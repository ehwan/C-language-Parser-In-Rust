
// This file was generated by rustylr 1.26.0
// This generated code is targeting rusty_lr version 3.33.0.
// There might be a build error if the version is not matched.
//
// ================================User Codes Begin================================
use rusty_lr::lr1;
use super::declarator;
use super::declarator::Declarator;
use super::expression;
use super::expression::Expression;
use super::statement;
use super::statement::Statement;
use crate::token::Token;

// =================================User Codes End=================================
/*
====================================Grammar=====================================

# of terminal classes: 88
# of states: 336

0: Constant -> constant_character
1: Constant -> constant_integer
2: Constant -> constant_long
3: Constant -> constant_unsigned_integer
4: Constant -> constant_unsigned_long
5: Constant -> constant_float
6: Constant -> constant_double
7: primary_expression -> ident
8: primary_expression -> Constant
9: primary_expression -> string_literal
10: primary_expression -> lparen expression rparen
11: postfix_expression -> primary_expression
12: postfix_expression -> postfix_expression lbracket expression rbracket
13: postfix_expression -> postfix_expression lparen rparen
14: postfix_expression -> postfix_expression lparen argument_expression_list rparen
15: postfix_expression -> postfix_expression dot ident
16: postfix_expression -> postfix_expression ptr_op ident
17: postfix_expression -> postfix_expression inc_op
18: postfix_expression -> postfix_expression dec_op
19: argument_expression_list -> assignment_expression
20: argument_expression_list -> argument_expression_list comma assignment_expression
21: unary_expression -> postfix_expression
22: unary_expression -> inc_op unary_expression
23: unary_expression -> dec_op unary_expression
24: unary_expression -> ampersand cast_expression
25: unary_expression -> star cast_expression
26: unary_expression -> plus cast_expression
27: unary_expression -> minus cast_expression
28: unary_expression -> tilde cast_expression
29: unary_expression -> exclamation cast_expression
30: unary_expression -> sizeof unary_expression
31: unary_expression -> sizeof lparen type_name rparen
32: cast_expression -> unary_expression
33: cast_expression -> lparen type_name rparen cast_expression
34: multiplicative_expression -> cast_expression
35: multiplicative_expression -> multiplicative_expression star cast_expression
36: multiplicative_expression -> multiplicative_expression slash cast_expression
37: multiplicative_expression -> multiplicative_expression percent cast_expression
38: additive_expression -> multiplicative_expression
39: additive_expression -> additive_expression plus multiplicative_expression
40: additive_expression -> additive_expression minus multiplicative_expression
41: shift_expression -> additive_expression
42: shift_expression -> shift_expression left_op additive_expression
43: shift_expression -> shift_expression right_op additive_expression
44: relational_expression -> shift_expression
45: relational_expression -> relational_expression less shift_expression
46: relational_expression -> relational_expression greater shift_expression
47: relational_expression -> relational_expression le shift_expression
48: relational_expression -> relational_expression ge shift_expression
49: equality_expression -> relational_expression
50: equality_expression -> equality_expression eq relational_expression
51: equality_expression -> equality_expression ne relational_expression
52: and_expression -> equality_expression
53: and_expression -> and_expression ampersand equality_expression
54: exclusive_or_expression -> and_expression
55: exclusive_or_expression -> exclusive_or_expression caret and_expression
56: inclusive_or_expression -> exclusive_or_expression
57: inclusive_or_expression -> inclusive_or_expression pipe exclusive_or_expression
58: logical_and_expression -> inclusive_or_expression
59: logical_and_expression -> logical_and_expression and_op inclusive_or_expression
60: logical_or_expression -> logical_and_expression
61: logical_or_expression -> logical_or_expression or_op logical_and_expression
62: conditional_expression -> logical_or_expression
63: conditional_expression -> logical_or_expression question expression colon conditional_expression
64: assignment_expression -> conditional_expression
65: assignment_expression -> unary_expression assign assignment_expression
66: assignment_expression -> unary_expression mul_assign assignment_expression
67: assignment_expression -> unary_expression div_assign assignment_expression
68: assignment_expression -> unary_expression mod_assign assignment_expression
69: assignment_expression -> unary_expression add_assign assignment_expression
70: assignment_expression -> unary_expression sub_assign assignment_expression
71: assignment_expression -> unary_expression left_assign assignment_expression
72: assignment_expression -> unary_expression right_assign assignment_expression
73: assignment_expression -> unary_expression and_assign assignment_expression
74: assignment_expression -> unary_expression xor_assign assignment_expression
75: assignment_expression -> unary_expression or_assign assignment_expression
76: expression -> assignment_expression
77: expression -> expression comma assignment_expression
78: initializer -> assignment_expression
79: initializer -> lbrace initializer_list rbrace
80: initializer -> lbrace initializer_list comma rbrace
81: initializer_list -> initializer
82: initializer_list -> initializer_list comma initializer
83: labeled_statement -> ident colon statement
84: labeled_statement -> case conditional_expression colon statement
85: labeled_statement -> default colon statement
86: statement_or_declaration -> statement
87: statement_or_declaration -> declaration
88: compound_statement -> lbrace statement_or_declaration* rbrace
89: expression_statement -> semicolon
90: expression_statement -> expression semicolon
91: selection_statement -> if_ lparen expression rparen statement
92: selection_statement -> if_ lparen expression rparen statement else_ statement
93: selection_statement -> switch lparen expression rparen statement
94: declaration_or_expression -> declaration
95: declaration_or_expression -> expression_statement
96: iteration_statement -> while_ lparen expression rparen statement
97: iteration_statement -> do_ statement while_ lparen expression rparen semicolon
98: iteration_statement -> for_ lparen declaration_or_expression expression_statement rparen statement
99: iteration_statement -> for_ lparen declaration_or_expression expression_statement expression rparen statement
100: jump_statement -> goto_ ident semicolon
101: jump_statement -> continue_ semicolon
102: jump_statement -> break_ semicolon
103: jump_statement -> return_ semicolon
104: jump_statement -> return_ expression semicolon
105: declaration -> declaration_specifier+ semicolon
106: declaration -> declaration_specifier+ init_declarator_list semicolon
107: function_definition -> declaration_specifier+ declarator compound_statement
108: function_definition -> declarator compound_statement
109: statement -> labeled_statement
110: statement -> compound_statement
111: statement -> expression_statement
112: statement -> selection_statement
113: statement -> iteration_statement
114: statement -> jump_statement
115: external_declaration -> function_definition
116: external_declaration -> declaration
117: translation_unit -> external_declaration*
118: type_qualifier -> const_
119: type_qualifier -> volatile
120: declarator -> direct_declarator
121: declarator -> star type_qualifier* declarator
122: direct_declarator -> ident
123: direct_declarator -> lparen declarator rparen
124: direct_declarator -> direct_declarator lbracket conditional_expression rbracket
125: direct_declarator -> direct_declarator lbracket rbracket
126: direct_declarator -> direct_declarator lparen parameter_type_list rparen
127: direct_declarator -> direct_declarator lparen rparen
128: abstract_declarator -> star type_qualifier* abstract_declarator
129: abstract_declarator -> star type_qualifier*
130: abstract_declarator -> direct_abstract_declarator
131: direct_abstract_declarator -> lparen abstract_declarator rparen
132: direct_abstract_declarator -> lbracket rbracket
133: direct_abstract_declarator -> lbracket conditional_expression rbracket
134: direct_abstract_declarator -> direct_abstract_declarator lbracket rbracket
135: direct_abstract_declarator -> direct_abstract_declarator lbracket conditional_expression rbracket
136: direct_abstract_declarator -> lparen rparen
137: direct_abstract_declarator -> lparen parameter_type_list rparen
138: direct_abstract_declarator -> direct_abstract_declarator lparen rparen
139: direct_abstract_declarator -> direct_abstract_declarator lparen parameter_type_list rparen
140: specifier_qualifier -> type_qualifier
141: specifier_qualifier -> type_specifier
142: type_name -> specifier_qualifier+ abstract_declarator?
143: type_specifier -> void_
144: type_specifier -> char_
145: type_specifier -> short_
146: type_specifier -> int_
147: type_specifier -> long_
148: type_specifier -> float_
149: type_specifier -> double_
150: type_specifier -> signed
151: type_specifier -> unsigned
152: type_specifier -> ident
153: type_specifier -> struct_or_union_specifier
154: type_specifier -> enum_specifier
155: storage_class_specifier -> typedef
156: storage_class_specifier -> extern_
157: storage_class_specifier -> static_
158: storage_class_specifier -> auto
159: storage_class_specifier -> register
160: declaration_specifier -> storage_class_specifier
161: declaration_specifier -> type_specifier
162: declaration_specifier -> type_qualifier
163: parameter_declaration -> declaration_specifier+ declarator
164: parameter_declaration -> declaration_specifier+ abstract_declarator
165: parameter_declaration -> declaration_specifier+
166: parameter_list -> parameter_declaration
167: parameter_list -> parameter_list comma parameter_declaration
168: parameter_type_list -> parameter_list
169: parameter_type_list -> parameter_list comma ellipsis
170: struct_or_union -> struct_
171: struct_or_union -> union_
172: struct_declarator_list -> declarator
173: struct_declarator_list -> struct_declarator_list comma declarator
174: struct_declaration -> specifier_qualifier+ struct_declarator_list semicolon
175: struct_or_union_specifier -> struct_or_union ident? lbrace struct_declaration* rbrace
176: struct_or_union_specifier -> struct_or_union ident
177: enum_specifier -> enum_ ident? lbrace enumerator_list rbrace
178: enum_specifier -> enum_ ident
179: enumerator_list -> enumerator
180: enumerator_list -> enumerator_list comma enumerator
181: enumerator -> ident
182: enumerator -> ident assign conditional_expression
183: init_declarator -> declarator
184: init_declarator -> declarator assign initializer
185: init_declarator_list -> init_declarator
186: init_declarator_list -> init_declarator_list comma init_declarator
187: statement_or_declaration+ -> statement_or_declaration
188: statement_or_declaration+ -> statement_or_declaration+ statement_or_declaration
189: statement_or_declaration* -> statement_or_declaration+
190: statement_or_declaration* -> 
191: declaration_specifier+ -> declaration_specifier
192: declaration_specifier+ -> declaration_specifier+ declaration_specifier
193: external_declaration+ -> external_declaration
194: external_declaration+ -> external_declaration+ external_declaration
195: external_declaration* -> external_declaration+
196: external_declaration* -> 
197: type_qualifier+ -> type_qualifier
198: type_qualifier+ -> type_qualifier+ type_qualifier
199: type_qualifier* -> type_qualifier+
200: type_qualifier* -> 
201: specifier_qualifier+ -> specifier_qualifier
202: specifier_qualifier+ -> specifier_qualifier+ specifier_qualifier
203: abstract_declarator? -> abstract_declarator
204: abstract_declarator? -> 
205: ident? -> ident
206: ident? -> 
207: struct_declaration+ -> struct_declaration
208: struct_declaration+ -> struct_declaration+ struct_declaration
209: struct_declaration* -> struct_declaration+
210: struct_declaration* -> 
211: Augmented -> translation_unit eof

*/
// =============================Generated Codes Begin==============================
/// type alias for `Context`
#[allow(non_camel_case_types, dead_code)]
pub type translation_unitContext = ::rusty_lr::parser::nondeterministic::Context<
    translation_unitDataStack,
    u16,
>;
/// type alias for CFG production rule
#[allow(non_camel_case_types, dead_code)]
pub type translation_unitRule = ::rusty_lr::rule::ProductionRule<
    translation_unitTerminalClasses,
    translation_unitNonTerminals,
>;
/// type alias for DFA state
#[allow(non_camel_case_types, dead_code)]
pub type translation_unitState = ::rusty_lr::parser::state::SparseState<
    translation_unitTerminalClasses,
    translation_unitNonTerminals,
    ::rusty_lr::parser::state::SmallVecU8,
    u16,
>;
/// type alias for `InvalidTerminalError`
#[allow(non_camel_case_types, dead_code)]
pub type translation_unitParseError = ::rusty_lr::parser::nondeterministic::ParseError<
    Token,
    ::rusty_lr::DefaultLocation,
    ::rusty_lr::DefaultReduceActionError,
>;
/// A enum that represents terminal classes
#[allow(non_camel_case_types, dead_code)]
#[derive(
    Clone,
    Copy,
    std::hash::Hash,
    std::cmp::PartialEq,
    std::cmp::Eq,
    std::cmp::PartialOrd,
    std::cmp::Ord
)]
pub enum translation_unitTerminalClasses {
    ident,
    lparen,
    rparen,
    string_literal,
    constant_character,
    constant_integer,
    constant_long,
    constant_unsigned_integer,
    constant_unsigned_long,
    constant_float,
    constant_double,
    lbracket,
    rbracket,
    lbrace,
    rbrace,
    comma,
    semicolon,
    ellipsis,
    question,
    colon,
    dot,
    ptr_op,
    inc_op,
    dec_op,
    sizeof,
    ampersand,
    exclamation,
    tilde,
    minus,
    plus,
    star,
    slash,
    percent,
    left_op,
    right_op,
    less,
    greater,
    caret,
    pipe,
    le,
    ge,
    eq,
    ne,
    and_op,
    or_op,
    assign,
    mul_assign,
    div_assign,
    mod_assign,
    add_assign,
    sub_assign,
    left_assign,
    right_assign,
    and_assign,
    xor_assign,
    or_assign,
    case,
    default,
    if_,
    else_,
    switch,
    while_,
    do_,
    for_,
    goto_,
    continue_,
    break_,
    return_,
    typedef,
    extern_,
    static_,
    auto,
    register,
    const_,
    volatile,
    void_,
    char_,
    short_,
    int_,
    long_,
    float_,
    double_,
    signed,
    unsigned,
    struct_,
    union_,
    enum_,
    __rustylr_other_terminals,
    error,
    eof,
}
impl ::rusty_lr::parser::terminalclass::TerminalClass
for translation_unitTerminalClasses {
    type Term = Token;
    const ERROR: Self = Self::error;
    const EOF: Self = Self::eof;
    fn as_str(&self) -> &'static str {
        match self {
            translation_unitTerminalClasses::ident => "ident",
            translation_unitTerminalClasses::lparen => "lparen",
            translation_unitTerminalClasses::rparen => "rparen",
            translation_unitTerminalClasses::string_literal => "string_literal",
            translation_unitTerminalClasses::constant_character => "constant_character",
            translation_unitTerminalClasses::constant_integer => "constant_integer",
            translation_unitTerminalClasses::constant_long => "constant_long",
            translation_unitTerminalClasses::constant_unsigned_integer => {
                "constant_unsigned_integer"
            }
            translation_unitTerminalClasses::constant_unsigned_long => {
                "constant_unsigned_long"
            }
            translation_unitTerminalClasses::constant_float => "constant_float",
            translation_unitTerminalClasses::constant_double => "constant_double",
            translation_unitTerminalClasses::lbracket => "lbracket",
            translation_unitTerminalClasses::rbracket => "rbracket",
            translation_unitTerminalClasses::lbrace => "lbrace",
            translation_unitTerminalClasses::rbrace => "rbrace",
            translation_unitTerminalClasses::comma => "comma",
            translation_unitTerminalClasses::semicolon => "semicolon",
            translation_unitTerminalClasses::ellipsis => "ellipsis",
            translation_unitTerminalClasses::question => "question",
            translation_unitTerminalClasses::colon => "colon",
            translation_unitTerminalClasses::dot => "dot",
            translation_unitTerminalClasses::ptr_op => "ptr_op",
            translation_unitTerminalClasses::inc_op => "inc_op",
            translation_unitTerminalClasses::dec_op => "dec_op",
            translation_unitTerminalClasses::sizeof => "sizeof",
            translation_unitTerminalClasses::ampersand => "ampersand",
            translation_unitTerminalClasses::exclamation => "exclamation",
            translation_unitTerminalClasses::tilde => "tilde",
            translation_unitTerminalClasses::minus => "minus",
            translation_unitTerminalClasses::plus => "plus",
            translation_unitTerminalClasses::star => "star",
            translation_unitTerminalClasses::slash => "slash",
            translation_unitTerminalClasses::percent => "percent",
            translation_unitTerminalClasses::left_op => "left_op",
            translation_unitTerminalClasses::right_op => "right_op",
            translation_unitTerminalClasses::less => "less",
            translation_unitTerminalClasses::greater => "greater",
            translation_unitTerminalClasses::caret => "caret",
            translation_unitTerminalClasses::pipe => "pipe",
            translation_unitTerminalClasses::le => "le",
            translation_unitTerminalClasses::ge => "ge",
            translation_unitTerminalClasses::eq => "eq",
            translation_unitTerminalClasses::ne => "ne",
            translation_unitTerminalClasses::and_op => "and_op",
            translation_unitTerminalClasses::or_op => "or_op",
            translation_unitTerminalClasses::assign => "assign",
            translation_unitTerminalClasses::mul_assign => "mul_assign",
            translation_unitTerminalClasses::div_assign => "div_assign",
            translation_unitTerminalClasses::mod_assign => "mod_assign",
            translation_unitTerminalClasses::add_assign => "add_assign",
            translation_unitTerminalClasses::sub_assign => "sub_assign",
            translation_unitTerminalClasses::left_assign => "left_assign",
            translation_unitTerminalClasses::right_assign => "right_assign",
            translation_unitTerminalClasses::and_assign => "and_assign",
            translation_unitTerminalClasses::xor_assign => "xor_assign",
            translation_unitTerminalClasses::or_assign => "or_assign",
            translation_unitTerminalClasses::case => "case",
            translation_unitTerminalClasses::default => "default",
            translation_unitTerminalClasses::if_ => "if_",
            translation_unitTerminalClasses::else_ => "else_",
            translation_unitTerminalClasses::switch => "switch",
            translation_unitTerminalClasses::while_ => "while_",
            translation_unitTerminalClasses::do_ => "do_",
            translation_unitTerminalClasses::for_ => "for_",
            translation_unitTerminalClasses::goto_ => "goto_",
            translation_unitTerminalClasses::continue_ => "continue_",
            translation_unitTerminalClasses::break_ => "break_",
            translation_unitTerminalClasses::return_ => "return_",
            translation_unitTerminalClasses::typedef => "typedef",
            translation_unitTerminalClasses::extern_ => "extern_",
            translation_unitTerminalClasses::static_ => "static_",
            translation_unitTerminalClasses::auto => "auto",
            translation_unitTerminalClasses::register => "register",
            translation_unitTerminalClasses::const_ => "const_",
            translation_unitTerminalClasses::volatile => "volatile",
            translation_unitTerminalClasses::void_ => "void_",
            translation_unitTerminalClasses::char_ => "char_",
            translation_unitTerminalClasses::short_ => "short_",
            translation_unitTerminalClasses::int_ => "int_",
            translation_unitTerminalClasses::long_ => "long_",
            translation_unitTerminalClasses::float_ => "float_",
            translation_unitTerminalClasses::double_ => "double_",
            translation_unitTerminalClasses::signed => "signed",
            translation_unitTerminalClasses::unsigned => "unsigned",
            translation_unitTerminalClasses::struct_ => "struct_",
            translation_unitTerminalClasses::union_ => "union_",
            translation_unitTerminalClasses::enum_ => "enum_",
            translation_unitTerminalClasses::__rustylr_other_terminals => {
                "__rustylr_other_terminals"
            }
            translation_unitTerminalClasses::error => "error",
            translation_unitTerminalClasses::eof => "eof",
        }
    }
    fn to_usize(&self) -> usize {
        *self as usize
    }
    fn precedence(&self) -> ::rusty_lr::parser::Precedence {
        match self {
            translation_unitTerminalClasses::else_ => {
                ::rusty_lr::parser::Precedence::new(1)
            }
            translation_unitTerminalClasses::eof => {
                unreachable!("eof token cannot be used in precedence levels")
            }
            _ => ::rusty_lr::parser::Precedence::none(),
        }
    }
    fn from_term(terminal: &Self::Term) -> Self {
        #[allow(unreachable_patterns)]
        match terminal {
            Token::Identifier(_) => translation_unitTerminalClasses::ident,
            Token::LeftParen => translation_unitTerminalClasses::lparen,
            Token::RightParen => translation_unitTerminalClasses::rparen,
            Token::StringLiteral(_) => translation_unitTerminalClasses::string_literal,
            Token::ConstantCharacter(_) => {
                translation_unitTerminalClasses::constant_character
            }
            Token::ConstantInteger(_) => {
                translation_unitTerminalClasses::constant_integer
            }
            Token::ConstantLong(_) => translation_unitTerminalClasses::constant_long,
            Token::ConstantUnsignedInteger(_) => {
                translation_unitTerminalClasses::constant_unsigned_integer
            }
            Token::ConstantUnsignedLong(_) => {
                translation_unitTerminalClasses::constant_unsigned_long
            }
            Token::ConstantFloat(_) => translation_unitTerminalClasses::constant_float,
            Token::ConstantDouble(_) => translation_unitTerminalClasses::constant_double,
            Token::LeftBracket => translation_unitTerminalClasses::lbracket,
            Token::RightBracket => translation_unitTerminalClasses::rbracket,
            Token::LeftBrace => translation_unitTerminalClasses::lbrace,
            Token::RightBrace => translation_unitTerminalClasses::rbrace,
            Token::Comma => translation_unitTerminalClasses::comma,
            Token::SemiColon => translation_unitTerminalClasses::semicolon,
            Token::Ellipsis => translation_unitTerminalClasses::ellipsis,
            Token::Question => translation_unitTerminalClasses::question,
            Token::Colon => translation_unitTerminalClasses::colon,
            Token::Dot => translation_unitTerminalClasses::dot,
            Token::PtrOp => translation_unitTerminalClasses::ptr_op,
            Token::IncOp => translation_unitTerminalClasses::inc_op,
            Token::DecOp => translation_unitTerminalClasses::dec_op,
            Token::Sizeof => translation_unitTerminalClasses::sizeof,
            Token::Ampersand => translation_unitTerminalClasses::ampersand,
            Token::Exclamation => translation_unitTerminalClasses::exclamation,
            Token::Tilde => translation_unitTerminalClasses::tilde,
            Token::Minus => translation_unitTerminalClasses::minus,
            Token::Plus => translation_unitTerminalClasses::plus,
            Token::Star => translation_unitTerminalClasses::star,
            Token::Slash => translation_unitTerminalClasses::slash,
            Token::Percent => translation_unitTerminalClasses::percent,
            Token::LeftOp => translation_unitTerminalClasses::left_op,
            Token::RightOp => translation_unitTerminalClasses::right_op,
            Token::LessThan => translation_unitTerminalClasses::less,
            Token::GreaterThan => translation_unitTerminalClasses::greater,
            Token::Caret => translation_unitTerminalClasses::caret,
            Token::Pipe => translation_unitTerminalClasses::pipe,
            Token::LeOp => translation_unitTerminalClasses::le,
            Token::GeOp => translation_unitTerminalClasses::ge,
            Token::EqOp => translation_unitTerminalClasses::eq,
            Token::NeOp => translation_unitTerminalClasses::ne,
            Token::AndOp => translation_unitTerminalClasses::and_op,
            Token::OrOp => translation_unitTerminalClasses::or_op,
            Token::Equal => translation_unitTerminalClasses::assign,
            Token::MulAssign => translation_unitTerminalClasses::mul_assign,
            Token::DivAssign => translation_unitTerminalClasses::div_assign,
            Token::ModAssign => translation_unitTerminalClasses::mod_assign,
            Token::AddAssign => translation_unitTerminalClasses::add_assign,
            Token::SubAssign => translation_unitTerminalClasses::sub_assign,
            Token::LeftAssign => translation_unitTerminalClasses::left_assign,
            Token::RightAssign => translation_unitTerminalClasses::right_assign,
            Token::AndAssign => translation_unitTerminalClasses::and_assign,
            Token::XorAssign => translation_unitTerminalClasses::xor_assign,
            Token::OrAssign => translation_unitTerminalClasses::or_assign,
            Token::Case => translation_unitTerminalClasses::case,
            Token::Default => translation_unitTerminalClasses::default,
            Token::If => translation_unitTerminalClasses::if_,
            Token::Else => translation_unitTerminalClasses::else_,
            Token::Switch => translation_unitTerminalClasses::switch,
            Token::While => translation_unitTerminalClasses::while_,
            Token::Do => translation_unitTerminalClasses::do_,
            Token::For => translation_unitTerminalClasses::for_,
            Token::Goto => translation_unitTerminalClasses::goto_,
            Token::Continue => translation_unitTerminalClasses::continue_,
            Token::Break => translation_unitTerminalClasses::break_,
            Token::Return => translation_unitTerminalClasses::return_,
            Token::Typedef => translation_unitTerminalClasses::typedef,
            Token::Extern => translation_unitTerminalClasses::extern_,
            Token::Static => translation_unitTerminalClasses::static_,
            Token::Auto => translation_unitTerminalClasses::auto,
            Token::Register => translation_unitTerminalClasses::register,
            Token::Const => translation_unitTerminalClasses::const_,
            Token::Volatile => translation_unitTerminalClasses::volatile,
            Token::Void => translation_unitTerminalClasses::void_,
            Token::Char => translation_unitTerminalClasses::char_,
            Token::Short => translation_unitTerminalClasses::short_,
            Token::Int => translation_unitTerminalClasses::int_,
            Token::Long => translation_unitTerminalClasses::long_,
            Token::Float => translation_unitTerminalClasses::float_,
            Token::Double => translation_unitTerminalClasses::double_,
            Token::Signed => translation_unitTerminalClasses::signed,
            Token::Unsigned => translation_unitTerminalClasses::unsigned,
            Token::Struct => translation_unitTerminalClasses::struct_,
            Token::Union => translation_unitTerminalClasses::union_,
            Token::Enum => translation_unitTerminalClasses::enum_,
            _ => translation_unitTerminalClasses::__rustylr_other_terminals,
        }
    }
}
impl std::fmt::Display for translation_unitTerminalClasses {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use ::rusty_lr::parser::terminalclass::TerminalClass;
        write!(f, "{}", self.as_str())
    }
}
impl std::fmt::Debug for translation_unitTerminalClasses {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use ::rusty_lr::parser::terminalclass::TerminalClass;
        write!(f, "{}", self.as_str())
    }
}
/// An enum that represents non-terminal symbols
#[allow(non_camel_case_types, dead_code)]
#[derive(
    Clone,
    Copy,
    std::hash::Hash,
    std::cmp::PartialEq,
    std::cmp::Eq,
    std::cmp::PartialOrd,
    std::cmp::Ord
)]
pub enum translation_unitNonTerminals {
    Constant,
    primary_expression,
    postfix_expression,
    argument_expression_list,
    unary_expression,
    cast_expression,
    multiplicative_expression,
    additive_expression,
    shift_expression,
    relational_expression,
    equality_expression,
    and_expression,
    exclusive_or_expression,
    inclusive_or_expression,
    logical_and_expression,
    logical_or_expression,
    conditional_expression,
    assignment_expression,
    expression,
    initializer,
    initializer_list,
    labeled_statement,
    statement_or_declaration,
    compound_statement,
    expression_statement,
    selection_statement,
    declaration_or_expression,
    iteration_statement,
    jump_statement,
    declaration,
    function_definition,
    statement,
    external_declaration,
    translation_unit,
    type_qualifier,
    declarator,
    direct_declarator,
    abstract_declarator,
    direct_abstract_declarator,
    specifier_qualifier,
    type_name,
    type_specifier,
    storage_class_specifier,
    declaration_specifier,
    parameter_declaration,
    parameter_list,
    parameter_type_list,
    struct_or_union,
    struct_declarator_list,
    struct_declaration,
    struct_or_union_specifier,
    enum_specifier,
    enumerator_list,
    enumerator,
    init_declarator,
    init_declarator_list,
    _statement_or_declarationPlus58,
    _statement_or_declarationStar59,
    _declaration_specifierPlus60,
    _external_declarationPlus61,
    _external_declarationStar62,
    _type_qualifierPlus63,
    _type_qualifierStar64,
    _specifier_qualifierPlus65,
    _abstract_declaratorQuestion66,
    _identQuestion67,
    _struct_declarationPlus68,
    _struct_declarationStar69,
    Augmented,
}
impl std::fmt::Display for translation_unitNonTerminals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use ::rusty_lr::parser::nonterminal::NonTerminal;
        write!(f, "{}", self.as_str())
    }
}
impl std::fmt::Debug for translation_unitNonTerminals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use ::rusty_lr::parser::nonterminal::NonTerminal;
        write!(f, "{}", self.as_str())
    }
}
impl ::rusty_lr::parser::nonterminal::NonTerminal for translation_unitNonTerminals {
    fn as_str(&self) -> &'static str {
        match self {
            translation_unitNonTerminals::Constant => "Constant",
            translation_unitNonTerminals::primary_expression => "primary_expression",
            translation_unitNonTerminals::postfix_expression => "postfix_expression",
            translation_unitNonTerminals::argument_expression_list => {
                "argument_expression_list"
            }
            translation_unitNonTerminals::unary_expression => "unary_expression",
            translation_unitNonTerminals::cast_expression => "cast_expression",
            translation_unitNonTerminals::multiplicative_expression => {
                "multiplicative_expression"
            }
            translation_unitNonTerminals::additive_expression => "additive_expression",
            translation_unitNonTerminals::shift_expression => "shift_expression",
            translation_unitNonTerminals::relational_expression => {
                "relational_expression"
            }
            translation_unitNonTerminals::equality_expression => "equality_expression",
            translation_unitNonTerminals::and_expression => "and_expression",
            translation_unitNonTerminals::exclusive_or_expression => {
                "exclusive_or_expression"
            }
            translation_unitNonTerminals::inclusive_or_expression => {
                "inclusive_or_expression"
            }
            translation_unitNonTerminals::logical_and_expression => {
                "logical_and_expression"
            }
            translation_unitNonTerminals::logical_or_expression => {
                "logical_or_expression"
            }
            translation_unitNonTerminals::conditional_expression => {
                "conditional_expression"
            }
            translation_unitNonTerminals::assignment_expression => {
                "assignment_expression"
            }
            translation_unitNonTerminals::expression => "expression",
            translation_unitNonTerminals::initializer => "initializer",
            translation_unitNonTerminals::initializer_list => "initializer_list",
            translation_unitNonTerminals::labeled_statement => "labeled_statement",
            translation_unitNonTerminals::statement_or_declaration => {
                "statement_or_declaration"
            }
            translation_unitNonTerminals::compound_statement => "compound_statement",
            translation_unitNonTerminals::expression_statement => "expression_statement",
            translation_unitNonTerminals::selection_statement => "selection_statement",
            translation_unitNonTerminals::declaration_or_expression => {
                "declaration_or_expression"
            }
            translation_unitNonTerminals::iteration_statement => "iteration_statement",
            translation_unitNonTerminals::jump_statement => "jump_statement",
            translation_unitNonTerminals::declaration => "declaration",
            translation_unitNonTerminals::function_definition => "function_definition",
            translation_unitNonTerminals::statement => "statement",
            translation_unitNonTerminals::external_declaration => "external_declaration",
            translation_unitNonTerminals::translation_unit => "translation_unit",
            translation_unitNonTerminals::type_qualifier => "type_qualifier",
            translation_unitNonTerminals::declarator => "declarator",
            translation_unitNonTerminals::direct_declarator => "direct_declarator",
            translation_unitNonTerminals::abstract_declarator => "abstract_declarator",
            translation_unitNonTerminals::direct_abstract_declarator => {
                "direct_abstract_declarator"
            }
            translation_unitNonTerminals::specifier_qualifier => "specifier_qualifier",
            translation_unitNonTerminals::type_name => "type_name",
            translation_unitNonTerminals::type_specifier => "type_specifier",
            translation_unitNonTerminals::storage_class_specifier => {
                "storage_class_specifier"
            }
            translation_unitNonTerminals::declaration_specifier => {
                "declaration_specifier"
            }
            translation_unitNonTerminals::parameter_declaration => {
                "parameter_declaration"
            }
            translation_unitNonTerminals::parameter_list => "parameter_list",
            translation_unitNonTerminals::parameter_type_list => "parameter_type_list",
            translation_unitNonTerminals::struct_or_union => "struct_or_union",
            translation_unitNonTerminals::struct_declarator_list => {
                "struct_declarator_list"
            }
            translation_unitNonTerminals::struct_declaration => "struct_declaration",
            translation_unitNonTerminals::struct_or_union_specifier => {
                "struct_or_union_specifier"
            }
            translation_unitNonTerminals::enum_specifier => "enum_specifier",
            translation_unitNonTerminals::enumerator_list => "enumerator_list",
            translation_unitNonTerminals::enumerator => "enumerator",
            translation_unitNonTerminals::init_declarator => "init_declarator",
            translation_unitNonTerminals::init_declarator_list => "init_declarator_list",
            translation_unitNonTerminals::_statement_or_declarationPlus58 => {
                "statement_or_declaration+"
            }
            translation_unitNonTerminals::_statement_or_declarationStar59 => {
                "statement_or_declaration*"
            }
            translation_unitNonTerminals::_declaration_specifierPlus60 => {
                "declaration_specifier+"
            }
            translation_unitNonTerminals::_external_declarationPlus61 => {
                "external_declaration+"
            }
            translation_unitNonTerminals::_external_declarationStar62 => {
                "external_declaration*"
            }
            translation_unitNonTerminals::_type_qualifierPlus63 => "type_qualifier+",
            translation_unitNonTerminals::_type_qualifierStar64 => "type_qualifier*",
            translation_unitNonTerminals::_specifier_qualifierPlus65 => {
                "specifier_qualifier+"
            }
            translation_unitNonTerminals::_abstract_declaratorQuestion66 => {
                "abstract_declarator?"
            }
            translation_unitNonTerminals::_identQuestion67 => "ident?",
            translation_unitNonTerminals::_struct_declarationPlus68 => {
                "struct_declaration+"
            }
            translation_unitNonTerminals::_struct_declarationStar69 => {
                "struct_declaration*"
            }
            translation_unitNonTerminals::Augmented => "Augmented",
        }
    }
    fn is_trace(&self) -> bool {
        match self {
            translation_unitNonTerminals::Constant => false,
            translation_unitNonTerminals::primary_expression => false,
            translation_unitNonTerminals::postfix_expression => false,
            translation_unitNonTerminals::argument_expression_list => false,
            translation_unitNonTerminals::unary_expression => false,
            translation_unitNonTerminals::cast_expression => false,
            translation_unitNonTerminals::multiplicative_expression => false,
            translation_unitNonTerminals::additive_expression => false,
            translation_unitNonTerminals::shift_expression => false,
            translation_unitNonTerminals::relational_expression => false,
            translation_unitNonTerminals::equality_expression => false,
            translation_unitNonTerminals::and_expression => false,
            translation_unitNonTerminals::exclusive_or_expression => false,
            translation_unitNonTerminals::inclusive_or_expression => false,
            translation_unitNonTerminals::logical_and_expression => false,
            translation_unitNonTerminals::logical_or_expression => false,
            translation_unitNonTerminals::conditional_expression => false,
            translation_unitNonTerminals::assignment_expression => false,
            translation_unitNonTerminals::expression => false,
            translation_unitNonTerminals::initializer => false,
            translation_unitNonTerminals::initializer_list => false,
            translation_unitNonTerminals::labeled_statement => false,
            translation_unitNonTerminals::statement_or_declaration => false,
            translation_unitNonTerminals::compound_statement => false,
            translation_unitNonTerminals::expression_statement => false,
            translation_unitNonTerminals::selection_statement => false,
            translation_unitNonTerminals::declaration_or_expression => false,
            translation_unitNonTerminals::iteration_statement => false,
            translation_unitNonTerminals::jump_statement => false,
            translation_unitNonTerminals::declaration => false,
            translation_unitNonTerminals::function_definition => false,
            translation_unitNonTerminals::statement => false,
            translation_unitNonTerminals::external_declaration => false,
            translation_unitNonTerminals::translation_unit => false,
            translation_unitNonTerminals::type_qualifier => false,
            translation_unitNonTerminals::declarator => false,
            translation_unitNonTerminals::direct_declarator => false,
            translation_unitNonTerminals::abstract_declarator => false,
            translation_unitNonTerminals::direct_abstract_declarator => false,
            translation_unitNonTerminals::specifier_qualifier => false,
            translation_unitNonTerminals::type_name => false,
            translation_unitNonTerminals::type_specifier => false,
            translation_unitNonTerminals::storage_class_specifier => false,
            translation_unitNonTerminals::declaration_specifier => false,
            translation_unitNonTerminals::parameter_declaration => false,
            translation_unitNonTerminals::parameter_list => false,
            translation_unitNonTerminals::parameter_type_list => false,
            translation_unitNonTerminals::struct_or_union => false,
            translation_unitNonTerminals::struct_declarator_list => false,
            translation_unitNonTerminals::struct_declaration => false,
            translation_unitNonTerminals::struct_or_union_specifier => false,
            translation_unitNonTerminals::enum_specifier => false,
            translation_unitNonTerminals::enumerator_list => false,
            translation_unitNonTerminals::enumerator => false,
            translation_unitNonTerminals::init_declarator => false,
            translation_unitNonTerminals::init_declarator_list => false,
            translation_unitNonTerminals::_statement_or_declarationPlus58 => false,
            translation_unitNonTerminals::_statement_or_declarationStar59 => false,
            translation_unitNonTerminals::_declaration_specifierPlus60 => false,
            translation_unitNonTerminals::_external_declarationPlus61 => false,
            translation_unitNonTerminals::_external_declarationStar62 => false,
            translation_unitNonTerminals::_type_qualifierPlus63 => false,
            translation_unitNonTerminals::_type_qualifierStar64 => false,
            translation_unitNonTerminals::_specifier_qualifierPlus65 => false,
            translation_unitNonTerminals::_abstract_declaratorQuestion66 => false,
            translation_unitNonTerminals::_identQuestion67 => false,
            translation_unitNonTerminals::_struct_declarationPlus68 => false,
            translation_unitNonTerminals::_struct_declarationStar69 => false,
            translation_unitNonTerminals::Augmented => false,
        }
    }
    fn nonterm_type(&self) -> Option<::rusty_lr::parser::nonterminal::NonTerminalType> {
        match self {
            translation_unitNonTerminals::Constant => None,
            translation_unitNonTerminals::primary_expression => None,
            translation_unitNonTerminals::postfix_expression => None,
            translation_unitNonTerminals::argument_expression_list => None,
            translation_unitNonTerminals::unary_expression => None,
            translation_unitNonTerminals::cast_expression => None,
            translation_unitNonTerminals::multiplicative_expression => None,
            translation_unitNonTerminals::additive_expression => None,
            translation_unitNonTerminals::shift_expression => None,
            translation_unitNonTerminals::relational_expression => None,
            translation_unitNonTerminals::equality_expression => None,
            translation_unitNonTerminals::and_expression => None,
            translation_unitNonTerminals::exclusive_or_expression => None,
            translation_unitNonTerminals::inclusive_or_expression => None,
            translation_unitNonTerminals::logical_and_expression => None,
            translation_unitNonTerminals::logical_or_expression => None,
            translation_unitNonTerminals::conditional_expression => None,
            translation_unitNonTerminals::assignment_expression => None,
            translation_unitNonTerminals::expression => None,
            translation_unitNonTerminals::initializer => None,
            translation_unitNonTerminals::initializer_list => None,
            translation_unitNonTerminals::labeled_statement => None,
            translation_unitNonTerminals::statement_or_declaration => None,
            translation_unitNonTerminals::compound_statement => None,
            translation_unitNonTerminals::expression_statement => None,
            translation_unitNonTerminals::selection_statement => None,
            translation_unitNonTerminals::declaration_or_expression => None,
            translation_unitNonTerminals::iteration_statement => None,
            translation_unitNonTerminals::jump_statement => None,
            translation_unitNonTerminals::declaration => None,
            translation_unitNonTerminals::function_definition => None,
            translation_unitNonTerminals::statement => None,
            translation_unitNonTerminals::external_declaration => None,
            translation_unitNonTerminals::translation_unit => None,
            translation_unitNonTerminals::type_qualifier => None,
            translation_unitNonTerminals::declarator => None,
            translation_unitNonTerminals::direct_declarator => None,
            translation_unitNonTerminals::abstract_declarator => None,
            translation_unitNonTerminals::direct_abstract_declarator => None,
            translation_unitNonTerminals::specifier_qualifier => None,
            translation_unitNonTerminals::type_name => None,
            translation_unitNonTerminals::type_specifier => None,
            translation_unitNonTerminals::storage_class_specifier => None,
            translation_unitNonTerminals::declaration_specifier => None,
            translation_unitNonTerminals::parameter_declaration => None,
            translation_unitNonTerminals::parameter_list => None,
            translation_unitNonTerminals::parameter_type_list => None,
            translation_unitNonTerminals::struct_or_union => None,
            translation_unitNonTerminals::struct_declarator_list => None,
            translation_unitNonTerminals::struct_declaration => None,
            translation_unitNonTerminals::struct_or_union_specifier => None,
            translation_unitNonTerminals::enum_specifier => None,
            translation_unitNonTerminals::enumerator_list => None,
            translation_unitNonTerminals::enumerator => None,
            translation_unitNonTerminals::init_declarator => None,
            translation_unitNonTerminals::init_declarator_list => None,
            translation_unitNonTerminals::_statement_or_declarationPlus58 => {
                Some(::rusty_lr::parser::nonterminal::NonTerminalType::PlusLeft)
            }
            translation_unitNonTerminals::_statement_or_declarationStar59 => {
                Some(::rusty_lr::parser::nonterminal::NonTerminalType::Star)
            }
            translation_unitNonTerminals::_declaration_specifierPlus60 => {
                Some(::rusty_lr::parser::nonterminal::NonTerminalType::PlusLeft)
            }
            translation_unitNonTerminals::_external_declarationPlus61 => {
                Some(::rusty_lr::parser::nonterminal::NonTerminalType::PlusLeft)
            }
            translation_unitNonTerminals::_external_declarationStar62 => {
                Some(::rusty_lr::parser::nonterminal::NonTerminalType::Star)
            }
            translation_unitNonTerminals::_type_qualifierPlus63 => {
                Some(::rusty_lr::parser::nonterminal::NonTerminalType::PlusLeft)
            }
            translation_unitNonTerminals::_type_qualifierStar64 => {
                Some(::rusty_lr::parser::nonterminal::NonTerminalType::Star)
            }
            translation_unitNonTerminals::_specifier_qualifierPlus65 => {
                Some(::rusty_lr::parser::nonterminal::NonTerminalType::PlusLeft)
            }
            translation_unitNonTerminals::_abstract_declaratorQuestion66 => {
                Some(::rusty_lr::parser::nonterminal::NonTerminalType::Optional)
            }
            translation_unitNonTerminals::_identQuestion67 => {
                Some(::rusty_lr::parser::nonterminal::NonTerminalType::Optional)
            }
            translation_unitNonTerminals::_struct_declarationPlus68 => {
                Some(::rusty_lr::parser::nonterminal::NonTerminalType::PlusLeft)
            }
            translation_unitNonTerminals::_struct_declarationStar69 => {
                Some(::rusty_lr::parser::nonterminal::NonTerminalType::Star)
            }
            translation_unitNonTerminals::Augmented => {
                Some(::rusty_lr::parser::nonterminal::NonTerminalType::Augmented)
            }
        }
    }
    fn to_usize(&self) -> usize {
        *self as usize
    }
}
/// tag for token that represents which stack a token is using
#[allow(unused_braces, unused_parens, non_snake_case, non_camel_case_types)]
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum translation_unitTags {
    __terminals,
    __stack2,
    __stack3,
    __stack4,
    __stack5,
    __stack6,
    __stack7,
    __stack8,
    __stack9,
    __stack10,
    __stack11,
    __stack12,
    __stack13,
    __stack14,
    __stack15,
    __stack16,
    __stack17,
    __stack18,
    __stack19,
    __stack20,
    __stack21,
    __stack22,
    __stack23,
    __stack24,
    __stack25,
    __stack26,
    __stack27,
    __stack28,
    __stack29,
    __stack30,
    __stack31,
    Empty,
}
/// enum for each non-terminal and terminal symbol, that actually hold data
#[allow(unused_braces, unused_parens, non_snake_case, non_camel_case_types)]
#[derive(Clone)]
pub struct translation_unitDataStack {
    pub __tags: Vec<translation_unitTags>,
    __terminals: Vec<Token>,
    __stack2: Vec<Expression>,
    __stack3: Vec<Vec<Expression>>,
    __stack4: Vec<Statement>,
    __stack5: Vec<statement::TranslationUnit>,
    __stack6: Vec<declarator::TypeQualifier>,
    __stack7: Vec<Declarator>,
    __stack8: Vec<declarator::SpecifierQualifier>,
    __stack9: Vec<declarator::Typename>,
    __stack10: Vec<declarator::TypeSpecifier>,
    __stack11: Vec<declarator::StorageClassSpecifier>,
    __stack12: Vec<declarator::DeclarationSpecifier>,
    __stack13: Vec<declarator::ParameterDeclaration>,
    __stack14: Vec<Vec<declarator::ParameterDeclaration>>,
    __stack15: Vec<declarator::ParameterList>,
    __stack16: Vec<bool>,
    __stack17: Vec<Vec<Declarator>>,
    __stack18: Vec<declarator::StructDeclaration>,
    __stack19: Vec<declarator::StructOrUnionSpecifier>,
    __stack20: Vec<declarator::EnumSpecifier>,
    __stack21: Vec<Vec<declarator::Enumerator>>,
    __stack22: Vec<declarator::Enumerator>,
    __stack23: Vec<declarator::DeclInit>,
    __stack24: Vec<Vec<declarator::DeclInit>>,
    __stack25: Vec<Vec<Statement>>,
    __stack26: Vec<Vec<declarator::DeclarationSpecifier>>,
    __stack27: Vec<Vec<declarator::TypeQualifier>>,
    __stack28: Vec<Vec<declarator::SpecifierQualifier>>,
    __stack29: Vec<Option<Declarator>>,
    __stack30: Vec<Option<Token>>,
    __stack31: Vec<Vec<declarator::StructDeclaration>>,
}
impl Default for translation_unitDataStack {
    fn default() -> Self {
        Self {
            __tags: Vec::new(),
            __terminals: Vec::new(),
            __stack2: Vec::new(),
            __stack3: Vec::new(),
            __stack4: Vec::new(),
            __stack5: Vec::new(),
            __stack6: Vec::new(),
            __stack7: Vec::new(),
            __stack8: Vec::new(),
            __stack9: Vec::new(),
            __stack10: Vec::new(),
            __stack11: Vec::new(),
            __stack12: Vec::new(),
            __stack13: Vec::new(),
            __stack14: Vec::new(),
            __stack15: Vec::new(),
            __stack16: Vec::new(),
            __stack17: Vec::new(),
            __stack18: Vec::new(),
            __stack19: Vec::new(),
            __stack20: Vec::new(),
            __stack21: Vec::new(),
            __stack22: Vec::new(),
            __stack23: Vec::new(),
            __stack24: Vec::new(),
            __stack25: Vec::new(),
            __stack26: Vec::new(),
            __stack27: Vec::new(),
            __stack28: Vec::new(),
            __stack29: Vec::new(),
            __stack30: Vec::new(),
            __stack31: Vec::new(),
        }
    }
}
#[allow(
    unused_braces,
    unused_parens,
    unused_variables,
    non_snake_case,
    unused_mut,
    dead_code
)]
impl translation_unitDataStack {
    ///Constant -> constant_character
    #[inline]
    fn reduce_Constant_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack2);
        let mut constant_character = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            if let Token::ConstantCharacter(value) = constant_character {
                Expression::ConstantCharacter(expression::ExprConstantCharacter {
                    value,
                })
            } else {
                unreachable!()
            }
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///Constant -> constant_integer
    #[inline]
    fn reduce_Constant_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack2);
        let mut constant_integer = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            if let Token::ConstantInteger(value) = constant_integer {
                Expression::ConstantInteger(expression::ExprConstantInteger {
                    value,
                })
            } else {
                unreachable!()
            }
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///Constant -> constant_long
    #[inline]
    fn reduce_Constant_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack2);
        let mut constant_long = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            if let Token::ConstantLong(value) = constant_long {
                Expression::ConstantLong(expression::ExprConstantLong {
                    value,
                })
            } else {
                unreachable!()
            }
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///Constant -> constant_unsigned_integer
    #[inline]
    fn reduce_Constant_3(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack2);
        let mut constant_unsigned_integer = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            if let Token::ConstantUnsignedInteger(value) = constant_unsigned_integer {
                Expression::ConstantUnsignedInteger(expression::ExprConstantUnsignedInteger {
                    value,
                })
            } else {
                unreachable!()
            }
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///Constant -> constant_unsigned_long
    #[inline]
    fn reduce_Constant_4(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack2);
        let mut constant_unsigned_long = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            if let Token::ConstantUnsignedLong(value) = constant_unsigned_long {
                Expression::ConstantUnsignedLong(expression::ExprConstantUnsignedLong {
                    value,
                })
            } else {
                unreachable!()
            }
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///Constant -> constant_float
    #[inline]
    fn reduce_Constant_5(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack2);
        let mut constant_float = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            if let Token::ConstantFloat(value) = constant_float {
                Expression::ConstantFloat(expression::ExprConstantFloat {
                    value,
                })
            } else {
                unreachable!()
            }
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///Constant -> constant_double
    #[inline]
    fn reduce_Constant_6(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack2);
        let mut constant_double = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            if let Token::ConstantDouble(value) = constant_double {
                Expression::ConstantDouble(expression::ExprConstantDouble {
                    value,
                })
            } else {
                unreachable!()
            }
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///primary_expression -> ident
    #[inline]
    fn reduce_primary_expression_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack2);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            if let Token::Identifier(name) = ident {
                Expression::Identifier(expression::ExprIdentifier { name })
            } else {
                unreachable!()
            }
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///primary_expression -> string_literal
    #[inline]
    fn reduce_primary_expression_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack2);
        let mut string_literal = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            if let Token::StringLiteral(value) = string_literal {
                Expression::String(expression::ExprString { value })
            } else {
                unreachable!()
            }
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///primary_expression -> lparen expression rparen
    #[inline]
    fn reduce_primary_expression_3(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(translation_unitTags::__stack2);
        let mut expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = expression;
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///postfix_expression -> postfix_expression lbracket expression rbracket
    #[inline]
    fn reduce_postfix_expression_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        let mut expression = __data_stack.__stack2.pop().unwrap();
        let mut postfix_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 4usize);
        let __res = {
            Expression::Bracket(expression::ExprBracket {
                src: Box::new(postfix_expression),
                index: Box::new(expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///postfix_expression -> postfix_expression lparen rparen
    #[inline]
    fn reduce_postfix_expression_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut postfix_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Paren(expression::ExprParen {
                src: Box::new(postfix_expression),
                args: Vec::new(),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///postfix_expression -> postfix_expression lparen argument_expression_list rparen
    #[inline]
    fn reduce_postfix_expression_3(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack3)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        let mut postfix_expression = __data_stack.__stack2.pop().unwrap();
        let mut argument_expression_list = __data_stack.__stack3.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 4usize);
        let __res = {
            Expression::Paren(expression::ExprParen {
                src: Box::new(postfix_expression),
                args: argument_expression_list,
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///postfix_expression -> postfix_expression dot ident
    #[inline]
    fn reduce_postfix_expression_4(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut postfix_expression = __data_stack.__stack2.pop().unwrap();
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            if let Token::Identifier(name) = ident {
                Expression::Member(expression::ExprMember {
                    src: Box::new(postfix_expression),
                    member: name,
                })
            } else {
                unreachable!()
            }
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///postfix_expression -> postfix_expression ptr_op ident
    #[inline]
    fn reduce_postfix_expression_5(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut postfix_expression = __data_stack.__stack2.pop().unwrap();
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            if let Token::Identifier(name) = ident {
                Expression::Arrow(expression::ExprArrow {
                    src: Box::new(postfix_expression),
                    member: name,
                })
            } else {
                unreachable!()
            }
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///postfix_expression -> postfix_expression inc_op
    #[inline]
    fn reduce_postfix_expression_6(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        let mut postfix_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Expression::Unary(expression::ExprUnary {
                op: expression::ExprUnaryOperator::IncrementPost,
                src: Box::new(postfix_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///postfix_expression -> postfix_expression dec_op
    #[inline]
    fn reduce_postfix_expression_7(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        let mut postfix_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Expression::Unary(expression::ExprUnary {
                op: expression::ExprUnaryOperator::DecrementPost,
                src: Box::new(postfix_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///argument_expression_list -> assignment_expression
    #[inline]
    fn reduce_argument_expression_list_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack3);
        let mut assignment_expression = __data_stack.__stack2.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![assignment_expression] };
        __data_stack.__stack3.push(__res);
        Ok(true)
    }
    ///argument_expression_list -> argument_expression_list comma assignment_expression
    #[inline]
    fn reduce_argument_expression_list_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack3)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut assignment_expression = __data_stack.__stack2.pop().unwrap();
        let mut argument_expression_list = __data_stack.__stack3.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            argument_expression_list.push(assignment_expression);
            argument_expression_list
        };
        __data_stack.__stack3.push(__res);
        Ok(true)
    }
    ///unary_expression -> postfix_expression
    #[inline]
    fn reduce_unary_expression_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        let mut postfix_expression = __data_stack.__stack2.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = postfix_expression;
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///unary_expression -> inc_op unary_expression
    #[inline]
    fn reduce_unary_expression_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(translation_unitTags::__stack2);
        let mut unary_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Expression::Unary(expression::ExprUnary {
                op: expression::ExprUnaryOperator::IncrementPre,
                src: Box::new(unary_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///unary_expression -> dec_op unary_expression
    #[inline]
    fn reduce_unary_expression_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(translation_unitTags::__stack2);
        let mut unary_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Expression::Unary(expression::ExprUnary {
                op: expression::ExprUnaryOperator::DecrementPre,
                src: Box::new(unary_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///unary_expression -> ampersand cast_expression
    #[inline]
    fn reduce_unary_expression_3(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(translation_unitTags::__stack2);
        let mut cast_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Expression::Unary(expression::ExprUnary {
                op: expression::ExprUnaryOperator::AddressOf,
                src: Box::new(cast_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///unary_expression -> star cast_expression
    #[inline]
    fn reduce_unary_expression_4(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(translation_unitTags::__stack2);
        let mut cast_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Expression::Unary(expression::ExprUnary {
                op: expression::ExprUnaryOperator::Dereference,
                src: Box::new(cast_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///unary_expression -> plus cast_expression
    #[inline]
    fn reduce_unary_expression_5(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(translation_unitTags::__stack2);
        let mut cast_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Expression::Unary(expression::ExprUnary {
                op: expression::ExprUnaryOperator::Plus,
                src: Box::new(cast_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///unary_expression -> minus cast_expression
    #[inline]
    fn reduce_unary_expression_6(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(translation_unitTags::__stack2);
        let mut cast_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Expression::Unary(expression::ExprUnary {
                op: expression::ExprUnaryOperator::Minus,
                src: Box::new(cast_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///unary_expression -> tilde cast_expression
    #[inline]
    fn reduce_unary_expression_7(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(translation_unitTags::__stack2);
        let mut cast_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Expression::Unary(expression::ExprUnary {
                op: expression::ExprUnaryOperator::BitwiseNot,
                src: Box::new(cast_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///unary_expression -> exclamation cast_expression
    #[inline]
    fn reduce_unary_expression_8(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(translation_unitTags::__stack2);
        let mut cast_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Expression::Unary(expression::ExprUnary {
                op: expression::ExprUnaryOperator::LogicalNot,
                src: Box::new(cast_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///unary_expression -> sizeof unary_expression
    #[inline]
    fn reduce_unary_expression_9(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(translation_unitTags::__stack2);
        let mut unary_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Expression::SizeofExpr(expression::ExprSizeOfExpr {
                expr: Box::new(unary_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///unary_expression -> sizeof lparen type_name rparen
    #[inline]
    fn reduce_unary_expression_10(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack9)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(translation_unitTags::__stack2);
        let mut type_name = __data_stack.__stack9.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 4usize);
        let __res = {
            Expression::SizeofType(expression::ExprSizeOfType {
                typename: type_name,
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///cast_expression -> unary_expression
    #[inline]
    fn reduce_cast_expression_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        let mut unary_expression = __data_stack.__stack2.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = unary_expression;
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///cast_expression -> lparen type_name rparen cast_expression
    #[inline]
    fn reduce_cast_expression_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack9)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(translation_unitTags::__stack2);
        let mut cast_expression = __data_stack.__stack2.pop().unwrap();
        let mut type_name = __data_stack.__stack9.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 4usize);
        let __res = {
            Expression::Cast(expression::ExprCast {
                src: Box::new(cast_expression),
                typename: type_name,
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///multiplicative_expression -> multiplicative_expression star cast_expression
    #[inline]
    fn reduce_multiplicative_expression_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut cast_expression = __data_stack.__stack2.pop().unwrap();
        let mut multiplicative_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::Mul,
                lhs: Box::new(multiplicative_expression),
                rhs: Box::new(cast_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///multiplicative_expression -> multiplicative_expression slash cast_expression
    #[inline]
    fn reduce_multiplicative_expression_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut cast_expression = __data_stack.__stack2.pop().unwrap();
        let mut multiplicative_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::Div,
                lhs: Box::new(multiplicative_expression),
                rhs: Box::new(cast_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///multiplicative_expression -> multiplicative_expression percent cast_expression
    #[inline]
    fn reduce_multiplicative_expression_3(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut cast_expression = __data_stack.__stack2.pop().unwrap();
        let mut multiplicative_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::Mod,
                lhs: Box::new(multiplicative_expression),
                rhs: Box::new(cast_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///additive_expression -> multiplicative_expression
    #[inline]
    fn reduce_additive_expression_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        let mut multiplicative_expression = __data_stack.__stack2.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = multiplicative_expression;
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///additive_expression -> additive_expression plus multiplicative_expression
    #[inline]
    fn reduce_additive_expression_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut multiplicative_expression = __data_stack.__stack2.pop().unwrap();
        let mut additive_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::Add,
                lhs: Box::new(additive_expression),
                rhs: Box::new(multiplicative_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///additive_expression -> additive_expression minus multiplicative_expression
    #[inline]
    fn reduce_additive_expression_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut multiplicative_expression = __data_stack.__stack2.pop().unwrap();
        let mut additive_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::Sub,
                lhs: Box::new(additive_expression),
                rhs: Box::new(multiplicative_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///shift_expression -> additive_expression
    #[inline]
    fn reduce_shift_expression_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        let mut additive_expression = __data_stack.__stack2.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = additive_expression;
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///shift_expression -> shift_expression left_op additive_expression
    #[inline]
    fn reduce_shift_expression_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut additive_expression = __data_stack.__stack2.pop().unwrap();
        let mut shift_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::ShiftLeft,
                lhs: Box::new(shift_expression),
                rhs: Box::new(additive_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///shift_expression -> shift_expression right_op additive_expression
    #[inline]
    fn reduce_shift_expression_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut additive_expression = __data_stack.__stack2.pop().unwrap();
        let mut shift_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::ShiftRight,
                lhs: Box::new(shift_expression),
                rhs: Box::new(additive_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///relational_expression -> shift_expression
    #[inline]
    fn reduce_relational_expression_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        let mut shift_expression = __data_stack.__stack2.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = shift_expression;
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///relational_expression -> relational_expression less shift_expression
    #[inline]
    fn reduce_relational_expression_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut shift_expression = __data_stack.__stack2.pop().unwrap();
        let mut relational_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::LessThan,
                lhs: Box::new(relational_expression),
                rhs: Box::new(shift_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///relational_expression -> relational_expression greater shift_expression
    #[inline]
    fn reduce_relational_expression_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut shift_expression = __data_stack.__stack2.pop().unwrap();
        let mut relational_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::GreaterThan,
                lhs: Box::new(relational_expression),
                rhs: Box::new(shift_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///relational_expression -> relational_expression le shift_expression
    #[inline]
    fn reduce_relational_expression_3(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut shift_expression = __data_stack.__stack2.pop().unwrap();
        let mut relational_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::LessThanOrEqual,
                lhs: Box::new(relational_expression),
                rhs: Box::new(shift_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///relational_expression -> relational_expression ge shift_expression
    #[inline]
    fn reduce_relational_expression_4(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut shift_expression = __data_stack.__stack2.pop().unwrap();
        let mut relational_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::GreaterThanOrEqual,
                lhs: Box::new(relational_expression),
                rhs: Box::new(shift_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///equality_expression -> relational_expression
    #[inline]
    fn reduce_equality_expression_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        let mut relational_expression = __data_stack.__stack2.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = relational_expression;
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///equality_expression -> equality_expression eq relational_expression
    #[inline]
    fn reduce_equality_expression_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut relational_expression = __data_stack.__stack2.pop().unwrap();
        let mut equality_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::Equal,
                lhs: Box::new(equality_expression),
                rhs: Box::new(relational_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///equality_expression -> equality_expression ne relational_expression
    #[inline]
    fn reduce_equality_expression_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut relational_expression = __data_stack.__stack2.pop().unwrap();
        let mut equality_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::NotEqual,
                lhs: Box::new(equality_expression),
                rhs: Box::new(relational_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///and_expression -> equality_expression
    #[inline]
    fn reduce_and_expression_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        let mut equality_expression = __data_stack.__stack2.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = equality_expression;
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///and_expression -> and_expression ampersand equality_expression
    #[inline]
    fn reduce_and_expression_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut equality_expression = __data_stack.__stack2.pop().unwrap();
        let mut and_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::BitwiseAnd,
                lhs: Box::new(and_expression),
                rhs: Box::new(equality_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///exclusive_or_expression -> and_expression
    #[inline]
    fn reduce_exclusive_or_expression_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        let mut and_expression = __data_stack.__stack2.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = and_expression;
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///exclusive_or_expression -> exclusive_or_expression caret and_expression
    #[inline]
    fn reduce_exclusive_or_expression_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut and_expression = __data_stack.__stack2.pop().unwrap();
        let mut exclusive_or_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::BitwiseXor,
                lhs: Box::new(exclusive_or_expression),
                rhs: Box::new(and_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///inclusive_or_expression -> exclusive_or_expression
    #[inline]
    fn reduce_inclusive_or_expression_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        let mut exclusive_or_expression = __data_stack.__stack2.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = exclusive_or_expression;
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///inclusive_or_expression -> inclusive_or_expression pipe exclusive_or_expression
    #[inline]
    fn reduce_inclusive_or_expression_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut exclusive_or_expression = __data_stack.__stack2.pop().unwrap();
        let mut inclusive_or_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::BitwiseOr,
                lhs: Box::new(inclusive_or_expression),
                rhs: Box::new(exclusive_or_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///logical_and_expression -> inclusive_or_expression
    #[inline]
    fn reduce_logical_and_expression_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        let mut inclusive_or_expression = __data_stack.__stack2.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = inclusive_or_expression;
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///logical_and_expression -> logical_and_expression and_op inclusive_or_expression
    #[inline]
    fn reduce_logical_and_expression_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut inclusive_or_expression = __data_stack.__stack2.pop().unwrap();
        let mut logical_and_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::LogicalAnd,
                lhs: Box::new(logical_and_expression),
                rhs: Box::new(inclusive_or_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///logical_or_expression -> logical_and_expression
    #[inline]
    fn reduce_logical_or_expression_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        let mut logical_and_expression = __data_stack.__stack2.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = logical_and_expression;
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///logical_or_expression -> logical_or_expression or_op logical_and_expression
    #[inline]
    fn reduce_logical_or_expression_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut logical_and_expression = __data_stack.__stack2.pop().unwrap();
        let mut logical_or_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::LogicalOr,
                lhs: Box::new(logical_or_expression),
                rhs: Box::new(logical_and_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///conditional_expression -> logical_or_expression
    #[inline]
    fn reduce_conditional_expression_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        let mut logical_or_expression = __data_stack.__stack2.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = logical_or_expression;
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///conditional_expression -> logical_or_expression question expression colon conditional_expression
    #[inline]
    fn reduce_conditional_expression_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 4usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        let mut conditional_expression = __data_stack.__stack2.pop().unwrap();
        let mut expression = __data_stack.__stack2.pop().unwrap();
        let mut logical_or_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 5usize);
        let __res = {
            Expression::Conditional(expression::ExprConditional {
                cond: Box::new(logical_or_expression),
                then_expr: Box::new(expression),
                else_expr: Box::new(conditional_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///assignment_expression -> unary_expression assign assignment_expression
    #[inline]
    fn reduce_assignment_expression_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut assignment_expression = __data_stack.__stack2.pop().unwrap();
        let mut unary_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::Assign(false),
                lhs: Box::new(unary_expression),
                rhs: Box::new(assignment_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///assignment_expression -> unary_expression mul_assign assignment_expression
    #[inline]
    fn reduce_assignment_expression_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut assignment_expression = __data_stack.__stack2.pop().unwrap();
        let mut unary_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::MulAssign,
                lhs: Box::new(unary_expression),
                rhs: Box::new(assignment_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///assignment_expression -> unary_expression div_assign assignment_expression
    #[inline]
    fn reduce_assignment_expression_3(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut assignment_expression = __data_stack.__stack2.pop().unwrap();
        let mut unary_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::DivAssign,
                lhs: Box::new(unary_expression),
                rhs: Box::new(assignment_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///assignment_expression -> unary_expression mod_assign assignment_expression
    #[inline]
    fn reduce_assignment_expression_4(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut assignment_expression = __data_stack.__stack2.pop().unwrap();
        let mut unary_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::ModAssign,
                lhs: Box::new(unary_expression),
                rhs: Box::new(assignment_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///assignment_expression -> unary_expression add_assign assignment_expression
    #[inline]
    fn reduce_assignment_expression_5(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut assignment_expression = __data_stack.__stack2.pop().unwrap();
        let mut unary_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::AddAssign,
                lhs: Box::new(unary_expression),
                rhs: Box::new(assignment_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///assignment_expression -> unary_expression sub_assign assignment_expression
    #[inline]
    fn reduce_assignment_expression_6(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut assignment_expression = __data_stack.__stack2.pop().unwrap();
        let mut unary_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::SubAssign,
                lhs: Box::new(unary_expression),
                rhs: Box::new(assignment_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///assignment_expression -> unary_expression left_assign assignment_expression
    #[inline]
    fn reduce_assignment_expression_7(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut assignment_expression = __data_stack.__stack2.pop().unwrap();
        let mut unary_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::ShiftLeftAssign,
                lhs: Box::new(unary_expression),
                rhs: Box::new(assignment_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///assignment_expression -> unary_expression right_assign assignment_expression
    #[inline]
    fn reduce_assignment_expression_8(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut assignment_expression = __data_stack.__stack2.pop().unwrap();
        let mut unary_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::ShiftRightAssign,
                lhs: Box::new(unary_expression),
                rhs: Box::new(assignment_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///assignment_expression -> unary_expression and_assign assignment_expression
    #[inline]
    fn reduce_assignment_expression_9(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut assignment_expression = __data_stack.__stack2.pop().unwrap();
        let mut unary_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::BitwiseAndAssign,
                lhs: Box::new(unary_expression),
                rhs: Box::new(assignment_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///assignment_expression -> unary_expression xor_assign assignment_expression
    #[inline]
    fn reduce_assignment_expression_10(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut assignment_expression = __data_stack.__stack2.pop().unwrap();
        let mut unary_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::BitwiseXorAssign,
                lhs: Box::new(unary_expression),
                rhs: Box::new(assignment_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///assignment_expression -> unary_expression or_assign assignment_expression
    #[inline]
    fn reduce_assignment_expression_11(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut assignment_expression = __data_stack.__stack2.pop().unwrap();
        let mut unary_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::BitwiseOrAssign,
                lhs: Box::new(unary_expression),
                rhs: Box::new(assignment_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///expression -> expression comma assignment_expression
    #[inline]
    fn reduce_expression_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut assignment_expression = __data_stack.__stack2.pop().unwrap();
        let mut expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::Binary(expression::ExprBinary {
                op: expression::ExprBinaryOperator::Comma,
                lhs: Box::new(expression),
                rhs: Box::new(assignment_expression),
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///initializer -> lbrace initializer_list rbrace
    #[inline]
    fn reduce_initializer_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack3)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(translation_unitTags::__stack2);
        let mut initializer_list = __data_stack.__stack3.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Expression::InitializerList(expression::ExprInitializerList {
                initializers: initializer_list,
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///initializer -> lbrace initializer_list comma rbrace
    #[inline]
    fn reduce_initializer_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack3)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(translation_unitTags::__stack2);
        let mut initializer_list = __data_stack.__stack3.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 4usize);
        let __res = {
            Expression::InitializerList(expression::ExprInitializerList {
                initializers: initializer_list,
            })
        };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///initializer_list -> initializer
    #[inline]
    fn reduce_initializer_list_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack3);
        let mut initializer = __data_stack.__stack2.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![initializer] };
        __data_stack.__stack3.push(__res);
        Ok(true)
    }
    ///initializer_list -> initializer_list comma initializer
    #[inline]
    fn reduce_initializer_list_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack3)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut initializer = __data_stack.__stack2.pop().unwrap();
        let mut initializer_list = __data_stack.__stack3.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            initializer_list.push(initializer);
            initializer_list
        };
        __data_stack.__stack3.push(__res);
        Ok(true)
    }
    ///labeled_statement -> ident colon statement
    #[inline]
    fn reduce_labeled_statement_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack4)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(translation_unitTags::__stack4);
        let mut statement = __data_stack.__stack4.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            if let Token::Identifier(label) = ident {
                Statement::Labeled(statement::StmtLabeled {
                    label,
                    statement: Box::new(statement),
                })
            } else {
                unreachable!()
            }
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///labeled_statement -> case conditional_expression colon statement
    #[inline]
    fn reduce_labeled_statement_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack4)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(translation_unitTags::__stack4);
        let mut constant_expression = __data_stack.__stack2.pop().unwrap();
        let mut statement = __data_stack.__stack4.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 4usize);
        let __res = {
            Statement::Case(statement::StmtCase {
                value: constant_expression,
                statement: Box::new(statement),
            })
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///labeled_statement -> default colon statement
    #[inline]
    fn reduce_labeled_statement_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack4)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(translation_unitTags::__stack4);
        let mut statement = __data_stack.__stack4.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Statement::Default(statement::StmtDefault {
                statement: Box::new(statement),
            })
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///compound_statement -> lbrace statement_or_declaration* rbrace
    #[inline]
    fn reduce_compound_statement_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack25)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(translation_unitTags::__stack4);
        let mut statement_or_declaration = __data_stack.__stack25.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Statement::Compound(statement::StmtCompound {
                statements: statement_or_declaration,
            })
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///expression_statement -> semicolon
    #[inline]
    fn reduce_expression_statement_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack4);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { Statement::Null(statement::StmtNull {}) };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///expression_statement -> expression semicolon
    #[inline]
    fn reduce_expression_statement_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack2)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(translation_unitTags::__stack4);
        let mut expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Statement::Expression(statement::StmtExpression {
                expression: expression,
            })
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///selection_statement -> if_ lparen expression rparen statement
    #[inline]
    fn reduce_selection_statement_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack4)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 4usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 5usize);
        __data_stack.__tags.push(translation_unitTags::__stack4);
        let mut expression = __data_stack.__stack2.pop().unwrap();
        let mut statement = __data_stack.__stack4.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 5usize);
        let __res = {
            Statement::If(statement::StmtIf {
                cond: expression,
                then_statement: Box::new(statement),
                else_statement: None,
            })
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///selection_statement -> if_ lparen expression rparen statement else_ statement
    #[inline]
    fn reduce_selection_statement_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack4)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack4)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 4usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 5usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 6usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 7usize);
        __data_stack.__tags.push(translation_unitTags::__stack4);
        let mut expression = __data_stack.__stack2.pop().unwrap();
        let mut elsestmt = __data_stack.__stack4.pop().unwrap();
        let mut thenstmt = __data_stack.__stack4.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 4usize);
        __location_stack.truncate(__location_stack.len() - 7usize);
        let __res = {
            Statement::If(statement::StmtIf {
                cond: expression,
                then_statement: Box::new(thenstmt),
                else_statement: Some(Box::new(elsestmt)),
            })
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///selection_statement -> switch lparen expression rparen statement
    #[inline]
    fn reduce_selection_statement_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack4)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 4usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 5usize);
        __data_stack.__tags.push(translation_unitTags::__stack4);
        let mut expression = __data_stack.__stack2.pop().unwrap();
        let mut statement = __data_stack.__stack4.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 5usize);
        let __res = {
            Statement::Switch(statement::StmtSwitch {
                target: expression,
                statement: Box::new(statement),
            })
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///iteration_statement -> while_ lparen expression rparen statement
    #[inline]
    fn reduce_iteration_statement_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack4)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 4usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 5usize);
        __data_stack.__tags.push(translation_unitTags::__stack4);
        let mut expression = __data_stack.__stack2.pop().unwrap();
        let mut statement = __data_stack.__stack4.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 5usize);
        let __res = {
            Statement::While(statement::StmtWhile {
                cond: expression,
                statement: Box::new(statement),
            })
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///iteration_statement -> do_ statement while_ lparen expression rparen semicolon
    #[inline]
    fn reduce_iteration_statement_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 4usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 5usize) == Some(&
                translation_unitTags::__stack4)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 6usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 7usize);
        __data_stack.__tags.push(translation_unitTags::__stack4);
        let mut expression = __data_stack.__stack2.pop().unwrap();
        let mut statement = __data_stack.__stack4.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 5usize);
        __location_stack.truncate(__location_stack.len() - 7usize);
        let __res = {
            Statement::DoWhile(statement::StmtDoWhile {
                cond: expression,
                statement: Box::new(statement),
            })
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///iteration_statement -> for_ lparen declaration_or_expression expression_statement rparen statement
    #[inline]
    fn reduce_iteration_statement_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack4)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack4)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                translation_unitTags::__stack4)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 4usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 5usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 6usize);
        __data_stack.__tags.push(translation_unitTags::__stack4);
        let mut body = __data_stack.__stack4.pop().unwrap();
        let mut cond = __data_stack.__stack4.pop().unwrap();
        let mut init = __data_stack.__stack4.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 6usize);
        let __res = {
            let Statement::Expression(cond) = cond else { unreachable!() };
            Statement::For(statement::StmtFor {
                init: Box::new(init),
                cond: cond.expression,
                next: None,
                statement: Box::new(body),
            })
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///iteration_statement -> for_ lparen declaration_or_expression expression_statement expression rparen statement
    #[inline]
    fn reduce_iteration_statement_3(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack4)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                translation_unitTags::__stack4)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 4usize) == Some(&
                translation_unitTags::__stack4)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 5usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 6usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 7usize);
        __data_stack.__tags.push(translation_unitTags::__stack4);
        let mut next = __data_stack.__stack2.pop().unwrap();
        let mut body = __data_stack.__stack4.pop().unwrap();
        let mut cond = __data_stack.__stack4.pop().unwrap();
        let mut init = __data_stack.__stack4.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 7usize);
        let __res = {
            let Statement::Expression(cond) = cond else { unreachable!() };
            Statement::For(statement::StmtFor {
                init: Box::new(init),
                cond: cond.expression,
                next: Some(next),
                statement: Box::new(body),
            })
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///jump_statement -> goto_ ident semicolon
    #[inline]
    fn reduce_jump_statement_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(translation_unitTags::__stack4);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            let Token::Identifier(ident) = ident else { unreachable!() };
            Statement::Goto(statement::StmtGoto {
                label: ident,
            })
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///jump_statement -> continue_ semicolon
    #[inline]
    fn reduce_jump_statement_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(translation_unitTags::__stack4);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = { Statement::Continue(statement::StmtContinue {}) };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///jump_statement -> break_ semicolon
    #[inline]
    fn reduce_jump_statement_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(translation_unitTags::__stack4);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = { Statement::Break(statement::StmtBreak {}) };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///jump_statement -> return_ semicolon
    #[inline]
    fn reduce_jump_statement_3(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(translation_unitTags::__stack4);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Statement::Return(statement::StmtReturn {
                expr: None,
            })
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///jump_statement -> return_ expression semicolon
    #[inline]
    fn reduce_jump_statement_4(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(translation_unitTags::__stack4);
        let mut expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Statement::Return(statement::StmtReturn {
                expr: Some(expression),
            })
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///declaration -> declaration_specifier+ semicolon
    #[inline]
    fn reduce_declaration_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack26)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(translation_unitTags::__stack4);
        let mut declaration_specifier = __data_stack.__stack26.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Statement::Declaration(statement::StmtDeclaration {
                specs: declaration_specifier,
                inits: None,
            })
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///declaration -> declaration_specifier+ init_declarator_list semicolon
    #[inline]
    fn reduce_declaration_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack24)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack26)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(translation_unitTags::__stack4);
        let mut inits = __data_stack.__stack24.pop().unwrap();
        let mut declaration_specifier = __data_stack.__stack26.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Statement::Declaration(statement::StmtDeclaration {
                specs: declaration_specifier,
                inits: Some(inits),
            })
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///function_definition -> declaration_specifier+ declarator compound_statement
    #[inline]
    fn reduce_function_definition_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack4)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack26)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(translation_unitTags::__stack4);
        let mut declaration_specifier = __data_stack.__stack26.pop().unwrap();
        let mut compound_statement = __data_stack.__stack4.pop().unwrap();
        let mut declarator = __data_stack.__stack7.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Statement::FunctionDefinition(statement::StmtFunctionDefinition {
                specs: Some(declaration_specifier),
                decl: declarator,
                body: Box::new(compound_statement),
            })
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///function_definition -> declarator compound_statement
    #[inline]
    fn reduce_function_definition_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack4)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(translation_unitTags::__stack4);
        let mut compound_statement = __data_stack.__stack4.pop().unwrap();
        let mut declarator = __data_stack.__stack7.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Statement::FunctionDefinition(statement::StmtFunctionDefinition {
                specs: None,
                decl: declarator,
                body: Box::new(compound_statement),
            })
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///translation_unit -> external_declaration*
    #[inline]
    fn reduce_translation_unit_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack25)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack5);
        let mut external_declaration = __data_stack.__stack25.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            statement::TranslationUnit {
                statements: external_declaration,
            }
        };
        __data_stack.__stack5.push(__res);
        Ok(true)
    }
    ///type_qualifier -> const_
    #[inline]
    fn reduce_type_qualifier_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack6);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { declarator::TypeQualifier::Const };
        __data_stack.__stack6.push(__res);
        Ok(true)
    }
    ///type_qualifier -> volatile
    #[inline]
    fn reduce_type_qualifier_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack6);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { declarator::TypeQualifier::Volatile };
        __data_stack.__stack6.push(__res);
        Ok(true)
    }
    ///declarator -> direct_declarator
    #[inline]
    fn reduce_declarator_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack7)
            );
        }
        let mut direct_declarator = __data_stack.__stack7.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = direct_declarator;
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///declarator -> star type_qualifier* declarator
    #[inline]
    fn reduce_declarator_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack27)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(translation_unitTags::__stack7);
        let mut type_qualifier = __data_stack.__stack27.pop().unwrap();
        let mut declarator = __data_stack.__stack7.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            while let Some(type_qual) = type_qualifier.pop() {
                match type_qual {
                    declarator::TypeQualifier::Const => {
                        declarator = Declarator::Const(declarator::DeclConst {
                            declarator: Some(Box::new(declarator)),
                        });
                    }
                    declarator::TypeQualifier::Volatile => {
                        declarator = Declarator::Volatile(declarator::DeclVolatile {
                            declarator: Some(Box::new(declarator)),
                        });
                    }
                }
            }
            declarator = Declarator::Pointer(declarator::DeclPointer {
                declarator: Some(Box::new(declarator)),
            });
            declarator
        };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///direct_declarator -> ident
    #[inline]
    fn reduce_direct_declarator_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack7);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            let Token::Identifier(name) = ident else { unreachable!() };
            Declarator::Identifier(declarator::DeclIdentifier { name })
        };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///direct_declarator -> lparen declarator rparen
    #[inline]
    fn reduce_direct_declarator_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(translation_unitTags::__stack7);
        let mut declarator = __data_stack.__stack7.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = declarator;
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///direct_declarator -> direct_declarator lbracket conditional_expression rbracket
    #[inline]
    fn reduce_direct_declarator_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                translation_unitTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        let mut constant_expression = __data_stack.__stack2.pop().unwrap();
        let mut direct_declarator = __data_stack.__stack7.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 4usize);
        let __res = {
            Declarator::ArrayFixed(declarator::DeclArrayFixed {
                declarator: Some(Box::new(direct_declarator)),
                size: constant_expression,
            })
        };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///direct_declarator -> direct_declarator lbracket rbracket
    #[inline]
    fn reduce_direct_declarator_3(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut direct_declarator = __data_stack.__stack7.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Declarator::ArrayUnbounded(declarator::DeclArrayUnbounded {
                declarator: Some(Box::new(direct_declarator)),
            })
        };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///direct_declarator -> direct_declarator lparen parameter_type_list rparen
    #[inline]
    fn reduce_direct_declarator_4(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack15)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                translation_unitTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        let mut parameter_type_list = __data_stack.__stack15.pop().unwrap();
        let mut direct_declarator = __data_stack.__stack7.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 4usize);
        let __res = {
            Declarator::Function(declarator::DeclFunction {
                declarator: Some(Box::new(direct_declarator)),
                params: parameter_type_list,
            })
        };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///direct_declarator -> direct_declarator lparen rparen
    #[inline]
    fn reduce_direct_declarator_5(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut direct_declarator = __data_stack.__stack7.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Declarator::Function(declarator::DeclFunction {
                declarator: Some(Box::new(direct_declarator)),
                params: declarator::ParameterList {
                    params: Vec::new(),
                    variadic: false,
                },
            })
        };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///abstract_declarator -> star type_qualifier* abstract_declarator
    #[inline]
    fn reduce_abstract_declarator_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack27)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(translation_unitTags::__stack7);
        let mut type_qualifier = __data_stack.__stack27.pop().unwrap();
        let mut abstract_declarator = __data_stack.__stack7.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            let mut declarator = abstract_declarator;
            while let Some(type_qual) = type_qualifier.pop() {
                match type_qual {
                    declarator::TypeQualifier::Const => {
                        declarator = Declarator::Const(declarator::DeclConst {
                            declarator: Some(Box::new(declarator)),
                        });
                    }
                    declarator::TypeQualifier::Volatile => {
                        declarator = Declarator::Volatile(declarator::DeclVolatile {
                            declarator: Some(Box::new(declarator)),
                        });
                    }
                }
            }
            declarator = Declarator::Pointer(declarator::DeclPointer {
                declarator: Some(Box::new(declarator)),
            });
            declarator
        };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///abstract_declarator -> star type_qualifier*
    #[inline]
    fn reduce_abstract_declarator_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack27)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(translation_unitTags::__stack7);
        let mut type_qualifier = __data_stack.__stack27.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            let mut declarator = None;
            while let Some(type_qual) = type_qualifier.pop() {
                match type_qual {
                    declarator::TypeQualifier::Const => {
                        declarator = Some(
                            Declarator::Const(declarator::DeclConst {
                                declarator: declarator.map(Box::new),
                            }),
                        );
                    }
                    declarator::TypeQualifier::Volatile => {
                        declarator = Some(
                            Declarator::Volatile(declarator::DeclVolatile {
                                declarator: declarator.map(Box::new),
                            }),
                        );
                    }
                }
            }
            Declarator::Pointer(declarator::DeclPointer {
                declarator: declarator.map(Box::new),
            })
        };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///abstract_declarator -> direct_abstract_declarator
    #[inline]
    fn reduce_abstract_declarator_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack7)
            );
        }
        let mut direct_abstract_declarator = __data_stack.__stack7.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = direct_abstract_declarator;
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///direct_abstract_declarator -> lparen abstract_declarator rparen
    #[inline]
    fn reduce_direct_abstract_declarator_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(translation_unitTags::__stack7);
        let mut abstract_declarator = __data_stack.__stack7.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = abstract_declarator;
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///direct_abstract_declarator -> lbracket rbracket
    #[inline]
    fn reduce_direct_abstract_declarator_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(translation_unitTags::__stack7);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Declarator::ArrayUnbounded(declarator::DeclArrayUnbounded {
                declarator: None,
            })
        };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///direct_abstract_declarator -> lbracket conditional_expression rbracket
    #[inline]
    fn reduce_direct_abstract_declarator_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(translation_unitTags::__stack7);
        let mut constant_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Declarator::ArrayFixed(declarator::DeclArrayFixed {
                declarator: None,
                size: constant_expression,
            })
        };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///direct_abstract_declarator -> direct_abstract_declarator lbracket rbracket
    #[inline]
    fn reduce_direct_abstract_declarator_3(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut direct_abstract_declarator = __data_stack.__stack7.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Declarator::ArrayUnbounded(declarator::DeclArrayUnbounded {
                declarator: Some(Box::new(direct_abstract_declarator)),
            })
        };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///direct_abstract_declarator -> direct_abstract_declarator lbracket conditional_expression rbracket
    #[inline]
    fn reduce_direct_abstract_declarator_4(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                translation_unitTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        let mut constant_expression = __data_stack.__stack2.pop().unwrap();
        let mut direct_abstract_declarator = __data_stack.__stack7.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 4usize);
        let __res = {
            Declarator::ArrayFixed(declarator::DeclArrayFixed {
                declarator: Some(Box::new(direct_abstract_declarator)),
                size: constant_expression,
            })
        };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///direct_abstract_declarator -> lparen rparen
    #[inline]
    fn reduce_direct_abstract_declarator_5(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(translation_unitTags::__stack7);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Declarator::Function(declarator::DeclFunction {
                declarator: None,
                params: declarator::ParameterList {
                    params: Vec::new(),
                    variadic: false,
                },
            })
        };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///direct_abstract_declarator -> lparen parameter_type_list rparen
    #[inline]
    fn reduce_direct_abstract_declarator_6(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack15)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(translation_unitTags::__stack7);
        let mut parameter_type_list = __data_stack.__stack15.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Declarator::Function(declarator::DeclFunction {
                declarator: None,
                params: parameter_type_list,
            })
        };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///direct_abstract_declarator -> direct_abstract_declarator lparen rparen
    #[inline]
    fn reduce_direct_abstract_declarator_7(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut direct_abstract_declarator = __data_stack.__stack7.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            Declarator::Function(declarator::DeclFunction {
                declarator: Some(Box::new(direct_abstract_declarator)),
                params: declarator::ParameterList {
                    params: Vec::new(),
                    variadic: false,
                },
            })
        };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///direct_abstract_declarator -> direct_abstract_declarator lparen parameter_type_list rparen
    #[inline]
    fn reduce_direct_abstract_declarator_8(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack15)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                translation_unitTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        let mut parameter_type_list = __data_stack.__stack15.pop().unwrap();
        let mut direct_abstract_declarator = __data_stack.__stack7.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 4usize);
        let __res = {
            Declarator::Function(declarator::DeclFunction {
                declarator: Some(Box::new(direct_abstract_declarator)),
                params: parameter_type_list,
            })
        };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///specifier_qualifier -> type_qualifier
    #[inline]
    fn reduce_specifier_qualifier_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack6)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack8);
        let mut type_qualifier = __data_stack.__stack6.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { declarator::SpecifierQualifier::TypeQualifier(type_qualifier) };
        __data_stack.__stack8.push(__res);
        Ok(true)
    }
    ///specifier_qualifier -> type_specifier
    #[inline]
    fn reduce_specifier_qualifier_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack10)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack8);
        let mut type_specifier = __data_stack.__stack10.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { declarator::SpecifierQualifier::TypeSpecifier(type_specifier) };
        __data_stack.__stack8.push(__res);
        Ok(true)
    }
    ///type_name -> specifier_qualifier+ abstract_declarator?
    #[inline]
    fn reduce_type_name_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack29)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack28)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(translation_unitTags::__stack9);
        let mut specifier_qualifier = __data_stack.__stack28.pop().unwrap();
        let mut abstract_declarator = __data_stack.__stack29.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            declarator::Typename {
                specs: specifier_qualifier,
                declarator: abstract_declarator.map(Box::new),
            }
        };
        __data_stack.__stack9.push(__res);
        Ok(true)
    }
    ///type_specifier -> void_
    #[inline]
    fn reduce_type_specifier_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack10);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { declarator::TypeSpecifier::Void };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///type_specifier -> char_
    #[inline]
    fn reduce_type_specifier_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack10);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { declarator::TypeSpecifier::Char };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///type_specifier -> short_
    #[inline]
    fn reduce_type_specifier_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack10);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { declarator::TypeSpecifier::Short };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///type_specifier -> int_
    #[inline]
    fn reduce_type_specifier_3(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack10);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { declarator::TypeSpecifier::Int };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///type_specifier -> long_
    #[inline]
    fn reduce_type_specifier_4(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack10);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { declarator::TypeSpecifier::Long };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///type_specifier -> float_
    #[inline]
    fn reduce_type_specifier_5(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack10);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { declarator::TypeSpecifier::Float };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///type_specifier -> double_
    #[inline]
    fn reduce_type_specifier_6(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack10);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { declarator::TypeSpecifier::Double };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///type_specifier -> signed
    #[inline]
    fn reduce_type_specifier_7(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack10);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { declarator::TypeSpecifier::Signed };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///type_specifier -> unsigned
    #[inline]
    fn reduce_type_specifier_8(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack10);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { declarator::TypeSpecifier::Unsigned };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///type_specifier -> ident
    #[inline]
    fn reduce_type_specifier_9(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack10);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            let Token::Identifier(ident) = ident else { unreachable!() };
            declarator::TypeSpecifier::Typename(ident)
        };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///type_specifier -> struct_or_union_specifier
    #[inline]
    fn reduce_type_specifier_10(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack19)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack10);
        let mut struct_or_union_specifier = __data_stack.__stack19.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            declarator::TypeSpecifier::StructOrUnion(struct_or_union_specifier)
        };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///type_specifier -> enum_specifier
    #[inline]
    fn reduce_type_specifier_11(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack20)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack10);
        let mut enum_specifier = __data_stack.__stack20.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { declarator::TypeSpecifier::Enum(enum_specifier) };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///storage_class_specifier -> typedef
    #[inline]
    fn reduce_storage_class_specifier_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack11);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { declarator::StorageClassSpecifier::Typedef };
        __data_stack.__stack11.push(__res);
        Ok(true)
    }
    ///storage_class_specifier -> extern_
    #[inline]
    fn reduce_storage_class_specifier_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack11);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { declarator::StorageClassSpecifier::Extern };
        __data_stack.__stack11.push(__res);
        Ok(true)
    }
    ///storage_class_specifier -> static_
    #[inline]
    fn reduce_storage_class_specifier_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack11);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { declarator::StorageClassSpecifier::Static };
        __data_stack.__stack11.push(__res);
        Ok(true)
    }
    ///storage_class_specifier -> auto
    #[inline]
    fn reduce_storage_class_specifier_3(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack11);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { declarator::StorageClassSpecifier::Auto };
        __data_stack.__stack11.push(__res);
        Ok(true)
    }
    ///storage_class_specifier -> register
    #[inline]
    fn reduce_storage_class_specifier_4(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack11);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { declarator::StorageClassSpecifier::Register };
        __data_stack.__stack11.push(__res);
        Ok(true)
    }
    ///declaration_specifier -> storage_class_specifier
    #[inline]
    fn reduce_declaration_specifier_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack11)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack12);
        let mut storage_class_specifier = __data_stack.__stack11.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            declarator::DeclarationSpecifier::StorageClassSpecifier(
                storage_class_specifier,
            )
        };
        __data_stack.__stack12.push(__res);
        Ok(true)
    }
    ///declaration_specifier -> type_specifier
    #[inline]
    fn reduce_declaration_specifier_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack10)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack12);
        let mut type_specifier = __data_stack.__stack10.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { declarator::DeclarationSpecifier::TypeSpecifier(type_specifier) };
        __data_stack.__stack12.push(__res);
        Ok(true)
    }
    ///declaration_specifier -> type_qualifier
    #[inline]
    fn reduce_declaration_specifier_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack6)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack12);
        let mut type_qualifier = __data_stack.__stack6.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { declarator::DeclarationSpecifier::TypeQualifier(type_qualifier) };
        __data_stack.__stack12.push(__res);
        Ok(true)
    }
    ///parameter_declaration -> declaration_specifier+ declarator
    #[inline]
    fn reduce_parameter_declaration_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack26)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(translation_unitTags::__stack13);
        let mut declaration_specifier = __data_stack.__stack26.pop().unwrap();
        let mut declarator = __data_stack.__stack7.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            declarator::ParameterDeclaration {
                specs: declaration_specifier,
                declarator: Some(Box::new(declarator)),
            }
        };
        __data_stack.__stack13.push(__res);
        Ok(true)
    }
    ///parameter_declaration -> declaration_specifier+ abstract_declarator
    #[inline]
    fn reduce_parameter_declaration_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack26)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(translation_unitTags::__stack13);
        let mut declaration_specifier = __data_stack.__stack26.pop().unwrap();
        let mut abstract_declarator = __data_stack.__stack7.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            declarator::ParameterDeclaration {
                specs: declaration_specifier,
                declarator: Some(Box::new(abstract_declarator)),
            }
        };
        __data_stack.__stack13.push(__res);
        Ok(true)
    }
    ///parameter_declaration -> declaration_specifier+
    #[inline]
    fn reduce_parameter_declaration_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack26)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack13);
        let mut declaration_specifier = __data_stack.__stack26.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            declarator::ParameterDeclaration {
                specs: declaration_specifier,
                declarator: None,
            }
        };
        __data_stack.__stack13.push(__res);
        Ok(true)
    }
    ///parameter_list -> parameter_declaration
    #[inline]
    fn reduce_parameter_list_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack13)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack14);
        let mut parameter_declaration = __data_stack.__stack13.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![parameter_declaration] };
        __data_stack.__stack14.push(__res);
        Ok(true)
    }
    ///parameter_list -> parameter_list comma parameter_declaration
    #[inline]
    fn reduce_parameter_list_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack13)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack14)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut parameter_declaration = __data_stack.__stack13.pop().unwrap();
        let mut parameter_list = __data_stack.__stack14.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            parameter_list.push(parameter_declaration);
            parameter_list
        };
        __data_stack.__stack14.push(__res);
        Ok(true)
    }
    ///parameter_type_list -> parameter_list
    #[inline]
    fn reduce_parameter_type_list_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack14)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack15);
        let mut parameter_list = __data_stack.__stack14.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            declarator::ParameterList {
                params: parameter_list,
                variadic: false,
            }
        };
        __data_stack.__stack15.push(__res);
        Ok(true)
    }
    ///parameter_type_list -> parameter_list comma ellipsis
    #[inline]
    fn reduce_parameter_type_list_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack14)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(translation_unitTags::__stack15);
        let mut parameter_list = __data_stack.__stack14.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            declarator::ParameterList {
                params: parameter_list,
                variadic: true,
            }
        };
        __data_stack.__stack15.push(__res);
        Ok(true)
    }
    ///struct_or_union -> struct_
    #[inline]
    fn reduce_struct_or_union_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack16);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { true };
        __data_stack.__stack16.push(__res);
        Ok(true)
    }
    ///struct_or_union -> union_
    #[inline]
    fn reduce_struct_or_union_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack16);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { false };
        __data_stack.__stack16.push(__res);
        Ok(true)
    }
    ///struct_declarator_list -> declarator
    #[inline]
    fn reduce_struct_declarator_list_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack17);
        let mut struct_declarator = __data_stack.__stack7.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![struct_declarator] };
        __data_stack.__stack17.push(__res);
        Ok(true)
    }
    ///struct_declarator_list -> struct_declarator_list comma declarator
    #[inline]
    fn reduce_struct_declarator_list_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack17)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut struct_declarator_list = __data_stack.__stack17.pop().unwrap();
        let mut struct_declarator = __data_stack.__stack7.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            struct_declarator_list.push(struct_declarator);
            struct_declarator_list
        };
        __data_stack.__stack17.push(__res);
        Ok(true)
    }
    ///struct_declaration -> specifier_qualifier+ struct_declarator_list semicolon
    #[inline]
    fn reduce_struct_declaration_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack17)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack28)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(translation_unitTags::__stack18);
        let mut struct_declarator_list = __data_stack.__stack17.pop().unwrap();
        let mut specifier_qualifier = __data_stack.__stack28.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            declarator::StructDeclaration {
                specs: specifier_qualifier,
                declarators: struct_declarator_list,
            }
        };
        __data_stack.__stack18.push(__res);
        Ok(true)
    }
    ///struct_or_union_specifier -> struct_or_union ident? lbrace struct_declaration* rbrace
    #[inline]
    fn reduce_struct_or_union_specifier_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack31)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                translation_unitTags::__stack30)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 4usize) == Some(&
                translation_unitTags::__stack16)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 5usize);
        __data_stack.__tags.push(translation_unitTags::__stack19);
        let mut struct_or_union = __data_stack.__stack16.pop().unwrap();
        let mut ident = __data_stack.__stack30.pop().unwrap();
        let mut struct_declaration = __data_stack.__stack31.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 5usize);
        let __res = {
            let name = ident
                .map(|name| {
                    let Token::Identifier(name) = name else { unreachable!() };
                    name
                });
            declarator::StructOrUnionSpecifier {
                is_struct: struct_or_union,
                name,
                decls: Some(struct_declaration),
            }
        };
        __data_stack.__stack19.push(__res);
        Ok(true)
    }
    ///struct_or_union_specifier -> struct_or_union ident
    #[inline]
    fn reduce_struct_or_union_specifier_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack16)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(translation_unitTags::__stack19);
        let mut struct_or_union = __data_stack.__stack16.pop().unwrap();
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            let Token::Identifier(name) = ident else { unreachable!() };
            declarator::StructOrUnionSpecifier {
                is_struct: struct_or_union,
                name: Some(name),
                decls: None,
            }
        };
        __data_stack.__stack19.push(__res);
        Ok(true)
    }
    ///enum_specifier -> enum_ ident? lbrace enumerator_list rbrace
    #[inline]
    fn reduce_enum_specifier_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack21)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                translation_unitTags::__stack30)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 4usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 5usize);
        __data_stack.__tags.push(translation_unitTags::__stack20);
        let mut enumerator_list = __data_stack.__stack21.pop().unwrap();
        let mut ident = __data_stack.__stack30.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        __location_stack.truncate(__location_stack.len() - 5usize);
        let __res = {
            let name = ident
                .map(|name| {
                    let Token::Identifier(name) = name else { unreachable!() };
                    name
                });
            declarator::EnumSpecifier {
                name,
                enumerators: Some(enumerator_list),
            }
        };
        __data_stack.__stack20.push(__res);
        Ok(true)
    }
    ///enum_specifier -> enum_ ident
    #[inline]
    fn reduce_enum_specifier_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(translation_unitTags::__stack20);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            let Token::Identifier(name) = ident else { unreachable!() };
            declarator::EnumSpecifier {
                name: Some(name),
                enumerators: None,
            }
        };
        __data_stack.__stack20.push(__res);
        Ok(true)
    }
    ///enumerator_list -> enumerator
    #[inline]
    fn reduce_enumerator_list_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack22)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack21);
        let mut enumerator = __data_stack.__stack22.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![enumerator] };
        __data_stack.__stack21.push(__res);
        Ok(true)
    }
    ///enumerator_list -> enumerator_list comma enumerator
    #[inline]
    fn reduce_enumerator_list_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack22)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack21)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut enumerator_list = __data_stack.__stack21.pop().unwrap();
        let mut enumerator = __data_stack.__stack22.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            enumerator_list.push(enumerator);
            enumerator_list
        };
        __data_stack.__stack21.push(__res);
        Ok(true)
    }
    ///enumerator -> ident
    #[inline]
    fn reduce_enumerator_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack22);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            let Token::Identifier(name) = ident else { unreachable!() };
            declarator::Enumerator {
                name,
                value: None,
            }
        };
        __data_stack.__stack22.push(__res);
        Ok(true)
    }
    ///enumerator -> ident assign conditional_expression
    #[inline]
    fn reduce_enumerator_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(translation_unitTags::__stack22);
        let mut constant_expression = __data_stack.__stack2.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            let Token::Identifier(name) = ident else { unreachable!() };
            declarator::Enumerator {
                name,
                value: Some(constant_expression),
            }
        };
        __data_stack.__stack22.push(__res);
        Ok(true)
    }
    ///init_declarator -> declarator
    #[inline]
    fn reduce_init_declarator_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack23);
        let mut declarator = __data_stack.__stack7.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            declarator::DeclInit {
                declarator: Box::new(declarator),
                initializer: None,
            }
        };
        __data_stack.__stack23.push(__res);
        Ok(true)
    }
    ///init_declarator -> declarator assign initializer
    #[inline]
    fn reduce_init_declarator_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack2)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(translation_unitTags::__stack23);
        let mut initializer = __data_stack.__stack2.pop().unwrap();
        let mut declarator = __data_stack.__stack7.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            declarator::DeclInit {
                declarator: Box::new(declarator),
                initializer: Some(initializer),
            }
        };
        __data_stack.__stack23.push(__res);
        Ok(true)
    }
    ///init_declarator_list -> init_declarator
    #[inline]
    fn reduce_init_declarator_list_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack23)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack24);
        let mut init_declarator = __data_stack.__stack23.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![init_declarator] };
        __data_stack.__stack24.push(__res);
        Ok(true)
    }
    ///init_declarator_list -> init_declarator_list comma init_declarator
    #[inline]
    fn reduce_init_declarator_list_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack23)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                translation_unitTags::__stack24)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut init_declarator = __data_stack.__stack23.pop().unwrap();
        let mut init_declarator_list = __data_stack.__stack24.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            init_declarator_list.push(init_declarator);
            init_declarator_list
        };
        __data_stack.__stack24.push(__res);
        Ok(true)
    }
    ///statement_or_declaration+ -> statement_or_declaration
    #[inline]
    fn reduce__statement_or_declarationPlus58_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack4)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack25);
        let mut A = __data_stack.__stack4.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![A] };
        __data_stack.__stack25.push(__res);
        Ok(true)
    }
    ///statement_or_declaration+ -> statement_or_declaration+ statement_or_declaration
    #[inline]
    fn reduce__statement_or_declarationPlus58_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack4)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack25)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        let mut Ap = __data_stack.__stack25.pop().unwrap();
        let mut A = __data_stack.__stack4.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Ap.push(A);
            Ap
        };
        __data_stack.__stack25.push(__res);
        Ok(true)
    }
    ///statement_or_declaration* -> statement_or_declaration+
    #[inline]
    fn reduce__statement_or_declarationStar59_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack25)
            );
        }
        let mut __token0 = __data_stack.__stack25.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = __token0;
        __data_stack.__stack25.push(__res);
        Ok(true)
    }
    ///statement_or_declaration* ->
    #[inline]
    fn reduce__statement_or_declarationStar59_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(translation_unitTags::__stack25);
        let __res = { vec![] };
        __data_stack.__stack25.push(__res);
        Ok(true)
    }
    ///declaration_specifier+ -> declaration_specifier
    #[inline]
    fn reduce__declaration_specifierPlus60_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack12)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack26);
        let mut A = __data_stack.__stack12.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![A] };
        __data_stack.__stack26.push(__res);
        Ok(true)
    }
    ///declaration_specifier+ -> declaration_specifier+ declaration_specifier
    #[inline]
    fn reduce__declaration_specifierPlus60_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack12)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack26)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        let mut A = __data_stack.__stack12.pop().unwrap();
        let mut Ap = __data_stack.__stack26.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Ap.push(A);
            Ap
        };
        __data_stack.__stack26.push(__res);
        Ok(true)
    }
    ///external_declaration+ -> external_declaration
    #[inline]
    fn reduce__external_declarationPlus61_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack4)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack25);
        let mut A = __data_stack.__stack4.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![A] };
        __data_stack.__stack25.push(__res);
        Ok(true)
    }
    ///external_declaration+ -> external_declaration+ external_declaration
    #[inline]
    fn reduce__external_declarationPlus61_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack4)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack25)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        let mut Ap = __data_stack.__stack25.pop().unwrap();
        let mut A = __data_stack.__stack4.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Ap.push(A);
            Ap
        };
        __data_stack.__stack25.push(__res);
        Ok(true)
    }
    ///external_declaration* -> external_declaration+
    #[inline]
    fn reduce__external_declarationStar62_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack25)
            );
        }
        let mut __token0 = __data_stack.__stack25.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = __token0;
        __data_stack.__stack25.push(__res);
        Ok(true)
    }
    ///external_declaration* ->
    #[inline]
    fn reduce__external_declarationStar62_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(translation_unitTags::__stack25);
        let __res = { vec![] };
        __data_stack.__stack25.push(__res);
        Ok(true)
    }
    ///type_qualifier+ -> type_qualifier
    #[inline]
    fn reduce__type_qualifierPlus63_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack6)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack27);
        let mut A = __data_stack.__stack6.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![A] };
        __data_stack.__stack27.push(__res);
        Ok(true)
    }
    ///type_qualifier+ -> type_qualifier+ type_qualifier
    #[inline]
    fn reduce__type_qualifierPlus63_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack6)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack27)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        let mut Ap = __data_stack.__stack27.pop().unwrap();
        let mut A = __data_stack.__stack6.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Ap.push(A);
            Ap
        };
        __data_stack.__stack27.push(__res);
        Ok(true)
    }
    ///type_qualifier* -> type_qualifier+
    #[inline]
    fn reduce__type_qualifierStar64_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack27)
            );
        }
        let mut __token0 = __data_stack.__stack27.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = __token0;
        __data_stack.__stack27.push(__res);
        Ok(true)
    }
    ///type_qualifier* ->
    #[inline]
    fn reduce__type_qualifierStar64_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(translation_unitTags::__stack27);
        let __res = { vec![] };
        __data_stack.__stack27.push(__res);
        Ok(true)
    }
    ///specifier_qualifier+ -> specifier_qualifier
    #[inline]
    fn reduce__specifier_qualifierPlus65_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack8)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack28);
        let mut A = __data_stack.__stack8.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![A] };
        __data_stack.__stack28.push(__res);
        Ok(true)
    }
    ///specifier_qualifier+ -> specifier_qualifier+ specifier_qualifier
    #[inline]
    fn reduce__specifier_qualifierPlus65_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack8)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack28)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        let mut Ap = __data_stack.__stack28.pop().unwrap();
        let mut A = __data_stack.__stack8.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Ap.push(A);
            Ap
        };
        __data_stack.__stack28.push(__res);
        Ok(true)
    }
    ///abstract_declarator? -> abstract_declarator
    #[inline]
    fn reduce__abstract_declaratorQuestion66_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack29);
        let mut A = __data_stack.__stack7.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = Some(A);
        __data_stack.__stack29.push(__res);
        Ok(true)
    }
    ///abstract_declarator? ->
    #[inline]
    fn reduce__abstract_declaratorQuestion66_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(translation_unitTags::__stack29);
        let __res = { None };
        __data_stack.__stack29.push(__res);
        Ok(true)
    }
    ///ident? -> ident
    #[inline]
    fn reduce__identQuestion67_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack30);
        let mut A = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = Some(A);
        __data_stack.__stack30.push(__res);
        Ok(true)
    }
    ///ident? ->
    #[inline]
    fn reduce__identQuestion67_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(translation_unitTags::__stack30);
        let __res = { None };
        __data_stack.__stack30.push(__res);
        Ok(true)
    }
    ///struct_declaration+ -> struct_declaration
    #[inline]
    fn reduce__struct_declarationPlus68_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack18)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(translation_unitTags::__stack31);
        let mut A = __data_stack.__stack18.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![A] };
        __data_stack.__stack31.push(__res);
        Ok(true)
    }
    ///struct_declaration+ -> struct_declaration+ struct_declaration
    #[inline]
    fn reduce__struct_declarationPlus68_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack18)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                translation_unitTags::__stack31)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        let mut A = __data_stack.__stack18.pop().unwrap();
        let mut Ap = __data_stack.__stack31.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Ap.push(A);
            Ap
        };
        __data_stack.__stack31.push(__res);
        Ok(true)
    }
    ///struct_declaration* -> struct_declaration+
    #[inline]
    fn reduce__struct_declarationStar69_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                translation_unitTags::__stack31)
            );
        }
        let mut __token0 = __data_stack.__stack31.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = __token0;
        __data_stack.__stack31.push(__res);
        Ok(true)
    }
    ///struct_declaration* ->
    #[inline]
    fn reduce__struct_declarationStar69_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ::rusty_lr::DefaultReduceActionError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(translation_unitTags::__stack31);
        let __res = { vec![] };
        __data_stack.__stack31.push(__res);
        Ok(true)
    }
}
#[allow(
    unused_braces,
    unused_parens,
    non_snake_case,
    non_camel_case_types,
    unused_variables
)]
impl ::rusty_lr::parser::data_stack::DataStack for translation_unitDataStack {
    type Term = Token;
    type NonTerm = translation_unitNonTerminals;
    type ReduceActionError = ::rusty_lr::DefaultReduceActionError;
    type UserData = ();
    type StartType = statement::TranslationUnit;
    type Location = ::rusty_lr::DefaultLocation;
    fn pop_start(&mut self) -> Option<Self::StartType> {
        let tag = self.__tags.pop();
        debug_assert!(tag == Some(translation_unitTags::__stack5));
        self.__stack5.pop()
    }
    fn pop(&mut self) {
        match self.__tags.pop().unwrap() {
            translation_unitTags::__terminals => {
                self.__terminals.pop();
            }
            translation_unitTags::__stack2 => {
                self.__stack2.pop();
            }
            translation_unitTags::__stack3 => {
                self.__stack3.pop();
            }
            translation_unitTags::__stack4 => {
                self.__stack4.pop();
            }
            translation_unitTags::__stack5 => {
                self.__stack5.pop();
            }
            translation_unitTags::__stack6 => {
                self.__stack6.pop();
            }
            translation_unitTags::__stack7 => {
                self.__stack7.pop();
            }
            translation_unitTags::__stack8 => {
                self.__stack8.pop();
            }
            translation_unitTags::__stack9 => {
                self.__stack9.pop();
            }
            translation_unitTags::__stack10 => {
                self.__stack10.pop();
            }
            translation_unitTags::__stack11 => {
                self.__stack11.pop();
            }
            translation_unitTags::__stack12 => {
                self.__stack12.pop();
            }
            translation_unitTags::__stack13 => {
                self.__stack13.pop();
            }
            translation_unitTags::__stack14 => {
                self.__stack14.pop();
            }
            translation_unitTags::__stack15 => {
                self.__stack15.pop();
            }
            translation_unitTags::__stack16 => {
                self.__stack16.pop();
            }
            translation_unitTags::__stack17 => {
                self.__stack17.pop();
            }
            translation_unitTags::__stack18 => {
                self.__stack18.pop();
            }
            translation_unitTags::__stack19 => {
                self.__stack19.pop();
            }
            translation_unitTags::__stack20 => {
                self.__stack20.pop();
            }
            translation_unitTags::__stack21 => {
                self.__stack21.pop();
            }
            translation_unitTags::__stack22 => {
                self.__stack22.pop();
            }
            translation_unitTags::__stack23 => {
                self.__stack23.pop();
            }
            translation_unitTags::__stack24 => {
                self.__stack24.pop();
            }
            translation_unitTags::__stack25 => {
                self.__stack25.pop();
            }
            translation_unitTags::__stack26 => {
                self.__stack26.pop();
            }
            translation_unitTags::__stack27 => {
                self.__stack27.pop();
            }
            translation_unitTags::__stack28 => {
                self.__stack28.pop();
            }
            translation_unitTags::__stack29 => {
                self.__stack29.pop();
            }
            translation_unitTags::__stack30 => {
                self.__stack30.pop();
            }
            translation_unitTags::__stack31 => {
                self.__stack31.pop();
            }
            _ => {}
        }
    }
    fn push_terminal(&mut self, term: Self::Term) {
        self.__tags.push(translation_unitTags::__terminals);
        self.__terminals.push(term);
    }
    fn push_empty(&mut self) {
        self.__tags.push(translation_unitTags::Empty);
    }
    fn clear(&mut self) {
        self.__tags.clear();
        self.__terminals.clear();
        self.__stack2.clear();
        self.__stack3.clear();
        self.__stack4.clear();
        self.__stack5.clear();
        self.__stack6.clear();
        self.__stack7.clear();
        self.__stack8.clear();
        self.__stack9.clear();
        self.__stack10.clear();
        self.__stack11.clear();
        self.__stack12.clear();
        self.__stack13.clear();
        self.__stack14.clear();
        self.__stack15.clear();
        self.__stack16.clear();
        self.__stack17.clear();
        self.__stack18.clear();
        self.__stack19.clear();
        self.__stack20.clear();
        self.__stack21.clear();
        self.__stack22.clear();
        self.__stack23.clear();
        self.__stack24.clear();
        self.__stack25.clear();
        self.__stack26.clear();
        self.__stack27.clear();
        self.__stack28.clear();
        self.__stack29.clear();
        self.__stack30.clear();
        self.__stack31.clear();
    }
    fn reserve(&mut self, additional: usize) {
        self.__tags.reserve(additional);
    }
    fn split_off(&mut self, at: usize) -> Self {
        let __other_tag_stack = self.__tags.split_off(at);
        let mut __counts: [u8; 31usize + 1] = [0; 31usize + 1];
        for &tag in &__other_tag_stack {
            __counts[tag as usize] += 1;
        }
        let __other___terminals = self
            .__terminals
            .split_off(self.__terminals.len() - (__counts[0usize] as usize));
        let __other___stack2 = self
            .__stack2
            .split_off(self.__stack2.len() - (__counts[1usize] as usize));
        let __other___stack3 = self
            .__stack3
            .split_off(self.__stack3.len() - (__counts[2usize] as usize));
        let __other___stack4 = self
            .__stack4
            .split_off(self.__stack4.len() - (__counts[3usize] as usize));
        let __other___stack5 = self
            .__stack5
            .split_off(self.__stack5.len() - (__counts[4usize] as usize));
        let __other___stack6 = self
            .__stack6
            .split_off(self.__stack6.len() - (__counts[5usize] as usize));
        let __other___stack7 = self
            .__stack7
            .split_off(self.__stack7.len() - (__counts[6usize] as usize));
        let __other___stack8 = self
            .__stack8
            .split_off(self.__stack8.len() - (__counts[7usize] as usize));
        let __other___stack9 = self
            .__stack9
            .split_off(self.__stack9.len() - (__counts[8usize] as usize));
        let __other___stack10 = self
            .__stack10
            .split_off(self.__stack10.len() - (__counts[9usize] as usize));
        let __other___stack11 = self
            .__stack11
            .split_off(self.__stack11.len() - (__counts[10usize] as usize));
        let __other___stack12 = self
            .__stack12
            .split_off(self.__stack12.len() - (__counts[11usize] as usize));
        let __other___stack13 = self
            .__stack13
            .split_off(self.__stack13.len() - (__counts[12usize] as usize));
        let __other___stack14 = self
            .__stack14
            .split_off(self.__stack14.len() - (__counts[13usize] as usize));
        let __other___stack15 = self
            .__stack15
            .split_off(self.__stack15.len() - (__counts[14usize] as usize));
        let __other___stack16 = self
            .__stack16
            .split_off(self.__stack16.len() - (__counts[15usize] as usize));
        let __other___stack17 = self
            .__stack17
            .split_off(self.__stack17.len() - (__counts[16usize] as usize));
        let __other___stack18 = self
            .__stack18
            .split_off(self.__stack18.len() - (__counts[17usize] as usize));
        let __other___stack19 = self
            .__stack19
            .split_off(self.__stack19.len() - (__counts[18usize] as usize));
        let __other___stack20 = self
            .__stack20
            .split_off(self.__stack20.len() - (__counts[19usize] as usize));
        let __other___stack21 = self
            .__stack21
            .split_off(self.__stack21.len() - (__counts[20usize] as usize));
        let __other___stack22 = self
            .__stack22
            .split_off(self.__stack22.len() - (__counts[21usize] as usize));
        let __other___stack23 = self
            .__stack23
            .split_off(self.__stack23.len() - (__counts[22usize] as usize));
        let __other___stack24 = self
            .__stack24
            .split_off(self.__stack24.len() - (__counts[23usize] as usize));
        let __other___stack25 = self
            .__stack25
            .split_off(self.__stack25.len() - (__counts[24usize] as usize));
        let __other___stack26 = self
            .__stack26
            .split_off(self.__stack26.len() - (__counts[25usize] as usize));
        let __other___stack27 = self
            .__stack27
            .split_off(self.__stack27.len() - (__counts[26usize] as usize));
        let __other___stack28 = self
            .__stack28
            .split_off(self.__stack28.len() - (__counts[27usize] as usize));
        let __other___stack29 = self
            .__stack29
            .split_off(self.__stack29.len() - (__counts[28usize] as usize));
        let __other___stack30 = self
            .__stack30
            .split_off(self.__stack30.len() - (__counts[29usize] as usize));
        let __other___stack31 = self
            .__stack31
            .split_off(self.__stack31.len() - (__counts[30usize] as usize));
        Self {
            __tags: __other_tag_stack,
            __terminals: __other___terminals,
            __stack2: __other___stack2,
            __stack3: __other___stack3,
            __stack4: __other___stack4,
            __stack5: __other___stack5,
            __stack6: __other___stack6,
            __stack7: __other___stack7,
            __stack8: __other___stack8,
            __stack9: __other___stack9,
            __stack10: __other___stack10,
            __stack11: __other___stack11,
            __stack12: __other___stack12,
            __stack13: __other___stack13,
            __stack14: __other___stack14,
            __stack15: __other___stack15,
            __stack16: __other___stack16,
            __stack17: __other___stack17,
            __stack18: __other___stack18,
            __stack19: __other___stack19,
            __stack20: __other___stack20,
            __stack21: __other___stack21,
            __stack22: __other___stack22,
            __stack23: __other___stack23,
            __stack24: __other___stack24,
            __stack25: __other___stack25,
            __stack26: __other___stack26,
            __stack27: __other___stack27,
            __stack28: __other___stack28,
            __stack29: __other___stack29,
            __stack30: __other___stack30,
            __stack31: __other___stack31,
        }
    }
    fn append(&mut self, other: &mut Self) {
        self.__tags.append(&mut other.__tags);
        self.__terminals.append(&mut other.__terminals);
        self.__stack2.append(&mut other.__stack2);
        self.__stack3.append(&mut other.__stack3);
        self.__stack4.append(&mut other.__stack4);
        self.__stack5.append(&mut other.__stack5);
        self.__stack6.append(&mut other.__stack6);
        self.__stack7.append(&mut other.__stack7);
        self.__stack8.append(&mut other.__stack8);
        self.__stack9.append(&mut other.__stack9);
        self.__stack10.append(&mut other.__stack10);
        self.__stack11.append(&mut other.__stack11);
        self.__stack12.append(&mut other.__stack12);
        self.__stack13.append(&mut other.__stack13);
        self.__stack14.append(&mut other.__stack14);
        self.__stack15.append(&mut other.__stack15);
        self.__stack16.append(&mut other.__stack16);
        self.__stack17.append(&mut other.__stack17);
        self.__stack18.append(&mut other.__stack18);
        self.__stack19.append(&mut other.__stack19);
        self.__stack20.append(&mut other.__stack20);
        self.__stack21.append(&mut other.__stack21);
        self.__stack22.append(&mut other.__stack22);
        self.__stack23.append(&mut other.__stack23);
        self.__stack24.append(&mut other.__stack24);
        self.__stack25.append(&mut other.__stack25);
        self.__stack26.append(&mut other.__stack26);
        self.__stack27.append(&mut other.__stack27);
        self.__stack28.append(&mut other.__stack28);
        self.__stack29.append(&mut other.__stack29);
        self.__stack30.append(&mut other.__stack30);
        self.__stack31.append(&mut other.__stack31);
    }
    fn reduce_action(
        data_stack: &mut Self,
        location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        rule_index: usize,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Self::Term>,
        user_data: &mut Self::UserData,
        location0: &mut Self::Location,
    ) -> Result<bool, Self::ReduceActionError> {
        match rule_index {
            0usize => {
                Self::reduce_Constant_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            1usize => {
                Self::reduce_Constant_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            2usize => {
                Self::reduce_Constant_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            3usize => {
                Self::reduce_Constant_3(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            4usize => {
                Self::reduce_Constant_4(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            5usize => {
                Self::reduce_Constant_5(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            6usize => {
                Self::reduce_Constant_6(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            7usize => {
                Self::reduce_primary_expression_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            9usize => {
                Self::reduce_primary_expression_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            10usize => {
                Self::reduce_primary_expression_3(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            12usize => {
                Self::reduce_postfix_expression_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            13usize => {
                Self::reduce_postfix_expression_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            14usize => {
                Self::reduce_postfix_expression_3(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            15usize => {
                Self::reduce_postfix_expression_4(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            16usize => {
                Self::reduce_postfix_expression_5(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            17usize => {
                Self::reduce_postfix_expression_6(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            18usize => {
                Self::reduce_postfix_expression_7(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            19usize => {
                Self::reduce_argument_expression_list_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            20usize => {
                Self::reduce_argument_expression_list_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            21usize => {
                Self::reduce_unary_expression_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            22usize => {
                Self::reduce_unary_expression_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            23usize => {
                Self::reduce_unary_expression_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            24usize => {
                Self::reduce_unary_expression_3(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            25usize => {
                Self::reduce_unary_expression_4(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            26usize => {
                Self::reduce_unary_expression_5(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            27usize => {
                Self::reduce_unary_expression_6(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            28usize => {
                Self::reduce_unary_expression_7(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            29usize => {
                Self::reduce_unary_expression_8(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            30usize => {
                Self::reduce_unary_expression_9(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            31usize => {
                Self::reduce_unary_expression_10(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            32usize => {
                Self::reduce_cast_expression_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            33usize => {
                Self::reduce_cast_expression_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            35usize => {
                Self::reduce_multiplicative_expression_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            36usize => {
                Self::reduce_multiplicative_expression_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            37usize => {
                Self::reduce_multiplicative_expression_3(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            38usize => {
                Self::reduce_additive_expression_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            39usize => {
                Self::reduce_additive_expression_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            40usize => {
                Self::reduce_additive_expression_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            41usize => {
                Self::reduce_shift_expression_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            42usize => {
                Self::reduce_shift_expression_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            43usize => {
                Self::reduce_shift_expression_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            44usize => {
                Self::reduce_relational_expression_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            45usize => {
                Self::reduce_relational_expression_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            46usize => {
                Self::reduce_relational_expression_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            47usize => {
                Self::reduce_relational_expression_3(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            48usize => {
                Self::reduce_relational_expression_4(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            49usize => {
                Self::reduce_equality_expression_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            50usize => {
                Self::reduce_equality_expression_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            51usize => {
                Self::reduce_equality_expression_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            52usize => {
                Self::reduce_and_expression_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            53usize => {
                Self::reduce_and_expression_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            54usize => {
                Self::reduce_exclusive_or_expression_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            55usize => {
                Self::reduce_exclusive_or_expression_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            56usize => {
                Self::reduce_inclusive_or_expression_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            57usize => {
                Self::reduce_inclusive_or_expression_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            58usize => {
                Self::reduce_logical_and_expression_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            59usize => {
                Self::reduce_logical_and_expression_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            60usize => {
                Self::reduce_logical_or_expression_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            61usize => {
                Self::reduce_logical_or_expression_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            62usize => {
                Self::reduce_conditional_expression_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            63usize => {
                Self::reduce_conditional_expression_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            65usize => {
                Self::reduce_assignment_expression_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            66usize => {
                Self::reduce_assignment_expression_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            67usize => {
                Self::reduce_assignment_expression_3(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            68usize => {
                Self::reduce_assignment_expression_4(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            69usize => {
                Self::reduce_assignment_expression_5(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            70usize => {
                Self::reduce_assignment_expression_6(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            71usize => {
                Self::reduce_assignment_expression_7(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            72usize => {
                Self::reduce_assignment_expression_8(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            73usize => {
                Self::reduce_assignment_expression_9(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            74usize => {
                Self::reduce_assignment_expression_10(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            75usize => {
                Self::reduce_assignment_expression_11(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            77usize => {
                Self::reduce_expression_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            79usize => {
                Self::reduce_initializer_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            80usize => {
                Self::reduce_initializer_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            81usize => {
                Self::reduce_initializer_list_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            82usize => {
                Self::reduce_initializer_list_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            83usize => {
                Self::reduce_labeled_statement_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            84usize => {
                Self::reduce_labeled_statement_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            85usize => {
                Self::reduce_labeled_statement_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            88usize => {
                Self::reduce_compound_statement_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            89usize => {
                Self::reduce_expression_statement_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            90usize => {
                Self::reduce_expression_statement_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            91usize => {
                Self::reduce_selection_statement_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            92usize => {
                Self::reduce_selection_statement_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            93usize => {
                Self::reduce_selection_statement_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            96usize => {
                Self::reduce_iteration_statement_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            97usize => {
                Self::reduce_iteration_statement_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            98usize => {
                Self::reduce_iteration_statement_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            99usize => {
                Self::reduce_iteration_statement_3(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            100usize => {
                Self::reduce_jump_statement_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            101usize => {
                Self::reduce_jump_statement_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            102usize => {
                Self::reduce_jump_statement_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            103usize => {
                Self::reduce_jump_statement_3(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            104usize => {
                Self::reduce_jump_statement_4(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            105usize => {
                Self::reduce_declaration_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            106usize => {
                Self::reduce_declaration_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            107usize => {
                Self::reduce_function_definition_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            108usize => {
                Self::reduce_function_definition_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            117usize => {
                Self::reduce_translation_unit_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            118usize => {
                Self::reduce_type_qualifier_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            119usize => {
                Self::reduce_type_qualifier_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            120usize => {
                Self::reduce_declarator_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            121usize => {
                Self::reduce_declarator_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            122usize => {
                Self::reduce_direct_declarator_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            123usize => {
                Self::reduce_direct_declarator_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            124usize => {
                Self::reduce_direct_declarator_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            125usize => {
                Self::reduce_direct_declarator_3(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            126usize => {
                Self::reduce_direct_declarator_4(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            127usize => {
                Self::reduce_direct_declarator_5(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            128usize => {
                Self::reduce_abstract_declarator_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            129usize => {
                Self::reduce_abstract_declarator_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            130usize => {
                Self::reduce_abstract_declarator_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            131usize => {
                Self::reduce_direct_abstract_declarator_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            132usize => {
                Self::reduce_direct_abstract_declarator_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            133usize => {
                Self::reduce_direct_abstract_declarator_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            134usize => {
                Self::reduce_direct_abstract_declarator_3(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            135usize => {
                Self::reduce_direct_abstract_declarator_4(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            136usize => {
                Self::reduce_direct_abstract_declarator_5(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            137usize => {
                Self::reduce_direct_abstract_declarator_6(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            138usize => {
                Self::reduce_direct_abstract_declarator_7(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            139usize => {
                Self::reduce_direct_abstract_declarator_8(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            140usize => {
                Self::reduce_specifier_qualifier_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            141usize => {
                Self::reduce_specifier_qualifier_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            142usize => {
                Self::reduce_type_name_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            143usize => {
                Self::reduce_type_specifier_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            144usize => {
                Self::reduce_type_specifier_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            145usize => {
                Self::reduce_type_specifier_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            146usize => {
                Self::reduce_type_specifier_3(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            147usize => {
                Self::reduce_type_specifier_4(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            148usize => {
                Self::reduce_type_specifier_5(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            149usize => {
                Self::reduce_type_specifier_6(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            150usize => {
                Self::reduce_type_specifier_7(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            151usize => {
                Self::reduce_type_specifier_8(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            152usize => {
                Self::reduce_type_specifier_9(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            153usize => {
                Self::reduce_type_specifier_10(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            154usize => {
                Self::reduce_type_specifier_11(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            155usize => {
                Self::reduce_storage_class_specifier_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            156usize => {
                Self::reduce_storage_class_specifier_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            157usize => {
                Self::reduce_storage_class_specifier_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            158usize => {
                Self::reduce_storage_class_specifier_3(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            159usize => {
                Self::reduce_storage_class_specifier_4(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            160usize => {
                Self::reduce_declaration_specifier_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            161usize => {
                Self::reduce_declaration_specifier_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            162usize => {
                Self::reduce_declaration_specifier_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            163usize => {
                Self::reduce_parameter_declaration_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            164usize => {
                Self::reduce_parameter_declaration_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            165usize => {
                Self::reduce_parameter_declaration_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            166usize => {
                Self::reduce_parameter_list_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            167usize => {
                Self::reduce_parameter_list_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            168usize => {
                Self::reduce_parameter_type_list_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            169usize => {
                Self::reduce_parameter_type_list_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            170usize => {
                Self::reduce_struct_or_union_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            171usize => {
                Self::reduce_struct_or_union_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            172usize => {
                Self::reduce_struct_declarator_list_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            173usize => {
                Self::reduce_struct_declarator_list_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            174usize => {
                Self::reduce_struct_declaration_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            175usize => {
                Self::reduce_struct_or_union_specifier_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            176usize => {
                Self::reduce_struct_or_union_specifier_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            177usize => {
                Self::reduce_enum_specifier_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            178usize => {
                Self::reduce_enum_specifier_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            179usize => {
                Self::reduce_enumerator_list_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            180usize => {
                Self::reduce_enumerator_list_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            181usize => {
                Self::reduce_enumerator_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            182usize => {
                Self::reduce_enumerator_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            183usize => {
                Self::reduce_init_declarator_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            184usize => {
                Self::reduce_init_declarator_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            185usize => {
                Self::reduce_init_declarator_list_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            186usize => {
                Self::reduce_init_declarator_list_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            187usize => {
                Self::reduce__statement_or_declarationPlus58_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            188usize => {
                Self::reduce__statement_or_declarationPlus58_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            189usize => {
                Self::reduce__statement_or_declarationStar59_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            190usize => {
                Self::reduce__statement_or_declarationStar59_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            191usize => {
                Self::reduce__declaration_specifierPlus60_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            192usize => {
                Self::reduce__declaration_specifierPlus60_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            193usize => {
                Self::reduce__external_declarationPlus61_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            194usize => {
                Self::reduce__external_declarationPlus61_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            195usize => {
                Self::reduce__external_declarationStar62_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            196usize => {
                Self::reduce__external_declarationStar62_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            197usize => {
                Self::reduce__type_qualifierPlus63_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            198usize => {
                Self::reduce__type_qualifierPlus63_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            199usize => {
                Self::reduce__type_qualifierStar64_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            200usize => {
                Self::reduce__type_qualifierStar64_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            201usize => {
                Self::reduce__specifier_qualifierPlus65_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            202usize => {
                Self::reduce__specifier_qualifierPlus65_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            203usize => {
                Self::reduce__abstract_declaratorQuestion66_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            204usize => {
                Self::reduce__abstract_declaratorQuestion66_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            205usize => {
                Self::reduce__identQuestion67_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            206usize => {
                Self::reduce__identQuestion67_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            207usize => {
                Self::reduce__struct_declarationPlus68_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            208usize => {
                Self::reduce__struct_declarationPlus68_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            209usize => {
                Self::reduce__struct_declarationStar69_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            210usize => {
                Self::reduce__struct_declarationStar69_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            _ => {
                unreachable!("Invalid Rule: {}", rule_index);
            }
        }
    }
}
/// A struct that holds the entire parser table and production rules.
#[allow(unused_braces, unused_parens, unused_variables, non_snake_case, unused_mut)]
pub struct translation_unitParser {
    /// production rules
    pub rules: Vec<translation_unitRule>,
    /// states
    pub states: Vec<translation_unitState>,
}
impl ::rusty_lr::parser::Parser for translation_unitParser {
    type Term = Token;
    type TermClass = translation_unitTerminalClasses;
    type NonTerm = translation_unitNonTerminals;
    type State = translation_unitState;
    const ERROR_USED: bool = false;
    fn precedence_types(&self, level: u8) -> Option<::rusty_lr::rule::ReduceType> {
        #[allow(unreachable_patterns)]
        match level {
            1 => Some(::rusty_lr::rule::ReduceType::Left),
            _ => None,
        }
    }
    fn get_rules(&self) -> &[translation_unitRule] {
        &self.rules
    }
    fn get_states(&self) -> &[translation_unitState] {
        &self.states
    }
}
/// A struct that holds the whole parser table.
#[allow(unused_braces, unused_parens, unused_variables, non_snake_case, unused_mut)]
impl translation_unitParser {
    /// Calculates the states and parser tables from the grammar.
    #[allow(clippy::clone_on_copy)]
    pub fn new() -> Self {
        let rules: Vec<
            ::rusty_lr::rule::ProductionRule<
                translation_unitTerminalClasses,
                translation_unitNonTerminals,
            >,
        > = vec![
            ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::Constant, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::constant_character),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::Constant, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::constant_integer),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::Constant, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::constant_long),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::Constant, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::constant_unsigned_integer),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::Constant, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::constant_unsigned_long),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::Constant, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::constant_float),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::Constant, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::constant_double),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::primary_expression, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::ident),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::primary_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::Constant),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::primary_expression, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::string_literal),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::primary_expression, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::lparen),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rparen),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::postfix_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::primary_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::postfix_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::postfix_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::lbracket),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rbracket),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::postfix_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::postfix_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::lparen),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rparen),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::postfix_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::postfix_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::lparen),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::argument_expression_list),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rparen),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::postfix_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::postfix_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::dot),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::ident),], precedence
            : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::postfix_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::postfix_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::ptr_op),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::ident),], precedence
            : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::postfix_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::postfix_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::inc_op),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::postfix_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::postfix_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::dec_op),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::argument_expression_list, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::assignment_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::argument_expression_list, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::argument_expression_list),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::comma),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::assignment_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::unary_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::postfix_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::unary_expression, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::inc_op),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::unary_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::unary_expression, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::dec_op),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::unary_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::unary_expression, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::ampersand),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::cast_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::unary_expression, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::star),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::cast_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::unary_expression, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::plus),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::cast_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::unary_expression, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::minus),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::cast_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::unary_expression, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::tilde),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::cast_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::unary_expression, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::exclamation),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::cast_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::unary_expression, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::sizeof),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::unary_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::unary_expression, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::sizeof),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::lparen),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::type_name),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rparen),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::cast_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::unary_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::cast_expression, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::lparen),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::type_name),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rparen),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::cast_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::multiplicative_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::cast_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::multiplicative_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::multiplicative_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::star),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::cast_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::multiplicative_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::multiplicative_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::slash),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::cast_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::multiplicative_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::multiplicative_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::percent),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::cast_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::additive_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::multiplicative_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::additive_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::additive_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::plus),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::multiplicative_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::additive_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::additive_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::minus),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::multiplicative_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::shift_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::additive_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::shift_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::shift_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::left_op),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::additive_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::shift_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::shift_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::right_op),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::additive_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::relational_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::shift_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::relational_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::relational_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::less),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::shift_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::relational_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::relational_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::greater),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::shift_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::relational_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::relational_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::le),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::shift_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::relational_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::relational_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::ge),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::shift_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::equality_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::relational_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::equality_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::equality_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::eq),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::relational_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::equality_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::equality_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::ne),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::relational_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::and_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::equality_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::and_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::and_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::ampersand),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::equality_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::exclusive_or_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::and_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::exclusive_or_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::exclusive_or_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::caret),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::and_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::inclusive_or_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::exclusive_or_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::inclusive_or_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::inclusive_or_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::pipe),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::exclusive_or_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::logical_and_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::inclusive_or_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::logical_and_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::logical_and_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::and_op),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::inclusive_or_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::logical_or_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::logical_and_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::logical_or_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::logical_or_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::or_op),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::logical_and_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::conditional_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::logical_or_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::conditional_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::logical_or_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::question),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::colon),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::conditional_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::assignment_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::conditional_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::assignment_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::unary_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::assign),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::assignment_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::assignment_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::unary_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::mul_assign),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::assignment_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::assignment_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::unary_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::div_assign),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::assignment_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::assignment_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::unary_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::mod_assign),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::assignment_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::assignment_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::unary_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::add_assign),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::assignment_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::assignment_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::unary_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::sub_assign),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::assignment_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::assignment_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::unary_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::left_assign),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::assignment_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::assignment_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::unary_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::right_assign),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::assignment_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::assignment_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::unary_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::and_assign),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::assignment_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::assignment_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::unary_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::xor_assign),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::assignment_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::assignment_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::unary_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::or_assign),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::assignment_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::assignment_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::comma),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::assignment_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::initializer, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::assignment_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::initializer, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::lbrace),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::initializer_list),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rbrace),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::initializer, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::lbrace),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::initializer_list),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::comma),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rbrace),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::initializer_list, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::initializer),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::initializer_list, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::initializer_list),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::comma),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::initializer),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::labeled_statement, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::ident),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::colon),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::statement),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::labeled_statement, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::case),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::conditional_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::colon),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::statement),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::labeled_statement, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::default),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::colon),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::statement),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::statement_or_declaration, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::statement),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::statement_or_declaration, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::declaration),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::compound_statement, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::lbrace),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_statement_or_declarationStar59),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rbrace),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::expression_statement, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::semicolon),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::expression_statement, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::semicolon),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::selection_statement, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::if_),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::lparen),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rparen),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::statement),],
            precedence : Some(::rusty_lr::rule::Precedence::Fixed(0usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::selection_statement, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::if_),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::lparen),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rparen),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::statement),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::else_),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::statement),],
            precedence : Some(::rusty_lr::rule::Precedence::Fixed(1usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::selection_statement, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::switch),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::lparen),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rparen),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::statement),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::declaration_or_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::declaration),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::declaration_or_expression, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::expression_statement),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::iteration_statement, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::while_),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::lparen),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rparen),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::statement),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::iteration_statement, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::do_),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::statement),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::while_),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::lparen),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rparen),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::semicolon),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::iteration_statement, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::for_),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::lparen),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::declaration_or_expression),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::expression_statement),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rparen),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::statement),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::iteration_statement, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::for_),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::lparen),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::declaration_or_expression),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::expression_statement),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rparen),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::statement),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::jump_statement, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::goto_),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::ident),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::semicolon),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::jump_statement, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::continue_),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::semicolon),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::jump_statement, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::break_),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::semicolon),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::jump_statement, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::return_),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::semicolon),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::jump_statement, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::return_),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::semicolon),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::declaration, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_declaration_specifierPlus60),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::semicolon),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::declaration, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_declaration_specifierPlus60),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::init_declarator_list),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::semicolon),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::function_definition, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_declaration_specifierPlus60),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::declarator),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::compound_statement),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::function_definition, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::declarator),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::compound_statement),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::statement, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::labeled_statement),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::statement, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::compound_statement),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::statement, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::expression_statement),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::statement, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::selection_statement),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::statement, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::iteration_statement),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::statement, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::jump_statement),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::external_declaration, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::function_definition),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::external_declaration, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::declaration),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::translation_unit, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_external_declarationStar62),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::type_qualifier, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::const_),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::type_qualifier, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::volatile),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::declarator, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::direct_declarator),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::declarator, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::star),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_type_qualifierStar64),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::declarator),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::direct_declarator, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::ident),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::direct_declarator, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::lparen),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::declarator),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rparen),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::direct_declarator, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::direct_declarator),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::lbracket),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::conditional_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rbracket),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::direct_declarator, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::direct_declarator),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::lbracket),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rbracket),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::direct_declarator, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::direct_declarator),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::lparen),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::parameter_type_list),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rparen),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::direct_declarator, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::direct_declarator),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::lparen),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rparen),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::abstract_declarator, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::star),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_type_qualifierStar64),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::abstract_declarator),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::abstract_declarator, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::star),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_type_qualifierStar64),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::abstract_declarator, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::direct_abstract_declarator),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::direct_abstract_declarator, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::lparen),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::abstract_declarator),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rparen),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::direct_abstract_declarator, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::lbracket),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rbracket),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::direct_abstract_declarator, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::lbracket),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::conditional_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rbracket),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::direct_abstract_declarator, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::direct_abstract_declarator),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::lbracket),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rbracket),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::direct_abstract_declarator, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::direct_abstract_declarator),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::lbracket),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::conditional_expression),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rbracket),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::direct_abstract_declarator, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::lparen),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rparen),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::direct_abstract_declarator, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::lparen),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::parameter_type_list),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rparen),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::direct_abstract_declarator, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::direct_abstract_declarator),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::lparen),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rparen),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::direct_abstract_declarator, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::direct_abstract_declarator),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::lparen),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::parameter_type_list),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rparen),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::specifier_qualifier, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::type_qualifier),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::specifier_qualifier, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::type_specifier),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::type_name, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_specifier_qualifierPlus65),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_abstract_declaratorQuestion66),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::type_specifier, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::void_),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::type_specifier, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::char_),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::type_specifier, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::short_),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::type_specifier, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::int_),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::type_specifier, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::long_),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::type_specifier, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::float_),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::type_specifier, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::double_),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::type_specifier, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::signed),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::type_specifier, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::unsigned),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::type_specifier, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::ident),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::type_specifier, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::struct_or_union_specifier),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::type_specifier, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::enum_specifier),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::storage_class_specifier, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::typedef),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::storage_class_specifier, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::extern_),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::storage_class_specifier, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::static_),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::storage_class_specifier, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::auto),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::storage_class_specifier, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::register),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::declaration_specifier, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::storage_class_specifier),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::declaration_specifier, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::type_specifier),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::declaration_specifier, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::type_qualifier),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::parameter_declaration, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_declaration_specifierPlus60),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::declarator),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::parameter_declaration, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_declaration_specifierPlus60),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::abstract_declarator),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::parameter_declaration, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_declaration_specifierPlus60),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::parameter_list, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::parameter_declaration),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::parameter_list, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::parameter_list),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::comma),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::parameter_declaration),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::parameter_type_list, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::parameter_list),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::parameter_type_list, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::parameter_list),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::comma),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::ellipsis),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::struct_or_union, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::struct_),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::struct_or_union, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::union_),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::struct_declarator_list, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::declarator),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::struct_declarator_list, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::struct_declarator_list),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::comma),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::declarator),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::struct_declaration, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_specifier_qualifierPlus65),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::struct_declarator_list),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::semicolon),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::struct_or_union_specifier, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::struct_or_union),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_identQuestion67),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::lbrace),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_struct_declarationStar69),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rbrace),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::struct_or_union_specifier, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::struct_or_union),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::ident),], precedence
            : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::enum_specifier, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::enum_),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_identQuestion67),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::lbrace),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::enumerator_list),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::rbrace),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::enum_specifier, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::enum_),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::ident),], precedence
            : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::enumerator_list, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::enumerator),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::enumerator_list, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::enumerator_list),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::comma),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::enumerator),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::enumerator, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::ident),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::enumerator, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::ident),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::assign),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::conditional_expression),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::init_declarator, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::declarator),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::init_declarator, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::declarator),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::assign),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::initializer),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::init_declarator_list, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::init_declarator),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::init_declarator_list, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::init_declarator_list),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::comma),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::init_declarator),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::_statement_or_declarationPlus58, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::statement_or_declaration),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::_statement_or_declarationPlus58, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_statement_or_declarationPlus58),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::statement_or_declaration),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::_statement_or_declarationStar59, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_statement_or_declarationPlus58),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::_statement_or_declarationStar59, rule : vec![],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::_declaration_specifierPlus60, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::declaration_specifier),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::_declaration_specifierPlus60, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_declaration_specifierPlus60),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::declaration_specifier),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::_external_declarationPlus61, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::external_declaration),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::_external_declarationPlus61, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_external_declarationPlus61),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::external_declaration),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::_external_declarationStar62, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_external_declarationPlus61),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::_external_declarationStar62, rule : vec![],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::_type_qualifierPlus63, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::type_qualifier),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::_type_qualifierPlus63, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_type_qualifierPlus63),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::type_qualifier),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::_type_qualifierStar64, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_type_qualifierPlus63),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::_type_qualifierStar64, rule : vec![],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::_specifier_qualifierPlus65, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::specifier_qualifier),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::_specifier_qualifierPlus65, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_specifier_qualifierPlus65),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::specifier_qualifier),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::_abstract_declaratorQuestion66, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::abstract_declarator),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::_abstract_declaratorQuestion66, rule : vec![],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::_identQuestion67, rule :
            vec![::rusty_lr::Token::Term(translation_unitTerminalClasses::ident),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::_identQuestion67, rule : vec![], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::_struct_declarationPlus68, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::struct_declaration),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::_struct_declarationPlus68, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_struct_declarationPlus68),
            ::rusty_lr::Token::NonTerm(translation_unitNonTerminals::struct_declaration),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::_struct_declarationStar69, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::_struct_declarationPlus68),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::_struct_declarationStar69, rule : vec![],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            translation_unitNonTerminals::Augmented, rule :
            vec![::rusty_lr::Token::NonTerm(translation_unitNonTerminals::translation_unit),
            ::rusty_lr::Token::Term(translation_unitTerminalClasses::eof),], precedence :
            None, },
        ];
        let __rustylr_tset43: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::ident,
            translation_unitTerminalClasses::lparen,
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::string_literal,
            translation_unitTerminalClasses::constant_character,
            translation_unitTerminalClasses::constant_integer,
            translation_unitTerminalClasses::constant_long,
            translation_unitTerminalClasses::constant_unsigned_integer,
            translation_unitTerminalClasses::constant_unsigned_long,
            translation_unitTerminalClasses::constant_float,
            translation_unitTerminalClasses::constant_double,
            translation_unitTerminalClasses::lbrace,
            translation_unitTerminalClasses::rbrace,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::inc_op,
            translation_unitTerminalClasses::dec_op,
            translation_unitTerminalClasses::sizeof,
            translation_unitTerminalClasses::ampersand,
            translation_unitTerminalClasses::exclamation,
            translation_unitTerminalClasses::tilde,
            translation_unitTerminalClasses::minus,
            translation_unitTerminalClasses::plus, translation_unitTerminalClasses::star,
            translation_unitTerminalClasses::case,
            translation_unitTerminalClasses::default,
            translation_unitTerminalClasses::if_, translation_unitTerminalClasses::else_,
            translation_unitTerminalClasses::switch,
            translation_unitTerminalClasses::while_,
            translation_unitTerminalClasses::do_, translation_unitTerminalClasses::for_,
            translation_unitTerminalClasses::goto_,
            translation_unitTerminalClasses::continue_,
            translation_unitTerminalClasses::break_,
            translation_unitTerminalClasses::return_,
            translation_unitTerminalClasses::typedef,
            translation_unitTerminalClasses::extern_,
            translation_unitTerminalClasses::static_,
            translation_unitTerminalClasses::auto,
            translation_unitTerminalClasses::register,
            translation_unitTerminalClasses::const_,
            translation_unitTerminalClasses::volatile,
            translation_unitTerminalClasses::void_,
            translation_unitTerminalClasses::char_,
            translation_unitTerminalClasses::short_,
            translation_unitTerminalClasses::int_,
            translation_unitTerminalClasses::long_,
            translation_unitTerminalClasses::float_,
            translation_unitTerminalClasses::double_,
            translation_unitTerminalClasses::signed,
            translation_unitTerminalClasses::unsigned,
            translation_unitTerminalClasses::struct_,
            translation_unitTerminalClasses::union_,
            translation_unitTerminalClasses::enum_
        ];
        let __rustylr_tset6: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::ident,
            translation_unitTerminalClasses::lparen,
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::lbracket,
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::star,
            translation_unitTerminalClasses::typedef,
            translation_unitTerminalClasses::extern_,
            translation_unitTerminalClasses::static_,
            translation_unitTerminalClasses::auto,
            translation_unitTerminalClasses::register,
            translation_unitTerminalClasses::const_,
            translation_unitTerminalClasses::volatile,
            translation_unitTerminalClasses::void_,
            translation_unitTerminalClasses::char_,
            translation_unitTerminalClasses::short_,
            translation_unitTerminalClasses::int_,
            translation_unitTerminalClasses::long_,
            translation_unitTerminalClasses::float_,
            translation_unitTerminalClasses::double_,
            translation_unitTerminalClasses::signed,
            translation_unitTerminalClasses::unsigned,
            translation_unitTerminalClasses::struct_,
            translation_unitTerminalClasses::union_,
            translation_unitTerminalClasses::enum_
        ];
        let __rustylr_tset8: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::ident,
            translation_unitTerminalClasses::lparen,
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::lbracket,
            translation_unitTerminalClasses::comma, translation_unitTerminalClasses::star
        ];
        let __rustylr_tset10: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::ident,
            translation_unitTerminalClasses::lparen,
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::lbracket,
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::star,
            translation_unitTerminalClasses::typedef,
            translation_unitTerminalClasses::extern_,
            translation_unitTerminalClasses::static_,
            translation_unitTerminalClasses::auto,
            translation_unitTerminalClasses::register,
            translation_unitTerminalClasses::const_,
            translation_unitTerminalClasses::volatile,
            translation_unitTerminalClasses::void_,
            translation_unitTerminalClasses::char_,
            translation_unitTerminalClasses::short_,
            translation_unitTerminalClasses::int_,
            translation_unitTerminalClasses::long_,
            translation_unitTerminalClasses::float_,
            translation_unitTerminalClasses::double_,
            translation_unitTerminalClasses::signed,
            translation_unitTerminalClasses::unsigned,
            translation_unitTerminalClasses::struct_,
            translation_unitTerminalClasses::union_,
            translation_unitTerminalClasses::enum_
        ];
        let __rustylr_tset7: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::ident,
            translation_unitTerminalClasses::lparen,
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::lbracket,
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::star,
            translation_unitTerminalClasses::const_,
            translation_unitTerminalClasses::volatile
        ];
        let __rustylr_tset31: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::ident,
            translation_unitTerminalClasses::lparen,
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::lbracket,
            translation_unitTerminalClasses::star,
            translation_unitTerminalClasses::const_,
            translation_unitTerminalClasses::volatile,
            translation_unitTerminalClasses::void_,
            translation_unitTerminalClasses::char_,
            translation_unitTerminalClasses::short_,
            translation_unitTerminalClasses::int_,
            translation_unitTerminalClasses::long_,
            translation_unitTerminalClasses::float_,
            translation_unitTerminalClasses::double_,
            translation_unitTerminalClasses::signed,
            translation_unitTerminalClasses::unsigned,
            translation_unitTerminalClasses::struct_,
            translation_unitTerminalClasses::union_,
            translation_unitTerminalClasses::enum_
        ];
        let __rustylr_tset44: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::ident,
            translation_unitTerminalClasses::lparen,
            translation_unitTerminalClasses::string_literal,
            translation_unitTerminalClasses::constant_character,
            translation_unitTerminalClasses::constant_integer,
            translation_unitTerminalClasses::constant_long,
            translation_unitTerminalClasses::constant_unsigned_integer,
            translation_unitTerminalClasses::constant_unsigned_long,
            translation_unitTerminalClasses::constant_float,
            translation_unitTerminalClasses::constant_double,
            translation_unitTerminalClasses::lbrace,
            translation_unitTerminalClasses::rbrace,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::inc_op,
            translation_unitTerminalClasses::dec_op,
            translation_unitTerminalClasses::sizeof,
            translation_unitTerminalClasses::ampersand,
            translation_unitTerminalClasses::exclamation,
            translation_unitTerminalClasses::tilde,
            translation_unitTerminalClasses::minus,
            translation_unitTerminalClasses::plus, translation_unitTerminalClasses::star,
            translation_unitTerminalClasses::case,
            translation_unitTerminalClasses::default,
            translation_unitTerminalClasses::if_, translation_unitTerminalClasses::else_,
            translation_unitTerminalClasses::switch,
            translation_unitTerminalClasses::while_,
            translation_unitTerminalClasses::do_, translation_unitTerminalClasses::for_,
            translation_unitTerminalClasses::goto_,
            translation_unitTerminalClasses::continue_,
            translation_unitTerminalClasses::break_,
            translation_unitTerminalClasses::return_,
            translation_unitTerminalClasses::typedef,
            translation_unitTerminalClasses::extern_,
            translation_unitTerminalClasses::static_,
            translation_unitTerminalClasses::auto,
            translation_unitTerminalClasses::register,
            translation_unitTerminalClasses::const_,
            translation_unitTerminalClasses::volatile,
            translation_unitTerminalClasses::void_,
            translation_unitTerminalClasses::char_,
            translation_unitTerminalClasses::short_,
            translation_unitTerminalClasses::int_,
            translation_unitTerminalClasses::long_,
            translation_unitTerminalClasses::float_,
            translation_unitTerminalClasses::double_,
            translation_unitTerminalClasses::signed,
            translation_unitTerminalClasses::unsigned,
            translation_unitTerminalClasses::struct_,
            translation_unitTerminalClasses::union_,
            translation_unitTerminalClasses::enum_
        ];
        let __rustylr_tset48: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::ident,
            translation_unitTerminalClasses::lparen,
            translation_unitTerminalClasses::string_literal,
            translation_unitTerminalClasses::constant_character,
            translation_unitTerminalClasses::constant_integer,
            translation_unitTerminalClasses::constant_long,
            translation_unitTerminalClasses::constant_unsigned_integer,
            translation_unitTerminalClasses::constant_unsigned_long,
            translation_unitTerminalClasses::constant_float,
            translation_unitTerminalClasses::constant_double,
            translation_unitTerminalClasses::lbrace,
            translation_unitTerminalClasses::rbrace,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::inc_op,
            translation_unitTerminalClasses::dec_op,
            translation_unitTerminalClasses::sizeof,
            translation_unitTerminalClasses::ampersand,
            translation_unitTerminalClasses::exclamation,
            translation_unitTerminalClasses::tilde,
            translation_unitTerminalClasses::minus,
            translation_unitTerminalClasses::plus, translation_unitTerminalClasses::star,
            translation_unitTerminalClasses::case,
            translation_unitTerminalClasses::default,
            translation_unitTerminalClasses::if_, translation_unitTerminalClasses::else_,
            translation_unitTerminalClasses::switch,
            translation_unitTerminalClasses::while_,
            translation_unitTerminalClasses::do_, translation_unitTerminalClasses::for_,
            translation_unitTerminalClasses::goto_,
            translation_unitTerminalClasses::continue_,
            translation_unitTerminalClasses::break_,
            translation_unitTerminalClasses::return_,
            translation_unitTerminalClasses::typedef,
            translation_unitTerminalClasses::extern_,
            translation_unitTerminalClasses::static_,
            translation_unitTerminalClasses::auto,
            translation_unitTerminalClasses::register,
            translation_unitTerminalClasses::const_,
            translation_unitTerminalClasses::volatile,
            translation_unitTerminalClasses::void_,
            translation_unitTerminalClasses::char_,
            translation_unitTerminalClasses::short_,
            translation_unitTerminalClasses::int_,
            translation_unitTerminalClasses::long_,
            translation_unitTerminalClasses::float_,
            translation_unitTerminalClasses::double_,
            translation_unitTerminalClasses::signed,
            translation_unitTerminalClasses::unsigned,
            translation_unitTerminalClasses::struct_,
            translation_unitTerminalClasses::union_,
            translation_unitTerminalClasses::enum_, translation_unitTerminalClasses::eof
        ];
        let __rustylr_tset47: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::ident,
            translation_unitTerminalClasses::lparen,
            translation_unitTerminalClasses::string_literal,
            translation_unitTerminalClasses::constant_character,
            translation_unitTerminalClasses::constant_integer,
            translation_unitTerminalClasses::constant_long,
            translation_unitTerminalClasses::constant_unsigned_integer,
            translation_unitTerminalClasses::constant_unsigned_long,
            translation_unitTerminalClasses::constant_float,
            translation_unitTerminalClasses::constant_double,
            translation_unitTerminalClasses::lbrace,
            translation_unitTerminalClasses::rbrace,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::inc_op,
            translation_unitTerminalClasses::dec_op,
            translation_unitTerminalClasses::sizeof,
            translation_unitTerminalClasses::ampersand,
            translation_unitTerminalClasses::exclamation,
            translation_unitTerminalClasses::tilde,
            translation_unitTerminalClasses::minus,
            translation_unitTerminalClasses::plus, translation_unitTerminalClasses::star,
            translation_unitTerminalClasses::case,
            translation_unitTerminalClasses::default,
            translation_unitTerminalClasses::if_,
            translation_unitTerminalClasses::switch,
            translation_unitTerminalClasses::while_,
            translation_unitTerminalClasses::do_, translation_unitTerminalClasses::for_,
            translation_unitTerminalClasses::goto_,
            translation_unitTerminalClasses::continue_,
            translation_unitTerminalClasses::break_,
            translation_unitTerminalClasses::return_,
            translation_unitTerminalClasses::typedef,
            translation_unitTerminalClasses::extern_,
            translation_unitTerminalClasses::static_,
            translation_unitTerminalClasses::auto,
            translation_unitTerminalClasses::register,
            translation_unitTerminalClasses::const_,
            translation_unitTerminalClasses::volatile,
            translation_unitTerminalClasses::void_,
            translation_unitTerminalClasses::char_,
            translation_unitTerminalClasses::short_,
            translation_unitTerminalClasses::int_,
            translation_unitTerminalClasses::long_,
            translation_unitTerminalClasses::float_,
            translation_unitTerminalClasses::double_,
            translation_unitTerminalClasses::signed,
            translation_unitTerminalClasses::unsigned,
            translation_unitTerminalClasses::struct_,
            translation_unitTerminalClasses::union_,
            translation_unitTerminalClasses::enum_
        ];
        let __rustylr_tset45: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::ident,
            translation_unitTerminalClasses::lparen,
            translation_unitTerminalClasses::string_literal,
            translation_unitTerminalClasses::constant_character,
            translation_unitTerminalClasses::constant_integer,
            translation_unitTerminalClasses::constant_long,
            translation_unitTerminalClasses::constant_unsigned_integer,
            translation_unitTerminalClasses::constant_unsigned_long,
            translation_unitTerminalClasses::constant_float,
            translation_unitTerminalClasses::constant_double,
            translation_unitTerminalClasses::lbrace,
            translation_unitTerminalClasses::rbrace,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::inc_op,
            translation_unitTerminalClasses::dec_op,
            translation_unitTerminalClasses::sizeof,
            translation_unitTerminalClasses::ampersand,
            translation_unitTerminalClasses::exclamation,
            translation_unitTerminalClasses::tilde,
            translation_unitTerminalClasses::minus,
            translation_unitTerminalClasses::plus, translation_unitTerminalClasses::star,
            translation_unitTerminalClasses::case,
            translation_unitTerminalClasses::default,
            translation_unitTerminalClasses::if_,
            translation_unitTerminalClasses::switch,
            translation_unitTerminalClasses::while_,
            translation_unitTerminalClasses::do_, translation_unitTerminalClasses::for_,
            translation_unitTerminalClasses::goto_,
            translation_unitTerminalClasses::continue_,
            translation_unitTerminalClasses::break_,
            translation_unitTerminalClasses::return_,
            translation_unitTerminalClasses::typedef,
            translation_unitTerminalClasses::extern_,
            translation_unitTerminalClasses::static_,
            translation_unitTerminalClasses::auto,
            translation_unitTerminalClasses::register,
            translation_unitTerminalClasses::const_,
            translation_unitTerminalClasses::volatile,
            translation_unitTerminalClasses::void_,
            translation_unitTerminalClasses::char_,
            translation_unitTerminalClasses::short_,
            translation_unitTerminalClasses::int_,
            translation_unitTerminalClasses::long_,
            translation_unitTerminalClasses::float_,
            translation_unitTerminalClasses::double_,
            translation_unitTerminalClasses::signed,
            translation_unitTerminalClasses::unsigned,
            translation_unitTerminalClasses::struct_,
            translation_unitTerminalClasses::union_,
            translation_unitTerminalClasses::enum_, translation_unitTerminalClasses::eof
        ];
        let __rustylr_tset5: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::ident,
            translation_unitTerminalClasses::lparen,
            translation_unitTerminalClasses::star
        ];
        let __rustylr_tset39: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::ident,
            translation_unitTerminalClasses::lparen,
            translation_unitTerminalClasses::star,
            translation_unitTerminalClasses::typedef,
            translation_unitTerminalClasses::extern_,
            translation_unitTerminalClasses::static_,
            translation_unitTerminalClasses::auto,
            translation_unitTerminalClasses::register,
            translation_unitTerminalClasses::const_,
            translation_unitTerminalClasses::volatile,
            translation_unitTerminalClasses::void_,
            translation_unitTerminalClasses::char_,
            translation_unitTerminalClasses::short_,
            translation_unitTerminalClasses::int_,
            translation_unitTerminalClasses::long_,
            translation_unitTerminalClasses::float_,
            translation_unitTerminalClasses::double_,
            translation_unitTerminalClasses::signed,
            translation_unitTerminalClasses::unsigned,
            translation_unitTerminalClasses::struct_,
            translation_unitTerminalClasses::union_,
            translation_unitTerminalClasses::enum_, translation_unitTerminalClasses::eof
        ];
        let __rustylr_tset11: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::ident,
            translation_unitTerminalClasses::lbrace
        ];
        let __rustylr_tset33: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::ident,
            translation_unitTerminalClasses::rbrace,
            translation_unitTerminalClasses::const_,
            translation_unitTerminalClasses::volatile,
            translation_unitTerminalClasses::void_,
            translation_unitTerminalClasses::char_,
            translation_unitTerminalClasses::short_,
            translation_unitTerminalClasses::int_,
            translation_unitTerminalClasses::long_,
            translation_unitTerminalClasses::float_,
            translation_unitTerminalClasses::double_,
            translation_unitTerminalClasses::signed,
            translation_unitTerminalClasses::unsigned,
            translation_unitTerminalClasses::struct_,
            translation_unitTerminalClasses::union_,
            translation_unitTerminalClasses::enum_
        ];
        let __rustylr_tset3: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::ident,
            translation_unitTerminalClasses::star,
            translation_unitTerminalClasses::typedef,
            translation_unitTerminalClasses::extern_,
            translation_unitTerminalClasses::static_,
            translation_unitTerminalClasses::auto,
            translation_unitTerminalClasses::register,
            translation_unitTerminalClasses::const_,
            translation_unitTerminalClasses::volatile,
            translation_unitTerminalClasses::void_,
            translation_unitTerminalClasses::char_,
            translation_unitTerminalClasses::short_,
            translation_unitTerminalClasses::int_,
            translation_unitTerminalClasses::long_,
            translation_unitTerminalClasses::float_,
            translation_unitTerminalClasses::double_,
            translation_unitTerminalClasses::signed,
            translation_unitTerminalClasses::unsigned,
            translation_unitTerminalClasses::struct_,
            translation_unitTerminalClasses::union_,
            translation_unitTerminalClasses::enum_
        ];
        let __rustylr_tset17: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::ident,
            translation_unitTerminalClasses::typedef,
            translation_unitTerminalClasses::extern_,
            translation_unitTerminalClasses::static_,
            translation_unitTerminalClasses::auto,
            translation_unitTerminalClasses::register,
            translation_unitTerminalClasses::const_,
            translation_unitTerminalClasses::volatile,
            translation_unitTerminalClasses::void_,
            translation_unitTerminalClasses::char_,
            translation_unitTerminalClasses::short_,
            translation_unitTerminalClasses::int_,
            translation_unitTerminalClasses::long_,
            translation_unitTerminalClasses::float_,
            translation_unitTerminalClasses::double_,
            translation_unitTerminalClasses::signed,
            translation_unitTerminalClasses::unsigned,
            translation_unitTerminalClasses::struct_,
            translation_unitTerminalClasses::union_,
            translation_unitTerminalClasses::enum_
        ];
        let __rustylr_tset14: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::lparen,
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::lbracket,
            translation_unitTerminalClasses::rbracket,
            translation_unitTerminalClasses::rbrace,
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::question,
            translation_unitTerminalClasses::colon, translation_unitTerminalClasses::dot,
            translation_unitTerminalClasses::ptr_op,
            translation_unitTerminalClasses::inc_op,
            translation_unitTerminalClasses::dec_op,
            translation_unitTerminalClasses::ampersand,
            translation_unitTerminalClasses::minus,
            translation_unitTerminalClasses::plus, translation_unitTerminalClasses::star,
            translation_unitTerminalClasses::slash,
            translation_unitTerminalClasses::percent,
            translation_unitTerminalClasses::left_op,
            translation_unitTerminalClasses::right_op,
            translation_unitTerminalClasses::less,
            translation_unitTerminalClasses::greater,
            translation_unitTerminalClasses::caret,
            translation_unitTerminalClasses::pipe, translation_unitTerminalClasses::le,
            translation_unitTerminalClasses::ge, translation_unitTerminalClasses::eq,
            translation_unitTerminalClasses::ne, translation_unitTerminalClasses::and_op,
            translation_unitTerminalClasses::or_op,
            translation_unitTerminalClasses::assign,
            translation_unitTerminalClasses::mul_assign,
            translation_unitTerminalClasses::div_assign,
            translation_unitTerminalClasses::mod_assign,
            translation_unitTerminalClasses::add_assign,
            translation_unitTerminalClasses::sub_assign,
            translation_unitTerminalClasses::left_assign,
            translation_unitTerminalClasses::right_assign,
            translation_unitTerminalClasses::and_assign,
            translation_unitTerminalClasses::xor_assign,
            translation_unitTerminalClasses::or_assign
        ];
        let __rustylr_tset4: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::lparen,
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::lbracket,
            translation_unitTerminalClasses::lbrace,
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::assign
        ];
        let __rustylr_tset36: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::lparen,
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::lbracket,
            translation_unitTerminalClasses::comma
        ];
        let __rustylr_tset2: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::lparen,
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::lbracket,
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::semicolon
        ];
        let __rustylr_tset16: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::lparen,
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::lbracket,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::star
        ];
        let __rustylr_tset37: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::lparen,
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::lbracket,
            translation_unitTerminalClasses::star
        ];
        let __rustylr_tset42: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::lparen,
            translation_unitTerminalClasses::lbracket,
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::question,
            translation_unitTerminalClasses::dot,
            translation_unitTerminalClasses::ptr_op,
            translation_unitTerminalClasses::inc_op,
            translation_unitTerminalClasses::dec_op,
            translation_unitTerminalClasses::ampersand,
            translation_unitTerminalClasses::minus,
            translation_unitTerminalClasses::plus, translation_unitTerminalClasses::star,
            translation_unitTerminalClasses::slash,
            translation_unitTerminalClasses::percent,
            translation_unitTerminalClasses::left_op,
            translation_unitTerminalClasses::right_op,
            translation_unitTerminalClasses::less,
            translation_unitTerminalClasses::greater,
            translation_unitTerminalClasses::caret,
            translation_unitTerminalClasses::pipe, translation_unitTerminalClasses::le,
            translation_unitTerminalClasses::ge, translation_unitTerminalClasses::eq,
            translation_unitTerminalClasses::ne, translation_unitTerminalClasses::and_op,
            translation_unitTerminalClasses::or_op,
            translation_unitTerminalClasses::assign,
            translation_unitTerminalClasses::mul_assign,
            translation_unitTerminalClasses::div_assign,
            translation_unitTerminalClasses::mod_assign,
            translation_unitTerminalClasses::add_assign,
            translation_unitTerminalClasses::sub_assign,
            translation_unitTerminalClasses::left_assign,
            translation_unitTerminalClasses::right_assign,
            translation_unitTerminalClasses::and_assign,
            translation_unitTerminalClasses::xor_assign,
            translation_unitTerminalClasses::or_assign
        ];
        let __rustylr_tset41: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::lparen,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::star
        ];
        let __rustylr_tset35: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::rparen
        ];
        let __rustylr_tset19: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::rbracket,
            translation_unitTerminalClasses::rbrace,
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::question,
            translation_unitTerminalClasses::colon,
            translation_unitTerminalClasses::ampersand,
            translation_unitTerminalClasses::minus,
            translation_unitTerminalClasses::plus, translation_unitTerminalClasses::star,
            translation_unitTerminalClasses::slash,
            translation_unitTerminalClasses::percent,
            translation_unitTerminalClasses::left_op,
            translation_unitTerminalClasses::right_op,
            translation_unitTerminalClasses::less,
            translation_unitTerminalClasses::greater,
            translation_unitTerminalClasses::caret,
            translation_unitTerminalClasses::pipe, translation_unitTerminalClasses::le,
            translation_unitTerminalClasses::ge, translation_unitTerminalClasses::eq,
            translation_unitTerminalClasses::ne, translation_unitTerminalClasses::and_op,
            translation_unitTerminalClasses::or_op
        ];
        let __rustylr_tset18: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::rbracket,
            translation_unitTerminalClasses::rbrace,
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::question,
            translation_unitTerminalClasses::colon,
            translation_unitTerminalClasses::ampersand,
            translation_unitTerminalClasses::minus,
            translation_unitTerminalClasses::plus, translation_unitTerminalClasses::star,
            translation_unitTerminalClasses::slash,
            translation_unitTerminalClasses::percent,
            translation_unitTerminalClasses::left_op,
            translation_unitTerminalClasses::right_op,
            translation_unitTerminalClasses::less,
            translation_unitTerminalClasses::greater,
            translation_unitTerminalClasses::caret,
            translation_unitTerminalClasses::pipe, translation_unitTerminalClasses::le,
            translation_unitTerminalClasses::ge, translation_unitTerminalClasses::eq,
            translation_unitTerminalClasses::ne, translation_unitTerminalClasses::and_op,
            translation_unitTerminalClasses::or_op,
            translation_unitTerminalClasses::assign,
            translation_unitTerminalClasses::mul_assign,
            translation_unitTerminalClasses::div_assign,
            translation_unitTerminalClasses::mod_assign,
            translation_unitTerminalClasses::add_assign,
            translation_unitTerminalClasses::sub_assign,
            translation_unitTerminalClasses::left_assign,
            translation_unitTerminalClasses::right_assign,
            translation_unitTerminalClasses::and_assign,
            translation_unitTerminalClasses::xor_assign,
            translation_unitTerminalClasses::or_assign
        ];
        let __rustylr_tset20: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::rbracket,
            translation_unitTerminalClasses::rbrace,
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::question,
            translation_unitTerminalClasses::colon,
            translation_unitTerminalClasses::ampersand,
            translation_unitTerminalClasses::minus,
            translation_unitTerminalClasses::plus,
            translation_unitTerminalClasses::left_op,
            translation_unitTerminalClasses::right_op,
            translation_unitTerminalClasses::less,
            translation_unitTerminalClasses::greater,
            translation_unitTerminalClasses::caret,
            translation_unitTerminalClasses::pipe, translation_unitTerminalClasses::le,
            translation_unitTerminalClasses::ge, translation_unitTerminalClasses::eq,
            translation_unitTerminalClasses::ne, translation_unitTerminalClasses::and_op,
            translation_unitTerminalClasses::or_op
        ];
        let __rustylr_tset21: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::rbracket,
            translation_unitTerminalClasses::rbrace,
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::question,
            translation_unitTerminalClasses::colon,
            translation_unitTerminalClasses::ampersand,
            translation_unitTerminalClasses::left_op,
            translation_unitTerminalClasses::right_op,
            translation_unitTerminalClasses::less,
            translation_unitTerminalClasses::greater,
            translation_unitTerminalClasses::caret,
            translation_unitTerminalClasses::pipe, translation_unitTerminalClasses::le,
            translation_unitTerminalClasses::ge, translation_unitTerminalClasses::eq,
            translation_unitTerminalClasses::ne, translation_unitTerminalClasses::and_op,
            translation_unitTerminalClasses::or_op
        ];
        let __rustylr_tset22: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::rbracket,
            translation_unitTerminalClasses::rbrace,
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::question,
            translation_unitTerminalClasses::colon,
            translation_unitTerminalClasses::ampersand,
            translation_unitTerminalClasses::less,
            translation_unitTerminalClasses::greater,
            translation_unitTerminalClasses::caret,
            translation_unitTerminalClasses::pipe, translation_unitTerminalClasses::le,
            translation_unitTerminalClasses::ge, translation_unitTerminalClasses::eq,
            translation_unitTerminalClasses::ne, translation_unitTerminalClasses::and_op,
            translation_unitTerminalClasses::or_op
        ];
        let __rustylr_tset23: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::rbracket,
            translation_unitTerminalClasses::rbrace,
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::question,
            translation_unitTerminalClasses::colon,
            translation_unitTerminalClasses::ampersand,
            translation_unitTerminalClasses::caret,
            translation_unitTerminalClasses::pipe, translation_unitTerminalClasses::eq,
            translation_unitTerminalClasses::ne, translation_unitTerminalClasses::and_op,
            translation_unitTerminalClasses::or_op
        ];
        let __rustylr_tset24: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::rbracket,
            translation_unitTerminalClasses::rbrace,
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::question,
            translation_unitTerminalClasses::colon,
            translation_unitTerminalClasses::ampersand,
            translation_unitTerminalClasses::caret,
            translation_unitTerminalClasses::pipe,
            translation_unitTerminalClasses::and_op,
            translation_unitTerminalClasses::or_op
        ];
        let __rustylr_tset25: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::rbracket,
            translation_unitTerminalClasses::rbrace,
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::question,
            translation_unitTerminalClasses::colon,
            translation_unitTerminalClasses::caret,
            translation_unitTerminalClasses::pipe,
            translation_unitTerminalClasses::and_op,
            translation_unitTerminalClasses::or_op
        ];
        let __rustylr_tset26: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::rbracket,
            translation_unitTerminalClasses::rbrace,
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::question,
            translation_unitTerminalClasses::colon,
            translation_unitTerminalClasses::pipe,
            translation_unitTerminalClasses::and_op,
            translation_unitTerminalClasses::or_op
        ];
        let __rustylr_tset27: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::rbracket,
            translation_unitTerminalClasses::rbrace,
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::question,
            translation_unitTerminalClasses::colon,
            translation_unitTerminalClasses::and_op,
            translation_unitTerminalClasses::or_op
        ];
        let __rustylr_tset28: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::rbracket,
            translation_unitTerminalClasses::rbrace,
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::question,
            translation_unitTerminalClasses::colon,
            translation_unitTerminalClasses::or_op
        ];
        let __rustylr_tset29: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::rbracket,
            translation_unitTerminalClasses::rbrace,
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::colon
        ];
        let __rustylr_tset30: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::rbracket,
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::colon
        ];
        let __rustylr_tset9: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::lbrace,
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::semicolon,
            translation_unitTerminalClasses::assign
        ];
        let __rustylr_tset34: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::rparen,
            translation_unitTerminalClasses::comma
        ];
        let __rustylr_tset40: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::lbracket,
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::question,
            translation_unitTerminalClasses::dot,
            translation_unitTerminalClasses::ptr_op,
            translation_unitTerminalClasses::inc_op,
            translation_unitTerminalClasses::dec_op,
            translation_unitTerminalClasses::ampersand,
            translation_unitTerminalClasses::minus,
            translation_unitTerminalClasses::plus,
            translation_unitTerminalClasses::slash,
            translation_unitTerminalClasses::percent,
            translation_unitTerminalClasses::left_op,
            translation_unitTerminalClasses::right_op,
            translation_unitTerminalClasses::less,
            translation_unitTerminalClasses::greater,
            translation_unitTerminalClasses::caret,
            translation_unitTerminalClasses::pipe, translation_unitTerminalClasses::le,
            translation_unitTerminalClasses::ge, translation_unitTerminalClasses::eq,
            translation_unitTerminalClasses::ne, translation_unitTerminalClasses::and_op,
            translation_unitTerminalClasses::or_op,
            translation_unitTerminalClasses::assign,
            translation_unitTerminalClasses::mul_assign,
            translation_unitTerminalClasses::div_assign,
            translation_unitTerminalClasses::mod_assign,
            translation_unitTerminalClasses::add_assign,
            translation_unitTerminalClasses::sub_assign,
            translation_unitTerminalClasses::left_assign,
            translation_unitTerminalClasses::right_assign,
            translation_unitTerminalClasses::and_assign,
            translation_unitTerminalClasses::xor_assign,
            translation_unitTerminalClasses::or_assign
        ];
        let __rustylr_tset12: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::lbrace
        ];
        let __rustylr_tset1: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::lbrace,
            translation_unitTerminalClasses::assign
        ];
        let __rustylr_tset32: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::rbrace
        ];
        let __rustylr_tset13: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::rbrace,
            translation_unitTerminalClasses::comma
        ];
        let __rustylr_tset46: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::rbrace,
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::semicolon
        ];
        let __rustylr_tset38: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::semicolon
        ];
        let __rustylr_tset15: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::comma,
            translation_unitTerminalClasses::question,
            translation_unitTerminalClasses::dot,
            translation_unitTerminalClasses::ptr_op,
            translation_unitTerminalClasses::inc_op,
            translation_unitTerminalClasses::dec_op,
            translation_unitTerminalClasses::ampersand,
            translation_unitTerminalClasses::minus,
            translation_unitTerminalClasses::plus,
            translation_unitTerminalClasses::slash,
            translation_unitTerminalClasses::percent,
            translation_unitTerminalClasses::left_op,
            translation_unitTerminalClasses::right_op,
            translation_unitTerminalClasses::less,
            translation_unitTerminalClasses::greater,
            translation_unitTerminalClasses::caret,
            translation_unitTerminalClasses::pipe, translation_unitTerminalClasses::le,
            translation_unitTerminalClasses::ge, translation_unitTerminalClasses::eq,
            translation_unitTerminalClasses::ne, translation_unitTerminalClasses::and_op,
            translation_unitTerminalClasses::or_op,
            translation_unitTerminalClasses::assign,
            translation_unitTerminalClasses::mul_assign,
            translation_unitTerminalClasses::div_assign,
            translation_unitTerminalClasses::mod_assign,
            translation_unitTerminalClasses::add_assign,
            translation_unitTerminalClasses::sub_assign,
            translation_unitTerminalClasses::left_assign,
            translation_unitTerminalClasses::right_assign,
            translation_unitTerminalClasses::and_assign,
            translation_unitTerminalClasses::xor_assign,
            translation_unitTerminalClasses::or_assign
        ];
        let __rustylr_tset0: Vec<translation_unitTerminalClasses> = vec![
            translation_unitTerminalClasses::eof
        ];
        let states: Vec<
            ::rusty_lr::parser::state::IntermediateState<
                translation_unitTerminalClasses,
                translation_unitNonTerminals,
                u16,
                u8,
            >,
        > = vec![
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)),
            (translation_unitTerminalClasses::typedef,
            ::rusty_lr::parser::state::ShiftTarget::new(16, true)),
            (translation_unitTerminalClasses::extern_,
            ::rusty_lr::parser::state::ShiftTarget::new(17, true)),
            (translation_unitTerminalClasses::static_,
            ::rusty_lr::parser::state::ShiftTarget::new(18, true)),
            (translation_unitTerminalClasses::auto,
            ::rusty_lr::parser::state::ShiftTarget::new(19, true)),
            (translation_unitTerminalClasses::register,
            ::rusty_lr::parser::state::ShiftTarget::new(20, true)),
            (translation_unitTerminalClasses::const_,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)),
            (translation_unitTerminalClasses::volatile,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (translation_unitTerminalClasses::void_,
            ::rusty_lr::parser::state::ShiftTarget::new(21, true)),
            (translation_unitTerminalClasses::char_,
            ::rusty_lr::parser::state::ShiftTarget::new(22, true)),
            (translation_unitTerminalClasses::short_,
            ::rusty_lr::parser::state::ShiftTarget::new(23, true)),
            (translation_unitTerminalClasses::int_,
            ::rusty_lr::parser::state::ShiftTarget::new(24, true)),
            (translation_unitTerminalClasses::long_,
            ::rusty_lr::parser::state::ShiftTarget::new(25, true)),
            (translation_unitTerminalClasses::float_,
            ::rusty_lr::parser::state::ShiftTarget::new(26, true)),
            (translation_unitTerminalClasses::double_,
            ::rusty_lr::parser::state::ShiftTarget::new(27, true)),
            (translation_unitTerminalClasses::signed,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),
            (translation_unitTerminalClasses::unsigned,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (translation_unitTerminalClasses::struct_,
            ::rusty_lr::parser::state::ShiftTarget::new(30, true)),
            (translation_unitTerminalClasses::union_,
            ::rusty_lr::parser::state::ShiftTarget::new(31, true)),
            (translation_unitTerminalClasses::enum_,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::declaration,
            ::rusty_lr::parser::state::ShiftTarget::new(244, true)),
            (translation_unitNonTerminals::function_definition,
            ::rusty_lr::parser::state::ShiftTarget::new(244, true)),
            (translation_unitNonTerminals::external_declaration,
            ::rusty_lr::parser::state::ShiftTarget::new(244, true)),
            (translation_unitNonTerminals::translation_unit,
            ::rusty_lr::parser::state::ShiftTarget::new(245, true)),
            (translation_unitNonTerminals::type_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(133, true)),
            (translation_unitNonTerminals::declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(247, true)),
            (translation_unitNonTerminals::direct_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(12, true)),
            (translation_unitNonTerminals::type_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(134, true)),
            (translation_unitNonTerminals::storage_class_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(135, true)),
            (translation_unitNonTerminals::declaration_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(136, true)),
            (translation_unitNonTerminals::struct_or_union,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (translation_unitNonTerminals::struct_or_union_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(128, true)),
            (translation_unitNonTerminals::enum_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(129, true)),
            (translation_unitNonTerminals::_declaration_specifierPlus60,
            ::rusty_lr::parser::state::ShiftTarget::new(330, true)),
            (translation_unitNonTerminals::_external_declarationPlus61,
            ::rusty_lr::parser::state::ShiftTarget::new(333, true)),
            (translation_unitNonTerminals::_external_declarationStar62,
            ::rusty_lr::parser::state::ShiftTarget::new(335, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![196]; __reduce_map.extend(__rustylr_tset0.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [105, 106, 107, 108, 115, 116, 117, 118, 119,
            120, 121, 122, 123, 124, 125, 126, 127, 143, 144, 145, 146, 147, 148, 149,
            150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 170, 171,
            175, 176, 177, 178, 191, 192, 193, 194, 195, 196, 211,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![122]; __reduce_map.extend(__rustylr_tset1.iter().map(| term | (* term,
            reduce_rules.clone()))); let reduce_rules = vec![122, 152]; __reduce_map
            .extend(__rustylr_tset2.iter().map(| term | (* term, reduce_rules.clone())));
            let reduce_rules = vec![152]; __reduce_map.extend(__rustylr_tset3.iter()
            .map(| term | (* term, reduce_rules.clone()))); __reduce_map.into_iter()
            .collect() }, ruleset : { let rules : & 'static [u8] = & [122, 152,]; let
            shifted : & 'static [u8] = & [1, 1,]; rules.iter().zip(shifted.iter()).map(|
            (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(131, true)),
            (translation_unitNonTerminals::direct_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(12, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [120,
            121, 122, 123, 123, 124, 125, 126, 127,]; let shifted : & 'static [u8] = &
            [0, 0, 0, 0, 1, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule,
            & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![122]; __reduce_map
            .extend(__rustylr_tset4.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, ruleset : { let rules : & 'static [u8]
            = & [122,]; let shifted : & 'static [u8] = & [1,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::const_,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)),
            (translation_unitTerminalClasses::volatile,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::type_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)),
            (translation_unitNonTerminals::_type_qualifierPlus63,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)),
            (translation_unitNonTerminals::_type_qualifierStar64,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![200]; __reduce_map.extend(__rustylr_tset5.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [118, 119, 121, 197, 198, 199, 200,]; let
            shifted : & 'static [u8] = & [0, 0, 1, 0, 0, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![118]; __reduce_map
            .extend(__rustylr_tset6.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, ruleset : { let rules : & 'static [u8]
            = & [118,]; let shifted : & 'static [u8] = & [1,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![119]; __reduce_map
            .extend(__rustylr_tset6.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, ruleset : { let rules : & 'static [u8]
            = & [119,]; let shifted : & 'static [u8] = & [1,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![197]; __reduce_map
            .extend(__rustylr_tset7.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, ruleset : { let rules : & 'static [u8]
            = & [197,]; let shifted : & 'static [u8] = & [1,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::const_,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)),
            (translation_unitTerminalClasses::volatile,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::type_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![199]; __reduce_map.extend(__rustylr_tset8.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [118, 119, 198, 199,]; let shifted : & 'static
            [u8] = & [0, 0, 1, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![198]; __reduce_map
            .extend(__rustylr_tset7.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, ruleset : { let rules : & 'static [u8]
            = & [198,]; let shifted : & 'static [u8] = & [2,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)),
            (translation_unitNonTerminals::direct_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(12, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [120,
            121, 121, 122, 123, 124, 125, 126, 127,]; let shifted : & 'static [u8] = &
            [0, 0, 2, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule,
            & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![121]; __reduce_map
            .extend(__rustylr_tset9.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, ruleset : { let rules : & 'static [u8]
            = & [121,]; let shifted : & 'static [u8] = & [3,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(13, true)),
            (translation_unitTerminalClasses::lbracket,
            ::rusty_lr::parser::state::ShiftTarget::new(230, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![120]; __reduce_map
            .extend(__rustylr_tset9.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, ruleset : { let rules : & 'static [u8]
            = & [120, 124, 125, 126, 127,]; let shifted : & 'static [u8] = & [1, 1, 1, 1,
            1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)),
            (translation_unitTerminalClasses::rparen,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)),
            (translation_unitTerminalClasses::typedef,
            ::rusty_lr::parser::state::ShiftTarget::new(16, true)),
            (translation_unitTerminalClasses::extern_,
            ::rusty_lr::parser::state::ShiftTarget::new(17, true)),
            (translation_unitTerminalClasses::static_,
            ::rusty_lr::parser::state::ShiftTarget::new(18, true)),
            (translation_unitTerminalClasses::auto,
            ::rusty_lr::parser::state::ShiftTarget::new(19, true)),
            (translation_unitTerminalClasses::register,
            ::rusty_lr::parser::state::ShiftTarget::new(20, true)),
            (translation_unitTerminalClasses::const_,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)),
            (translation_unitTerminalClasses::volatile,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (translation_unitTerminalClasses::void_,
            ::rusty_lr::parser::state::ShiftTarget::new(21, true)),
            (translation_unitTerminalClasses::char_,
            ::rusty_lr::parser::state::ShiftTarget::new(22, true)),
            (translation_unitTerminalClasses::short_,
            ::rusty_lr::parser::state::ShiftTarget::new(23, true)),
            (translation_unitTerminalClasses::int_,
            ::rusty_lr::parser::state::ShiftTarget::new(24, true)),
            (translation_unitTerminalClasses::long_,
            ::rusty_lr::parser::state::ShiftTarget::new(25, true)),
            (translation_unitTerminalClasses::float_,
            ::rusty_lr::parser::state::ShiftTarget::new(26, true)),
            (translation_unitTerminalClasses::double_,
            ::rusty_lr::parser::state::ShiftTarget::new(27, true)),
            (translation_unitTerminalClasses::signed,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),
            (translation_unitTerminalClasses::unsigned,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (translation_unitTerminalClasses::struct_,
            ::rusty_lr::parser::state::ShiftTarget::new(30, true)),
            (translation_unitTerminalClasses::union_,
            ::rusty_lr::parser::state::ShiftTarget::new(31, true)),
            (translation_unitTerminalClasses::enum_,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::type_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(133, true)),
            (translation_unitNonTerminals::type_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(134, true)),
            (translation_unitNonTerminals::storage_class_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(135, true)),
            (translation_unitNonTerminals::declaration_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(136, true)),
            (translation_unitNonTerminals::parameter_declaration,
            ::rusty_lr::parser::state::ShiftTarget::new(137, true)),
            (translation_unitNonTerminals::parameter_list,
            ::rusty_lr::parser::state::ShiftTarget::new(138, true)),
            (translation_unitNonTerminals::parameter_type_list,
            ::rusty_lr::parser::state::ShiftTarget::new(228, true)),
            (translation_unitNonTerminals::struct_or_union,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (translation_unitNonTerminals::struct_or_union_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(128, true)),
            (translation_unitNonTerminals::enum_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(129, true)),
            (translation_unitNonTerminals::_declaration_specifierPlus60,
            ::rusty_lr::parser::state::ShiftTarget::new(146, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [118,
            119, 126, 127, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154,
            155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169,
            170, 171, 175, 176, 177, 178, 191, 192,]; let shifted : & 'static [u8] = &
            [0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter())
            .map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule
            as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![152]; __reduce_map
            .extend(__rustylr_tset10.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [152,]; let shifted : & 'static [u8] = & [1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![127]; __reduce_map.extend(__rustylr_tset4.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [127,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![155]; __reduce_map.extend(__rustylr_tset6.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [155,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![156]; __reduce_map.extend(__rustylr_tset6.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [156,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![157]; __reduce_map.extend(__rustylr_tset6.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [157,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![158]; __reduce_map.extend(__rustylr_tset6.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [158,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![159]; __reduce_map.extend(__rustylr_tset6.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [159,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![143]; __reduce_map.extend(__rustylr_tset6.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [143,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![144]; __reduce_map.extend(__rustylr_tset6.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [144,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![145]; __reduce_map.extend(__rustylr_tset6.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [145,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![146]; __reduce_map.extend(__rustylr_tset6.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [146,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![147]; __reduce_map.extend(__rustylr_tset6.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [147,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![148]; __reduce_map.extend(__rustylr_tset6.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [148,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![149]; __reduce_map.extend(__rustylr_tset6.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [149,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![150]; __reduce_map.extend(__rustylr_tset6.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [150,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![151]; __reduce_map.extend(__rustylr_tset6.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [151,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![170]; __reduce_map.extend(__rustylr_tset11.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [170,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![171]; __reduce_map.extend(__rustylr_tset11.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [171,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(33, true)),],
            shift_goto_map_nonterm :
            vec![(translation_unitNonTerminals::_identQuestion67,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![206]; __reduce_map.extend(__rustylr_tset12.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [177, 178, 205, 206,]; let shifted : & 'static
            [u8] = & [1, 1, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![178]; __reduce_map
            .extend(__rustylr_tset6.iter().map(| term | (* term, reduce_rules.clone())));
            let reduce_rules = vec![205]; __reduce_map.extend(__rustylr_tset12.iter()
            .map(| term | (* term, reduce_rules.clone()))); __reduce_map.into_iter()
            .collect() }, ruleset : { let rules : & 'static [u8] = & [178, 205,]; let
            shifted : & 'static [u8] = & [2, 1,]; rules.iter().zip(shifted.iter()).map(|
            (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::lbrace,
            ::rusty_lr::parser::state::ShiftTarget::new(35, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [177,]; let shifted : & 'static
            [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::enumerator_list,
            ::rusty_lr::parser::state::ShiftTarget::new(70, true)),
            (translation_unitNonTerminals::enumerator,
            ::rusty_lr::parser::state::ShiftTarget::new(74, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [177,
            179, 180, 181, 182,]; let shifted : & 'static [u8] = & [3, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::assign,
            ::rusty_lr::parser::state::ShiftTarget::new(37, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![181]; __reduce_map
            .extend(__rustylr_tset13.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [181, 182,]; let shifted : & 'static [u8] = & [1, 1,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(243, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 182,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![7]; __reduce_map.extend(__rustylr_tset14.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [7,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),
            (translation_unitTerminalClasses::const_,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)),
            (translation_unitTerminalClasses::volatile,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (translation_unitTerminalClasses::void_,
            ::rusty_lr::parser::state::ShiftTarget::new(21, true)),
            (translation_unitTerminalClasses::char_,
            ::rusty_lr::parser::state::ShiftTarget::new(22, true)),
            (translation_unitTerminalClasses::short_,
            ::rusty_lr::parser::state::ShiftTarget::new(23, true)),
            (translation_unitTerminalClasses::int_,
            ::rusty_lr::parser::state::ShiftTarget::new(24, true)),
            (translation_unitTerminalClasses::long_,
            ::rusty_lr::parser::state::ShiftTarget::new(25, true)),
            (translation_unitTerminalClasses::float_,
            ::rusty_lr::parser::state::ShiftTarget::new(26, true)),
            (translation_unitTerminalClasses::double_,
            ::rusty_lr::parser::state::ShiftTarget::new(27, true)),
            (translation_unitTerminalClasses::signed,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),
            (translation_unitTerminalClasses::unsigned,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (translation_unitTerminalClasses::struct_,
            ::rusty_lr::parser::state::ShiftTarget::new(30, true)),
            (translation_unitTerminalClasses::union_,
            ::rusty_lr::parser::state::ShiftTarget::new(31, true)),
            (translation_unitTerminalClasses::enum_,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(114, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(114, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(114, true)),
            (translation_unitNonTerminals::type_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(118, true)),
            (translation_unitNonTerminals::specifier_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(119, true)),
            (translation_unitNonTerminals::type_name,
            ::rusty_lr::parser::state::ShiftTarget::new(120, true)),
            (translation_unitNonTerminals::type_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(122, true)),
            (translation_unitNonTerminals::struct_or_union,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (translation_unitNonTerminals::struct_or_union_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(128, true)),
            (translation_unitNonTerminals::enum_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(129, true)),
            (translation_unitNonTerminals::_specifier_qualifierPlus65,
            ::rusty_lr::parser::state::ShiftTarget::new(152, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23,
            24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 33, 34, 35, 36, 37, 38, 39, 40, 41,
            42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
            61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 118, 119,
            140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154,
            170, 171, 175, 176, 177, 178, 201, 202,]; let shifted : & 'static [u8] = &
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![7]; __reduce_map.extend(__rustylr_tset15.iter().map(| term | (* term,
            reduce_rules.clone()))); let reduce_rules = vec![7, 152]; __reduce_map
            .extend(__rustylr_tset16.iter().map(| term | (* term, reduce_rules
            .clone()))); let reduce_rules = vec![152]; __reduce_map
            .extend(__rustylr_tset17.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [7, 152,]; let shifted : & 'static [u8] = & [1, 1,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![9]; __reduce_map.extend(__rustylr_tset14.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [9,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![0]; __reduce_map.extend(__rustylr_tset14.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [0,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![1]; __reduce_map.extend(__rustylr_tset14.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [1,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![2]; __reduce_map.extend(__rustylr_tset14.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [2,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![3]; __reduce_map.extend(__rustylr_tset14.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [3,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![4]; __reduce_map.extend(__rustylr_tset14.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [4,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![5]; __reduce_map.extend(__rustylr_tset14.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [5,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![6]; __reduce_map.extend(__rustylr_tset14.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [6,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(187, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 22, 23,
            24, 25, 26, 27, 28, 29, 30, 31,]; let shifted : & 'static [u8] = & [0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
            0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(114, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(114, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(114, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23,
            24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
            43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
            62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,]; let shifted
            : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(186, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 23,
            24, 25, 26, 27, 28, 29, 30, 31,]; let shifted : & 'static [u8] = & [0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
            0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(53, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(185, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 30, 31, 31,]; let shifted : & 'static [u8] = & [0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 1, 0, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),
            (translation_unitTerminalClasses::const_,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)),
            (translation_unitTerminalClasses::volatile,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (translation_unitTerminalClasses::void_,
            ::rusty_lr::parser::state::ShiftTarget::new(21, true)),
            (translation_unitTerminalClasses::char_,
            ::rusty_lr::parser::state::ShiftTarget::new(22, true)),
            (translation_unitTerminalClasses::short_,
            ::rusty_lr::parser::state::ShiftTarget::new(23, true)),
            (translation_unitTerminalClasses::int_,
            ::rusty_lr::parser::state::ShiftTarget::new(24, true)),
            (translation_unitTerminalClasses::long_,
            ::rusty_lr::parser::state::ShiftTarget::new(25, true)),
            (translation_unitTerminalClasses::float_,
            ::rusty_lr::parser::state::ShiftTarget::new(26, true)),
            (translation_unitTerminalClasses::double_,
            ::rusty_lr::parser::state::ShiftTarget::new(27, true)),
            (translation_unitTerminalClasses::signed,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),
            (translation_unitTerminalClasses::unsigned,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (translation_unitTerminalClasses::struct_,
            ::rusty_lr::parser::state::ShiftTarget::new(30, true)),
            (translation_unitTerminalClasses::union_,
            ::rusty_lr::parser::state::ShiftTarget::new(31, true)),
            (translation_unitTerminalClasses::enum_,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(114, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(114, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(114, true)),
            (translation_unitNonTerminals::type_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(118, true)),
            (translation_unitNonTerminals::specifier_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(119, true)),
            (translation_unitNonTerminals::type_name,
            ::rusty_lr::parser::state::ShiftTarget::new(150, true)),
            (translation_unitNonTerminals::type_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(122, true)),
            (translation_unitNonTerminals::struct_or_union,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (translation_unitNonTerminals::struct_or_union_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(128, true)),
            (translation_unitNonTerminals::enum_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(129, true)),
            (translation_unitNonTerminals::_specifier_qualifierPlus65,
            ::rusty_lr::parser::state::ShiftTarget::new(152, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23,
            24, 25, 26, 27, 28, 29, 30, 31, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
            42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
            61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 118, 119,
            140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154,
            170, 171, 175, 176, 177, 178, 201, 202,]; let shifted : & 'static [u8] = &
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(184, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(184, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            24, 25, 26, 27, 28, 29, 30, 31, 32, 33,]; let shifted : & 'static [u8] = &
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
            0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(182, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(182, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 29, 30, 31, 32, 33,]; let shifted : & 'static [u8] = &
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 1, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(181, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(181, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 28, 29, 30, 31, 32, 33,]; let shifted : & 'static [u8] = &
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 1, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(180, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(180, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 27, 28, 29, 30, 31, 32, 33,]; let shifted : & 'static [u8] = &
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 1, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(179, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(179, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 26, 27, 28, 29, 30, 31, 32, 33,]; let shifted : & 'static [u8] = &
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(178, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(178, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 25, 26, 27, 28, 29, 30, 31, 32, 33,]; let shifted : & 'static [u8] = &
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(61, true)),
            (translation_unitTerminalClasses::lbracket,
            ::rusty_lr::parser::state::ShiftTarget::new(165, true)),
            (translation_unitTerminalClasses::dot,
            ::rusty_lr::parser::state::ShiftTarget::new(172, true)),
            (translation_unitTerminalClasses::ptr_op,
            ::rusty_lr::parser::state::ShiftTarget::new(174, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(176, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(177, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![21]; __reduce_map
            .extend(__rustylr_tset18.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [12, 13, 14, 15, 16, 17, 18, 21,]; let shifted : & 'static
            [u8] = & [1, 1, 1, 1, 1, 1, 1, 1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::rparen,
            ::rusty_lr::parser::state::ShiftTarget::new(62, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::argument_expression_list,
            ::rusty_lr::parser::state::ShiftTarget::new(63, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(164, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(164, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 13, 14, 14, 15, 16, 17, 18, 19, 20,
            21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
            40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58,
            59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,]; let
            shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0,
            2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![13]; __reduce_map
            .extend(__rustylr_tset14.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [13,]; let shifted : & 'static [u8] = & [3,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::rparen,
            ::rusty_lr::parser::state::ShiftTarget::new(64, true)),
            (translation_unitTerminalClasses::comma,
            ::rusty_lr::parser::state::ShiftTarget::new(65, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [14, 20,]; let shifted : & 'static
            [u8] = & [3, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted)
            | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![14]; __reduce_map
            .extend(__rustylr_tset14.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [14,]; let shifted : & 'static [u8] = & [4,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(242, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(242, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 20, 21, 22, 23,
            24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
            43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
            62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::assign,
            ::rusty_lr::parser::state::ShiftTarget::new(67, true)),
            (translation_unitTerminalClasses::mul_assign,
            ::rusty_lr::parser::state::ShiftTarget::new(194, true)),
            (translation_unitTerminalClasses::div_assign,
            ::rusty_lr::parser::state::ShiftTarget::new(196, true)),
            (translation_unitTerminalClasses::mod_assign,
            ::rusty_lr::parser::state::ShiftTarget::new(198, true)),
            (translation_unitTerminalClasses::add_assign,
            ::rusty_lr::parser::state::ShiftTarget::new(200, true)),
            (translation_unitTerminalClasses::sub_assign,
            ::rusty_lr::parser::state::ShiftTarget::new(202, true)),
            (translation_unitTerminalClasses::left_assign,
            ::rusty_lr::parser::state::ShiftTarget::new(204, true)),
            (translation_unitTerminalClasses::right_assign,
            ::rusty_lr::parser::state::ShiftTarget::new(206, true)),
            (translation_unitTerminalClasses::and_assign,
            ::rusty_lr::parser::state::ShiftTarget::new(208, true)),
            (translation_unitTerminalClasses::xor_assign,
            ::rusty_lr::parser::state::ShiftTarget::new(210, true)),
            (translation_unitTerminalClasses::or_assign,
            ::rusty_lr::parser::state::ShiftTarget::new(212, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![32]; __reduce_map
            .extend(__rustylr_tset19.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [32, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,]; let
            shifted : & 'static [u8] = & [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(193, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(193, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(69, true)),
            (translation_unitTerminalClasses::slash,
            ::rusty_lr::parser::state::ShiftTarget::new(90, true)),
            (translation_unitTerminalClasses::percent,
            ::rusty_lr::parser::state::ShiftTarget::new(92, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![38]; __reduce_map
            .extend(__rustylr_tset20.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [35, 36, 37, 38,]; let shifted : & 'static [u8] = & [1, 1,
            1, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(166, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(166, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 35,]; let shifted : & 'static [u8] = &
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::rbrace,
            ::rusty_lr::parser::state::ShiftTarget::new(71, true)),
            (translation_unitTerminalClasses::comma,
            ::rusty_lr::parser::state::ShiftTarget::new(72, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [177, 180,]; let shifted : &
            'static [u8] = & [4, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![177]; __reduce_map
            .extend(__rustylr_tset6.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, ruleset : { let rules : & 'static [u8]
            = & [177,]; let shifted : & 'static [u8] = & [5,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::enumerator,
            ::rusty_lr::parser::state::ShiftTarget::new(73, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [180,
            181, 182,]; let shifted : & 'static [u8] = & [2, 0, 0,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![180]; __reduce_map.extend(__rustylr_tset13.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [180,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![179]; __reduce_map.extend(__rustylr_tset13.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [179,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(76, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(88, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![41]; __reduce_map
            .extend(__rustylr_tset21.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [39, 40, 41,]; let shifted : & 'static [u8] = & [1, 1, 1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(167, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(167, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(167, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 40,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::left_op,
            ::rusty_lr::parser::state::ShiftTarget::new(78, true)),
            (translation_unitTerminalClasses::right_op,
            ::rusty_lr::parser::state::ShiftTarget::new(86, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![44]; __reduce_map
            .extend(__rustylr_tset22.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [42, 43, 44,]; let shifted : & 'static [u8] = & [1, 1, 1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(168, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 42,]; let
            shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::less,
            ::rusty_lr::parser::state::ShiftTarget::new(80, true)),
            (translation_unitTerminalClasses::greater,
            ::rusty_lr::parser::state::ShiftTarget::new(84, true)),
            (translation_unitTerminalClasses::le,
            ::rusty_lr::parser::state::ShiftTarget::new(94, true)),
            (translation_unitTerminalClasses::ge,
            ::rusty_lr::parser::state::ShiftTarget::new(96, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![49]; __reduce_map
            .extend(__rustylr_tset23.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [45, 46, 47, 48, 49,]; let shifted : & 'static [u8] = & [1,
            1, 1, 1, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(169, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            45,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) |
            { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted
            as usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::eq,
            ::rusty_lr::parser::state::ShiftTarget::new(82, true)),
            (translation_unitTerminalClasses::ne,
            ::rusty_lr::parser::state::ShiftTarget::new(98, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![52]; __reduce_map
            .extend(__rustylr_tset24.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [50, 51, 52,]; let shifted : & 'static [u8] = & [1, 1, 1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(83, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 50,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::less,
            ::rusty_lr::parser::state::ShiftTarget::new(80, true)),
            (translation_unitTerminalClasses::greater,
            ::rusty_lr::parser::state::ShiftTarget::new(84, true)),
            (translation_unitTerminalClasses::le,
            ::rusty_lr::parser::state::ShiftTarget::new(94, true)),
            (translation_unitTerminalClasses::ge,
            ::rusty_lr::parser::state::ShiftTarget::new(96, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![50]; __reduce_map
            .extend(__rustylr_tset23.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [45, 46, 47, 48, 50,]; let shifted : & 'static [u8] = & [1,
            1, 1, 1, 3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(85, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            46,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) |
            { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted
            as usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::left_op,
            ::rusty_lr::parser::state::ShiftTarget::new(78, true)),
            (translation_unitTerminalClasses::right_op,
            ::rusty_lr::parser::state::ShiftTarget::new(86, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![46]; __reduce_map
            .extend(__rustylr_tset22.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [42, 43, 46,]; let shifted : & 'static [u8] = & [1, 1, 3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(87, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 43,]; let
            shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(76, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(88, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![43]; __reduce_map
            .extend(__rustylr_tset21.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [39, 40, 43,]; let shifted : & 'static [u8] = & [1, 1, 3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(89, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(89, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(89, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 39,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(69, true)),
            (translation_unitTerminalClasses::slash,
            ::rusty_lr::parser::state::ShiftTarget::new(90, true)),
            (translation_unitTerminalClasses::percent,
            ::rusty_lr::parser::state::ShiftTarget::new(92, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![39]; __reduce_map
            .extend(__rustylr_tset20.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [35, 36, 37, 39,]; let shifted : & 'static [u8] = & [1, 1,
            1, 3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(91, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(91, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 36,]; let shifted : & 'static [u8] = &
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![36]; __reduce_map
            .extend(__rustylr_tset19.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [36,]; let shifted : & 'static [u8] = & [3,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(93, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(93, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 37,]; let shifted : & 'static [u8] = &
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![37]; __reduce_map
            .extend(__rustylr_tset19.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [37,]; let shifted : & 'static [u8] = & [3,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(95, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            47,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) |
            { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted
            as usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::left_op,
            ::rusty_lr::parser::state::ShiftTarget::new(78, true)),
            (translation_unitTerminalClasses::right_op,
            ::rusty_lr::parser::state::ShiftTarget::new(86, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![47]; __reduce_map
            .extend(__rustylr_tset22.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [42, 43, 47,]; let shifted : & 'static [u8] = & [1, 1, 3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(97, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            48,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) |
            { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted
            as usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::left_op,
            ::rusty_lr::parser::state::ShiftTarget::new(78, true)),
            (translation_unitTerminalClasses::right_op,
            ::rusty_lr::parser::state::ShiftTarget::new(86, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![48]; __reduce_map
            .extend(__rustylr_tset22.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [42, 43, 48,]; let shifted : & 'static [u8] = & [1, 1, 3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(99, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 51,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::less,
            ::rusty_lr::parser::state::ShiftTarget::new(80, true)),
            (translation_unitTerminalClasses::greater,
            ::rusty_lr::parser::state::ShiftTarget::new(84, true)),
            (translation_unitTerminalClasses::le,
            ::rusty_lr::parser::state::ShiftTarget::new(94, true)),
            (translation_unitTerminalClasses::ge,
            ::rusty_lr::parser::state::ShiftTarget::new(96, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![51]; __reduce_map
            .extend(__rustylr_tset23.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [45, 46, 47, 48, 51,]; let shifted : & 'static [u8] = & [1,
            1, 1, 1, 3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(101, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![54]; __reduce_map
            .extend(__rustylr_tset25.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [53, 54,]; let shifted : & 'static [u8] = & [1, 1,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(102, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 53,]; let shifted : & 'static [u8] = & [0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::eq,
            ::rusty_lr::parser::state::ShiftTarget::new(82, true)),
            (translation_unitTerminalClasses::ne,
            ::rusty_lr::parser::state::ShiftTarget::new(98, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![53]; __reduce_map
            .extend(__rustylr_tset24.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [50, 51, 53,]; let shifted : & 'static [u8] = & [1, 1, 3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::caret,
            ::rusty_lr::parser::state::ShiftTarget::new(104, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![56]; __reduce_map
            .extend(__rustylr_tset26.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [55, 56,]; let shifted : & 'static [u8] = & [1, 1,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(105, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 55,]; let shifted : & 'static [u8] =
            & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(101, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![55]; __reduce_map
            .extend(__rustylr_tset25.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [53, 55,]; let shifted : & 'static [u8] = & [1, 3,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::pipe,
            ::rusty_lr::parser::state::ShiftTarget::new(107, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![58]; __reduce_map
            .extend(__rustylr_tset27.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [57, 58,]; let shifted : & 'static [u8] = & [1, 1,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(108, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 57,]; let shifted : & 'static
            [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::caret,
            ::rusty_lr::parser::state::ShiftTarget::new(104, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![57]; __reduce_map
            .extend(__rustylr_tset26.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [55, 57,]; let shifted : & 'static [u8] = & [1, 3,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::and_op,
            ::rusty_lr::parser::state::ShiftTarget::new(110, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![60]; __reduce_map
            .extend(__rustylr_tset28.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [59, 60,]; let shifted : & 'static [u8] = & [1, 1,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(111, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 59,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::pipe,
            ::rusty_lr::parser::state::ShiftTarget::new(107, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![59]; __reduce_map
            .extend(__rustylr_tset27.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [57, 59,]; let shifted : & 'static [u8] = & [1, 3,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::question,
            ::rusty_lr::parser::state::ShiftTarget::new(113, true)),
            (translation_unitTerminalClasses::or_op,
            ::rusty_lr::parser::state::ShiftTarget::new(191, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![62]; __reduce_map
            .extend(__rustylr_tset29.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [61, 62, 63,]; let shifted : & 'static [u8] = & [1, 1, 1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(188, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(188, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(188, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,]; let shifted
            : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::rparen,
            ::rusty_lr::parser::state::ShiftTarget::new(115, true)),
            (translation_unitTerminalClasses::comma,
            ::rusty_lr::parser::state::ShiftTarget::new(116, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [10, 77,]; let shifted : & 'static
            [u8] = & [2, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted)
            | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![10]; __reduce_map
            .extend(__rustylr_tset14.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [10,]; let shifted : & 'static [u8] = & [3,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(117, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(117, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 77,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![77]; __reduce_map.extend(__rustylr_tset30.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [77,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![140]; __reduce_map.extend(__rustylr_tset31.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [140,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![201]; __reduce_map.extend(__rustylr_tset31.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [201,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::rparen,
            ::rusty_lr::parser::state::ShiftTarget::new(121, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [33,]; let shifted : & 'static
            [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(183, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(183, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 33,]; let shifted : & 'static [u8] = &
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 3,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![141]; __reduce_map
            .extend(__rustylr_tset31.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [141,]; let shifted : & 'static [u8] = & [1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(124, true)),],
            shift_goto_map_nonterm :
            vec![(translation_unitNonTerminals::_identQuestion67,
            ::rusty_lr::parser::state::ShiftTarget::new(125, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![206]; __reduce_map.extend(__rustylr_tset12.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [175, 176, 205, 206,]; let shifted : & 'static
            [u8] = & [1, 1, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![176]; __reduce_map
            .extend(__rustylr_tset6.iter().map(| term | (* term, reduce_rules.clone())));
            let reduce_rules = vec![205]; __reduce_map.extend(__rustylr_tset12.iter()
            .map(| term | (* term, reduce_rules.clone()))); __reduce_map.into_iter()
            .collect() }, ruleset : { let rules : & 'static [u8] = & [176, 205,]; let
            shifted : & 'static [u8] = & [2, 1,]; rules.iter().zip(shifted.iter()).map(|
            (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::lbrace,
            ::rusty_lr::parser::state::ShiftTarget::new(126, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [175,]; let shifted : & 'static
            [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)),
            (translation_unitTerminalClasses::const_,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)),
            (translation_unitTerminalClasses::volatile,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (translation_unitTerminalClasses::void_,
            ::rusty_lr::parser::state::ShiftTarget::new(21, true)),
            (translation_unitTerminalClasses::char_,
            ::rusty_lr::parser::state::ShiftTarget::new(22, true)),
            (translation_unitTerminalClasses::short_,
            ::rusty_lr::parser::state::ShiftTarget::new(23, true)),
            (translation_unitTerminalClasses::int_,
            ::rusty_lr::parser::state::ShiftTarget::new(24, true)),
            (translation_unitTerminalClasses::long_,
            ::rusty_lr::parser::state::ShiftTarget::new(25, true)),
            (translation_unitTerminalClasses::float_,
            ::rusty_lr::parser::state::ShiftTarget::new(26, true)),
            (translation_unitTerminalClasses::double_,
            ::rusty_lr::parser::state::ShiftTarget::new(27, true)),
            (translation_unitTerminalClasses::signed,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),
            (translation_unitTerminalClasses::unsigned,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (translation_unitTerminalClasses::struct_,
            ::rusty_lr::parser::state::ShiftTarget::new(30, true)),
            (translation_unitTerminalClasses::union_,
            ::rusty_lr::parser::state::ShiftTarget::new(31, true)),
            (translation_unitTerminalClasses::enum_,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::type_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(118, true)),
            (translation_unitNonTerminals::specifier_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(119, true)),
            (translation_unitNonTerminals::type_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(122, true)),
            (translation_unitNonTerminals::struct_or_union,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (translation_unitNonTerminals::struct_declaration,
            ::rusty_lr::parser::state::ShiftTarget::new(127, true)),
            (translation_unitNonTerminals::struct_or_union_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(128, true)),
            (translation_unitNonTerminals::enum_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(129, true)),
            (translation_unitNonTerminals::_specifier_qualifierPlus65,
            ::rusty_lr::parser::state::ShiftTarget::new(130, true)),
            (translation_unitNonTerminals::_struct_declarationPlus68,
            ::rusty_lr::parser::state::ShiftTarget::new(142, true)),
            (translation_unitNonTerminals::_struct_declarationStar69,
            ::rusty_lr::parser::state::ShiftTarget::new(144, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![210]; __reduce_map.extend(__rustylr_tset32.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [118, 119, 140, 141, 143, 144, 145, 146, 147,
            148, 149, 150, 151, 152, 153, 154, 170, 171, 174, 175, 175, 176, 177, 178,
            201, 202, 207, 208, 209, 210,]; let shifted : & 'static [u8] = & [0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0,
            0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![207]; __reduce_map.extend(__rustylr_tset33.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [207,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![153]; __reduce_map.extend(__rustylr_tset6.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [153,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![154]; __reduce_map.extend(__rustylr_tset6.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [154,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)),
            (translation_unitTerminalClasses::const_,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)),
            (translation_unitTerminalClasses::volatile,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (translation_unitTerminalClasses::void_,
            ::rusty_lr::parser::state::ShiftTarget::new(21, true)),
            (translation_unitTerminalClasses::char_,
            ::rusty_lr::parser::state::ShiftTarget::new(22, true)),
            (translation_unitTerminalClasses::short_,
            ::rusty_lr::parser::state::ShiftTarget::new(23, true)),
            (translation_unitTerminalClasses::int_,
            ::rusty_lr::parser::state::ShiftTarget::new(24, true)),
            (translation_unitTerminalClasses::long_,
            ::rusty_lr::parser::state::ShiftTarget::new(25, true)),
            (translation_unitTerminalClasses::float_,
            ::rusty_lr::parser::state::ShiftTarget::new(26, true)),
            (translation_unitTerminalClasses::double_,
            ::rusty_lr::parser::state::ShiftTarget::new(27, true)),
            (translation_unitTerminalClasses::signed,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),
            (translation_unitTerminalClasses::unsigned,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (translation_unitTerminalClasses::struct_,
            ::rusty_lr::parser::state::ShiftTarget::new(30, true)),
            (translation_unitTerminalClasses::union_,
            ::rusty_lr::parser::state::ShiftTarget::new(31, true)),
            (translation_unitTerminalClasses::enum_,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::type_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(118, true)),
            (translation_unitNonTerminals::declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(237, true)),
            (translation_unitNonTerminals::direct_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(12, true)),
            (translation_unitNonTerminals::specifier_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(221, true)),
            (translation_unitNonTerminals::type_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(122, true)),
            (translation_unitNonTerminals::struct_or_union,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (translation_unitNonTerminals::struct_declarator_list,
            ::rusty_lr::parser::state::ShiftTarget::new(238, true)),
            (translation_unitNonTerminals::struct_or_union_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(128, true)),
            (translation_unitNonTerminals::enum_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(129, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [118,
            119, 120, 121, 122, 123, 124, 125, 126, 127, 140, 141, 143, 144, 145, 146,
            147, 148, 149, 150, 151, 152, 153, 154, 170, 171, 172, 173, 174, 175, 176,
            177, 178, 202,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::rparen,
            ::rusty_lr::parser::state::ShiftTarget::new(132, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [123,]; let shifted : & 'static
            [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![123]; __reduce_map.extend(__rustylr_tset4.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [123,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![162]; __reduce_map.extend(__rustylr_tset6.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [162,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![161]; __reduce_map.extend(__rustylr_tset6.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [161,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![160]; __reduce_map.extend(__rustylr_tset6.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [160,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![191]; __reduce_map.extend(__rustylr_tset6.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [191,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![166]; __reduce_map.extend(__rustylr_tset34.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [166,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::comma,
            ::rusty_lr::parser::state::ShiftTarget::new(139, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![168]; __reduce_map
            .extend(__rustylr_tset35.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [167, 168, 169,]; let shifted : & 'static [u8] = & [1, 1,
            1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)),
            (translation_unitTerminalClasses::ellipsis,
            ::rusty_lr::parser::state::ShiftTarget::new(140, true)),
            (translation_unitTerminalClasses::typedef,
            ::rusty_lr::parser::state::ShiftTarget::new(16, true)),
            (translation_unitTerminalClasses::extern_,
            ::rusty_lr::parser::state::ShiftTarget::new(17, true)),
            (translation_unitTerminalClasses::static_,
            ::rusty_lr::parser::state::ShiftTarget::new(18, true)),
            (translation_unitTerminalClasses::auto,
            ::rusty_lr::parser::state::ShiftTarget::new(19, true)),
            (translation_unitTerminalClasses::register,
            ::rusty_lr::parser::state::ShiftTarget::new(20, true)),
            (translation_unitTerminalClasses::const_,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)),
            (translation_unitTerminalClasses::volatile,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (translation_unitTerminalClasses::void_,
            ::rusty_lr::parser::state::ShiftTarget::new(21, true)),
            (translation_unitTerminalClasses::char_,
            ::rusty_lr::parser::state::ShiftTarget::new(22, true)),
            (translation_unitTerminalClasses::short_,
            ::rusty_lr::parser::state::ShiftTarget::new(23, true)),
            (translation_unitTerminalClasses::int_,
            ::rusty_lr::parser::state::ShiftTarget::new(24, true)),
            (translation_unitTerminalClasses::long_,
            ::rusty_lr::parser::state::ShiftTarget::new(25, true)),
            (translation_unitTerminalClasses::float_,
            ::rusty_lr::parser::state::ShiftTarget::new(26, true)),
            (translation_unitTerminalClasses::double_,
            ::rusty_lr::parser::state::ShiftTarget::new(27, true)),
            (translation_unitTerminalClasses::signed,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),
            (translation_unitTerminalClasses::unsigned,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (translation_unitTerminalClasses::struct_,
            ::rusty_lr::parser::state::ShiftTarget::new(30, true)),
            (translation_unitTerminalClasses::union_,
            ::rusty_lr::parser::state::ShiftTarget::new(31, true)),
            (translation_unitTerminalClasses::enum_,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::type_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(133, true)),
            (translation_unitNonTerminals::type_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(134, true)),
            (translation_unitNonTerminals::storage_class_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(135, true)),
            (translation_unitNonTerminals::declaration_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(136, true)),
            (translation_unitNonTerminals::parameter_declaration,
            ::rusty_lr::parser::state::ShiftTarget::new(141, true)),
            (translation_unitNonTerminals::struct_or_union,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (translation_unitNonTerminals::struct_or_union_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(128, true)),
            (translation_unitNonTerminals::enum_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(129, true)),
            (translation_unitNonTerminals::_declaration_specifierPlus60,
            ::rusty_lr::parser::state::ShiftTarget::new(146, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [118,
            119, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156,
            157, 158, 159, 160, 161, 162, 163, 164, 165, 167, 169, 170, 171, 175, 176,
            177, 178, 191, 192,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0,
            0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![169]; __reduce_map.extend(__rustylr_tset35.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [169,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![167]; __reduce_map.extend(__rustylr_tset34.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [167,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)),
            (translation_unitTerminalClasses::const_,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)),
            (translation_unitTerminalClasses::volatile,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (translation_unitTerminalClasses::void_,
            ::rusty_lr::parser::state::ShiftTarget::new(21, true)),
            (translation_unitTerminalClasses::char_,
            ::rusty_lr::parser::state::ShiftTarget::new(22, true)),
            (translation_unitTerminalClasses::short_,
            ::rusty_lr::parser::state::ShiftTarget::new(23, true)),
            (translation_unitTerminalClasses::int_,
            ::rusty_lr::parser::state::ShiftTarget::new(24, true)),
            (translation_unitTerminalClasses::long_,
            ::rusty_lr::parser::state::ShiftTarget::new(25, true)),
            (translation_unitTerminalClasses::float_,
            ::rusty_lr::parser::state::ShiftTarget::new(26, true)),
            (translation_unitTerminalClasses::double_,
            ::rusty_lr::parser::state::ShiftTarget::new(27, true)),
            (translation_unitTerminalClasses::signed,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),
            (translation_unitTerminalClasses::unsigned,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (translation_unitTerminalClasses::struct_,
            ::rusty_lr::parser::state::ShiftTarget::new(30, true)),
            (translation_unitTerminalClasses::union_,
            ::rusty_lr::parser::state::ShiftTarget::new(31, true)),
            (translation_unitTerminalClasses::enum_,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::type_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(118, true)),
            (translation_unitNonTerminals::specifier_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(119, true)),
            (translation_unitNonTerminals::type_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(122, true)),
            (translation_unitNonTerminals::struct_or_union,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (translation_unitNonTerminals::struct_declaration,
            ::rusty_lr::parser::state::ShiftTarget::new(143, true)),
            (translation_unitNonTerminals::struct_or_union_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(128, true)),
            (translation_unitNonTerminals::enum_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(129, true)),
            (translation_unitNonTerminals::_specifier_qualifierPlus65,
            ::rusty_lr::parser::state::ShiftTarget::new(130, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![209]; __reduce_map.extend(__rustylr_tset32.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [118, 119, 140, 141, 143, 144, 145, 146, 147,
            148, 149, 150, 151, 152, 153, 154, 170, 171, 174, 175, 176, 177, 178, 201,
            202, 208, 209,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![208]; __reduce_map.extend(__rustylr_tset33.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [208,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::rbrace,
            ::rusty_lr::parser::state::ShiftTarget::new(145, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [175,]; let shifted : & 'static
            [u8] = & [4,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![175]; __reduce_map.extend(__rustylr_tset6.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [175,]; let shifted : & 'static [u8] = & [5,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(147, true)),
            (translation_unitTerminalClasses::lbracket,
            ::rusty_lr::parser::state::ShiftTarget::new(149, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(226, true)),
            (translation_unitTerminalClasses::typedef,
            ::rusty_lr::parser::state::ShiftTarget::new(16, true)),
            (translation_unitTerminalClasses::extern_,
            ::rusty_lr::parser::state::ShiftTarget::new(17, true)),
            (translation_unitTerminalClasses::static_,
            ::rusty_lr::parser::state::ShiftTarget::new(18, true)),
            (translation_unitTerminalClasses::auto,
            ::rusty_lr::parser::state::ShiftTarget::new(19, true)),
            (translation_unitTerminalClasses::register,
            ::rusty_lr::parser::state::ShiftTarget::new(20, true)),
            (translation_unitTerminalClasses::const_,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)),
            (translation_unitTerminalClasses::volatile,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (translation_unitTerminalClasses::void_,
            ::rusty_lr::parser::state::ShiftTarget::new(21, true)),
            (translation_unitTerminalClasses::char_,
            ::rusty_lr::parser::state::ShiftTarget::new(22, true)),
            (translation_unitTerminalClasses::short_,
            ::rusty_lr::parser::state::ShiftTarget::new(23, true)),
            (translation_unitTerminalClasses::int_,
            ::rusty_lr::parser::state::ShiftTarget::new(24, true)),
            (translation_unitTerminalClasses::long_,
            ::rusty_lr::parser::state::ShiftTarget::new(25, true)),
            (translation_unitTerminalClasses::float_,
            ::rusty_lr::parser::state::ShiftTarget::new(26, true)),
            (translation_unitTerminalClasses::double_,
            ::rusty_lr::parser::state::ShiftTarget::new(27, true)),
            (translation_unitTerminalClasses::signed,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),
            (translation_unitTerminalClasses::unsigned,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (translation_unitTerminalClasses::struct_,
            ::rusty_lr::parser::state::ShiftTarget::new(30, true)),
            (translation_unitTerminalClasses::union_,
            ::rusty_lr::parser::state::ShiftTarget::new(31, true)),
            (translation_unitTerminalClasses::enum_,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::type_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(133, true)),
            (translation_unitNonTerminals::declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(234, true)),
            (translation_unitNonTerminals::direct_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(12, true)),
            (translation_unitNonTerminals::abstract_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(235, true)),
            (translation_unitNonTerminals::direct_abstract_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(157, true)),
            (translation_unitNonTerminals::type_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(134, true)),
            (translation_unitNonTerminals::storage_class_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(135, true)),
            (translation_unitNonTerminals::declaration_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(236, true)),
            (translation_unitNonTerminals::struct_or_union,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (translation_unitNonTerminals::struct_or_union_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(128, true)),
            (translation_unitNonTerminals::enum_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(129, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![165]; __reduce_map.extend(__rustylr_tset34.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [118, 119, 120, 121, 122, 123, 124, 125, 126,
            127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 143, 144,
            145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
            160, 161, 162, 163, 164, 165, 170, 171, 175, 176, 177, 178, 192,]; let
            shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 1, 1, 0, 0, 0, 0, 0, 0, 1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(147, true)),
            (translation_unitTerminalClasses::rparen,
            ::rusty_lr::parser::state::ShiftTarget::new(148, true)),
            (translation_unitTerminalClasses::lbracket,
            ::rusty_lr::parser::state::ShiftTarget::new(149, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(226, true)),
            (translation_unitTerminalClasses::typedef,
            ::rusty_lr::parser::state::ShiftTarget::new(16, true)),
            (translation_unitTerminalClasses::extern_,
            ::rusty_lr::parser::state::ShiftTarget::new(17, true)),
            (translation_unitTerminalClasses::static_,
            ::rusty_lr::parser::state::ShiftTarget::new(18, true)),
            (translation_unitTerminalClasses::auto,
            ::rusty_lr::parser::state::ShiftTarget::new(19, true)),
            (translation_unitTerminalClasses::register,
            ::rusty_lr::parser::state::ShiftTarget::new(20, true)),
            (translation_unitTerminalClasses::const_,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)),
            (translation_unitTerminalClasses::volatile,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (translation_unitTerminalClasses::void_,
            ::rusty_lr::parser::state::ShiftTarget::new(21, true)),
            (translation_unitTerminalClasses::char_,
            ::rusty_lr::parser::state::ShiftTarget::new(22, true)),
            (translation_unitTerminalClasses::short_,
            ::rusty_lr::parser::state::ShiftTarget::new(23, true)),
            (translation_unitTerminalClasses::int_,
            ::rusty_lr::parser::state::ShiftTarget::new(24, true)),
            (translation_unitTerminalClasses::long_,
            ::rusty_lr::parser::state::ShiftTarget::new(25, true)),
            (translation_unitTerminalClasses::float_,
            ::rusty_lr::parser::state::ShiftTarget::new(26, true)),
            (translation_unitTerminalClasses::double_,
            ::rusty_lr::parser::state::ShiftTarget::new(27, true)),
            (translation_unitTerminalClasses::signed,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),
            (translation_unitTerminalClasses::unsigned,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (translation_unitTerminalClasses::struct_,
            ::rusty_lr::parser::state::ShiftTarget::new(30, true)),
            (translation_unitTerminalClasses::union_,
            ::rusty_lr::parser::state::ShiftTarget::new(31, true)),
            (translation_unitTerminalClasses::enum_,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::type_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(133, true)),
            (translation_unitNonTerminals::declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(131, true)),
            (translation_unitNonTerminals::direct_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(12, true)),
            (translation_unitNonTerminals::abstract_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(216, true)),
            (translation_unitNonTerminals::direct_abstract_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(157, true)),
            (translation_unitNonTerminals::type_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(134, true)),
            (translation_unitNonTerminals::storage_class_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(135, true)),
            (translation_unitNonTerminals::declaration_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(136, true)),
            (translation_unitNonTerminals::parameter_declaration,
            ::rusty_lr::parser::state::ShiftTarget::new(137, true)),
            (translation_unitNonTerminals::parameter_list,
            ::rusty_lr::parser::state::ShiftTarget::new(138, true)),
            (translation_unitNonTerminals::parameter_type_list,
            ::rusty_lr::parser::state::ShiftTarget::new(218, true)),
            (translation_unitNonTerminals::struct_or_union,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (translation_unitNonTerminals::struct_or_union_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(128, true)),
            (translation_unitNonTerminals::enum_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(129, true)),
            (translation_unitNonTerminals::_declaration_specifierPlus60,
            ::rusty_lr::parser::state::ShiftTarget::new(146, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [118,
            119, 120, 121, 122, 123, 123, 124, 125, 126, 127, 128, 129, 130, 131, 131,
            132, 133, 134, 135, 136, 136, 137, 137, 138, 139, 143, 144, 145, 146, 147,
            148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162,
            163, 164, 165, 166, 167, 168, 169, 170, 171, 175, 176, 177, 178, 191, 192,];
            let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
            0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![136]; __reduce_map.extend(__rustylr_tset36.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [136,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::rbracket,
            ::rusty_lr::parser::state::ShiftTarget::new(223, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(224, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 132, 133,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 1, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::rparen,
            ::rusty_lr::parser::state::ShiftTarget::new(151, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [31,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![31]; __reduce_map.extend(__rustylr_tset18.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [31,]; let shifted : & 'static [u8] = & [4,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(153, true)),
            (translation_unitTerminalClasses::lbracket,
            ::rusty_lr::parser::state::ShiftTarget::new(149, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(154, true)),
            (translation_unitTerminalClasses::const_,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)),
            (translation_unitTerminalClasses::volatile,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (translation_unitTerminalClasses::void_,
            ::rusty_lr::parser::state::ShiftTarget::new(21, true)),
            (translation_unitTerminalClasses::char_,
            ::rusty_lr::parser::state::ShiftTarget::new(22, true)),
            (translation_unitTerminalClasses::short_,
            ::rusty_lr::parser::state::ShiftTarget::new(23, true)),
            (translation_unitTerminalClasses::int_,
            ::rusty_lr::parser::state::ShiftTarget::new(24, true)),
            (translation_unitTerminalClasses::long_,
            ::rusty_lr::parser::state::ShiftTarget::new(25, true)),
            (translation_unitTerminalClasses::float_,
            ::rusty_lr::parser::state::ShiftTarget::new(26, true)),
            (translation_unitTerminalClasses::double_,
            ::rusty_lr::parser::state::ShiftTarget::new(27, true)),
            (translation_unitTerminalClasses::signed,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),
            (translation_unitTerminalClasses::unsigned,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (translation_unitTerminalClasses::struct_,
            ::rusty_lr::parser::state::ShiftTarget::new(30, true)),
            (translation_unitTerminalClasses::union_,
            ::rusty_lr::parser::state::ShiftTarget::new(31, true)),
            (translation_unitTerminalClasses::enum_,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::type_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(118, true)),
            (translation_unitNonTerminals::abstract_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(220, true)),
            (translation_unitNonTerminals::direct_abstract_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(157, true)),
            (translation_unitNonTerminals::specifier_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(221, true)),
            (translation_unitNonTerminals::type_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(122, true)),
            (translation_unitNonTerminals::struct_or_union,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (translation_unitNonTerminals::struct_or_union_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(128, true)),
            (translation_unitNonTerminals::enum_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(129, true)),
            (translation_unitNonTerminals::_abstract_declaratorQuestion66,
            ::rusty_lr::parser::state::ShiftTarget::new(222, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![204]; __reduce_map.extend(__rustylr_tset35.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [118, 119, 128, 129, 130, 131, 132, 133, 134,
            135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,
            150, 151, 152, 153, 154, 170, 171, 175, 176, 177, 178, 202, 203, 204,]; let
            shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(153, true)),
            (translation_unitTerminalClasses::rparen,
            ::rusty_lr::parser::state::ShiftTarget::new(148, true)),
            (translation_unitTerminalClasses::lbracket,
            ::rusty_lr::parser::state::ShiftTarget::new(149, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(154, true)),
            (translation_unitTerminalClasses::typedef,
            ::rusty_lr::parser::state::ShiftTarget::new(16, true)),
            (translation_unitTerminalClasses::extern_,
            ::rusty_lr::parser::state::ShiftTarget::new(17, true)),
            (translation_unitTerminalClasses::static_,
            ::rusty_lr::parser::state::ShiftTarget::new(18, true)),
            (translation_unitTerminalClasses::auto,
            ::rusty_lr::parser::state::ShiftTarget::new(19, true)),
            (translation_unitTerminalClasses::register,
            ::rusty_lr::parser::state::ShiftTarget::new(20, true)),
            (translation_unitTerminalClasses::const_,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)),
            (translation_unitTerminalClasses::volatile,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (translation_unitTerminalClasses::void_,
            ::rusty_lr::parser::state::ShiftTarget::new(21, true)),
            (translation_unitTerminalClasses::char_,
            ::rusty_lr::parser::state::ShiftTarget::new(22, true)),
            (translation_unitTerminalClasses::short_,
            ::rusty_lr::parser::state::ShiftTarget::new(23, true)),
            (translation_unitTerminalClasses::int_,
            ::rusty_lr::parser::state::ShiftTarget::new(24, true)),
            (translation_unitTerminalClasses::long_,
            ::rusty_lr::parser::state::ShiftTarget::new(25, true)),
            (translation_unitTerminalClasses::float_,
            ::rusty_lr::parser::state::ShiftTarget::new(26, true)),
            (translation_unitTerminalClasses::double_,
            ::rusty_lr::parser::state::ShiftTarget::new(27, true)),
            (translation_unitTerminalClasses::signed,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),
            (translation_unitTerminalClasses::unsigned,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (translation_unitTerminalClasses::struct_,
            ::rusty_lr::parser::state::ShiftTarget::new(30, true)),
            (translation_unitTerminalClasses::union_,
            ::rusty_lr::parser::state::ShiftTarget::new(31, true)),
            (translation_unitTerminalClasses::enum_,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::type_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(133, true)),
            (translation_unitNonTerminals::abstract_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(216, true)),
            (translation_unitNonTerminals::direct_abstract_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(157, true)),
            (translation_unitNonTerminals::type_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(134, true)),
            (translation_unitNonTerminals::storage_class_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(135, true)),
            (translation_unitNonTerminals::declaration_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(136, true)),
            (translation_unitNonTerminals::parameter_declaration,
            ::rusty_lr::parser::state::ShiftTarget::new(137, true)),
            (translation_unitNonTerminals::parameter_list,
            ::rusty_lr::parser::state::ShiftTarget::new(138, true)),
            (translation_unitNonTerminals::parameter_type_list,
            ::rusty_lr::parser::state::ShiftTarget::new(218, true)),
            (translation_unitNonTerminals::struct_or_union,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (translation_unitNonTerminals::struct_or_union_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(128, true)),
            (translation_unitNonTerminals::enum_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(129, true)),
            (translation_unitNonTerminals::_declaration_specifierPlus60,
            ::rusty_lr::parser::state::ShiftTarget::new(146, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [118,
            119, 128, 129, 130, 131, 131, 132, 133, 134, 135, 136, 136, 137, 137, 138,
            139, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156,
            157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171,
            175, 176, 177, 178, 191, 192,]; let shifted : & 'static [u8] = & [0, 0, 0, 0,
            0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::const_,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)),
            (translation_unitTerminalClasses::volatile,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::type_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)),
            (translation_unitNonTerminals::_type_qualifierPlus63,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)),
            (translation_unitNonTerminals::_type_qualifierStar64,
            ::rusty_lr::parser::state::ShiftTarget::new(155, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![200]; __reduce_map.extend(__rustylr_tset37.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [118, 119, 128, 129, 197, 198, 199, 200,]; let
            shifted : & 'static [u8] = & [0, 0, 1, 1, 0, 0, 0, 0,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(153, true)),
            (translation_unitTerminalClasses::lbracket,
            ::rusty_lr::parser::state::ShiftTarget::new(149, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(154, true)),],
            shift_goto_map_nonterm :
            vec![(translation_unitNonTerminals::abstract_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(156, true)),
            (translation_unitNonTerminals::direct_abstract_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(157, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![129]; __reduce_map.extend(__rustylr_tset35.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [128, 128, 129, 129, 130, 131, 132, 133, 134,
            135, 136, 137, 138, 139,]; let shifted : & 'static [u8] = & [0, 2, 0, 2, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule,
            & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![128]; __reduce_map
            .extend(__rustylr_tset34.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [128,]; let shifted : & 'static [u8] = & [3,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(158, true)),
            (translation_unitTerminalClasses::lbracket,
            ::rusty_lr::parser::state::ShiftTarget::new(162, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![130]; __reduce_map
            .extend(__rustylr_tset34.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [130, 134, 135, 138, 139,]; let shifted : & 'static [u8] = &
            [1, 1, 1, 1, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted)
            | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)),
            (translation_unitTerminalClasses::rparen,
            ::rusty_lr::parser::state::ShiftTarget::new(159, true)),
            (translation_unitTerminalClasses::typedef,
            ::rusty_lr::parser::state::ShiftTarget::new(16, true)),
            (translation_unitTerminalClasses::extern_,
            ::rusty_lr::parser::state::ShiftTarget::new(17, true)),
            (translation_unitTerminalClasses::static_,
            ::rusty_lr::parser::state::ShiftTarget::new(18, true)),
            (translation_unitTerminalClasses::auto,
            ::rusty_lr::parser::state::ShiftTarget::new(19, true)),
            (translation_unitTerminalClasses::register,
            ::rusty_lr::parser::state::ShiftTarget::new(20, true)),
            (translation_unitTerminalClasses::const_,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)),
            (translation_unitTerminalClasses::volatile,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (translation_unitTerminalClasses::void_,
            ::rusty_lr::parser::state::ShiftTarget::new(21, true)),
            (translation_unitTerminalClasses::char_,
            ::rusty_lr::parser::state::ShiftTarget::new(22, true)),
            (translation_unitTerminalClasses::short_,
            ::rusty_lr::parser::state::ShiftTarget::new(23, true)),
            (translation_unitTerminalClasses::int_,
            ::rusty_lr::parser::state::ShiftTarget::new(24, true)),
            (translation_unitTerminalClasses::long_,
            ::rusty_lr::parser::state::ShiftTarget::new(25, true)),
            (translation_unitTerminalClasses::float_,
            ::rusty_lr::parser::state::ShiftTarget::new(26, true)),
            (translation_unitTerminalClasses::double_,
            ::rusty_lr::parser::state::ShiftTarget::new(27, true)),
            (translation_unitTerminalClasses::signed,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),
            (translation_unitTerminalClasses::unsigned,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (translation_unitTerminalClasses::struct_,
            ::rusty_lr::parser::state::ShiftTarget::new(30, true)),
            (translation_unitTerminalClasses::union_,
            ::rusty_lr::parser::state::ShiftTarget::new(31, true)),
            (translation_unitTerminalClasses::enum_,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::type_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(133, true)),
            (translation_unitNonTerminals::type_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(134, true)),
            (translation_unitNonTerminals::storage_class_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(135, true)),
            (translation_unitNonTerminals::declaration_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(136, true)),
            (translation_unitNonTerminals::parameter_declaration,
            ::rusty_lr::parser::state::ShiftTarget::new(137, true)),
            (translation_unitNonTerminals::parameter_list,
            ::rusty_lr::parser::state::ShiftTarget::new(138, true)),
            (translation_unitNonTerminals::parameter_type_list,
            ::rusty_lr::parser::state::ShiftTarget::new(160, true)),
            (translation_unitNonTerminals::struct_or_union,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (translation_unitNonTerminals::struct_or_union_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(128, true)),
            (translation_unitNonTerminals::enum_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(129, true)),
            (translation_unitNonTerminals::_declaration_specifierPlus60,
            ::rusty_lr::parser::state::ShiftTarget::new(146, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [118,
            119, 138, 139, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154,
            155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169,
            170, 171, 175, 176, 177, 178, 191, 192,]; let shifted : & 'static [u8] = &
            [0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter())
            .map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule
            as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![138]; __reduce_map
            .extend(__rustylr_tset36.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [138,]; let shifted : & 'static [u8] = & [3,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::rparen,
            ::rusty_lr::parser::state::ShiftTarget::new(161, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [139,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![139]; __reduce_map.extend(__rustylr_tset36.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [139,]; let shifted : & 'static [u8] = & [4,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::rbracket,
            ::rusty_lr::parser::state::ShiftTarget::new(163, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(214, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 134, 135,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 2, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![134]; __reduce_map.extend(__rustylr_tset36.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [134,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![19]; __reduce_map.extend(__rustylr_tset34.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [19,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(170, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(170, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(170, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23,
            24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
            43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
            62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,]; let shifted
            : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![35]; __reduce_map
            .extend(__rustylr_tset19.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [35,]; let shifted : & 'static [u8] = & [3,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(69, true)),
            (translation_unitTerminalClasses::slash,
            ::rusty_lr::parser::state::ShiftTarget::new(90, true)),
            (translation_unitTerminalClasses::percent,
            ::rusty_lr::parser::state::ShiftTarget::new(92, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![40]; __reduce_map
            .extend(__rustylr_tset20.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [35, 36, 37, 40,]; let shifted : & 'static [u8] = & [1, 1,
            1, 3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(76, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(88, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![42]; __reduce_map
            .extend(__rustylr_tset21.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [39, 40, 42,]; let shifted : & 'static [u8] = & [1, 1, 3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::left_op,
            ::rusty_lr::parser::state::ShiftTarget::new(78, true)),
            (translation_unitTerminalClasses::right_op,
            ::rusty_lr::parser::state::ShiftTarget::new(86, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![45]; __reduce_map
            .extend(__rustylr_tset22.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [42, 43, 45,]; let shifted : & 'static [u8] = & [1, 1, 3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::rbracket,
            ::rusty_lr::parser::state::ShiftTarget::new(171, true)),
            (translation_unitTerminalClasses::comma,
            ::rusty_lr::parser::state::ShiftTarget::new(116, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [12, 77,]; let shifted : & 'static
            [u8] = & [3, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted)
            | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![12]; __reduce_map
            .extend(__rustylr_tset14.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [12,]; let shifted : & 'static [u8] = & [4,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(173, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [15,]; let shifted : & 'static
            [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![15]; __reduce_map.extend(__rustylr_tset14.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [15,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(175, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [16,]; let shifted : & 'static
            [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![16]; __reduce_map.extend(__rustylr_tset14.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [16,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![17]; __reduce_map.extend(__rustylr_tset14.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [17,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![18]; __reduce_map.extend(__rustylr_tset14.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [18,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![25]; __reduce_map.extend(__rustylr_tset18.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [25,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![26]; __reduce_map.extend(__rustylr_tset18.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [26,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![27]; __reduce_map.extend(__rustylr_tset18.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [27,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![28]; __reduce_map.extend(__rustylr_tset18.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [28,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![29]; __reduce_map.extend(__rustylr_tset18.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [29,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![33]; __reduce_map.extend(__rustylr_tset18.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [33,]; let shifted : & 'static [u8] = & [4,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![24]; __reduce_map.extend(__rustylr_tset18.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [24,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![30]; __reduce_map.extend(__rustylr_tset18.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [30,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![23]; __reduce_map.extend(__rustylr_tset18.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [23,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![22]; __reduce_map.extend(__rustylr_tset18.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [22,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::comma,
            ::rusty_lr::parser::state::ShiftTarget::new(116, true)),
            (translation_unitTerminalClasses::colon,
            ::rusty_lr::parser::state::ShiftTarget::new(189, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [63, 77,]; let shifted : & 'static
            [u8] = & [3, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted)
            | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(190, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 63,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            4,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![63]; __reduce_map.extend(__rustylr_tset29.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [63,]; let shifted : & 'static [u8] = & [5,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(192, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 61,]; let
            shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::and_op,
            ::rusty_lr::parser::state::ShiftTarget::new(110, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![61]; __reduce_map
            .extend(__rustylr_tset28.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [59, 61,]; let shifted : & 'static [u8] = & [1, 3,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![65]; __reduce_map.extend(__rustylr_tset29.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [65,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(195, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(195, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,
            0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![66]; __reduce_map.extend(__rustylr_tset29.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [66,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(197, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(197, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 67, 68, 69, 70, 71, 72, 73, 74, 75,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0,
            0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![67]; __reduce_map.extend(__rustylr_tset29.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [67,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(199, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(199, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 68, 69, 70, 71, 72, 73, 74, 75,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0,
            0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![68]; __reduce_map.extend(__rustylr_tset29.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [68,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(201, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(201, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 69, 70, 71, 72, 73, 74, 75,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,
            0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![69]; __reduce_map.extend(__rustylr_tset29.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [69,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(203, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(203, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 70, 71, 72, 73, 74, 75,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0,
            0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![70]; __reduce_map.extend(__rustylr_tset29.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [70,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(205, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(205, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 71, 72, 73, 74, 75,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0,
            0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![71]; __reduce_map.extend(__rustylr_tset29.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [71,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(207, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(207, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 72, 73, 74, 75,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,
            0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![72]; __reduce_map.extend(__rustylr_tset29.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [72,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(209, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(209, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 73, 74, 75,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            2, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![73]; __reduce_map.extend(__rustylr_tset29.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [73,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(211, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(211, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 74, 75,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 2, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![74]; __reduce_map.extend(__rustylr_tset29.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [74,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(213, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(213, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 75,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![75]; __reduce_map.extend(__rustylr_tset29.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [75,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::rbracket,
            ::rusty_lr::parser::state::ShiftTarget::new(215, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [135,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![135]; __reduce_map.extend(__rustylr_tset36.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [135,]; let shifted : & 'static [u8] = & [4,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::rparen,
            ::rusty_lr::parser::state::ShiftTarget::new(217, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [131,]; let shifted : & 'static
            [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![131]; __reduce_map.extend(__rustylr_tset36.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [131,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::rparen,
            ::rusty_lr::parser::state::ShiftTarget::new(219, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [137,]; let shifted : & 'static
            [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![137]; __reduce_map.extend(__rustylr_tset36.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [137,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![203]; __reduce_map.extend(__rustylr_tset35.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [203,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![202]; __reduce_map.extend(__rustylr_tset31.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [202,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![142]; __reduce_map.extend(__rustylr_tset35.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [142,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![132]; __reduce_map.extend(__rustylr_tset36.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [132,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::rbracket,
            ::rusty_lr::parser::state::ShiftTarget::new(225, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [133,]; let shifted : & 'static
            [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![133]; __reduce_map.extend(__rustylr_tset36.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [133,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::const_,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)),
            (translation_unitTerminalClasses::volatile,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::type_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)),
            (translation_unitNonTerminals::_type_qualifierPlus63,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)),
            (translation_unitNonTerminals::_type_qualifierStar64,
            ::rusty_lr::parser::state::ShiftTarget::new(227, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![200]; __reduce_map.extend(__rustylr_tset8.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [118, 119, 121, 128, 129, 197, 198, 199,
            200,]; let shifted : & 'static [u8] = & [0, 0, 1, 1, 1, 0, 0, 0, 0,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(147, true)),
            (translation_unitTerminalClasses::lbracket,
            ::rusty_lr::parser::state::ShiftTarget::new(149, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(226, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)),
            (translation_unitNonTerminals::direct_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(12, true)),
            (translation_unitNonTerminals::abstract_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(156, true)),
            (translation_unitNonTerminals::direct_abstract_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(157, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![129]; __reduce_map.extend(__rustylr_tset34.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [120, 121, 121, 122, 123, 124, 125, 126, 127,
            128, 128, 129, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,]; let
            shifted : & 'static [u8] = & [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::rparen,
            ::rusty_lr::parser::state::ShiftTarget::new(229, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [126,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![126]; __reduce_map.extend(__rustylr_tset4.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [126,]; let shifted : & 'static [u8] = & [4,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::rbracket,
            ::rusty_lr::parser::state::ShiftTarget::new(231, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(232, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 124, 125,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 2, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![125]; __reduce_map.extend(__rustylr_tset4.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [125,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::rbracket,
            ::rusty_lr::parser::state::ShiftTarget::new(233, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [124,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![124]; __reduce_map.extend(__rustylr_tset4.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [124,]; let shifted : & 'static [u8] = & [4,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![163]; __reduce_map.extend(__rustylr_tset34.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [163,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![164]; __reduce_map.extend(__rustylr_tset34.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [164,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![192]; __reduce_map.extend(__rustylr_tset6.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [192,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![172]; __reduce_map.extend(__rustylr_tset38.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [172,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::comma,
            ::rusty_lr::parser::state::ShiftTarget::new(239, true)),
            (translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(241, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [173, 174,]; let shifted : &
            'static [u8] = & [1, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(240, true)),
            (translation_unitNonTerminals::direct_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(12, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [120,
            121, 122, 123, 124, 125, 126, 127, 173,]; let shifted : & 'static [u8] = &
            [0, 0, 0, 0, 0, 0, 0, 0, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule,
            & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![173]; __reduce_map
            .extend(__rustylr_tset38.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [173,]; let shifted : & 'static [u8] = & [3,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![174]; __reduce_map.extend(__rustylr_tset33.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [174,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![20]; __reduce_map.extend(__rustylr_tset34.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [20,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![182]; __reduce_map.extend(__rustylr_tset13.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [182,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![193]; __reduce_map.extend(__rustylr_tset39.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [193,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::eof,
            ::rusty_lr::parser::state::ShiftTarget::new(246, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [211,]; let shifted : & 'static
            [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [211,];
            let shifted : & 'static [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(|
            (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::lbrace,
            ::rusty_lr::parser::state::ShiftTarget::new(248, true)),],
            shift_goto_map_nonterm :
            vec![(translation_unitNonTerminals::compound_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(329, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [88,
            108,]; let shifted : & 'static [u8] = & [0, 1,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(249, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::lbrace,
            ::rusty_lr::parser::state::ShiftTarget::new(248, true)),
            (translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(252, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),
            (translation_unitTerminalClasses::case,
            ::rusty_lr::parser::state::ShiftTarget::new(253, true)),
            (translation_unitTerminalClasses::default,
            ::rusty_lr::parser::state::ShiftTarget::new(256, true)),
            (translation_unitTerminalClasses::if_,
            ::rusty_lr::parser::state::ShiftTarget::new(258, true)),
            (translation_unitTerminalClasses::switch,
            ::rusty_lr::parser::state::ShiftTarget::new(262, true)),
            (translation_unitTerminalClasses::while_,
            ::rusty_lr::parser::state::ShiftTarget::new(266, true)),
            (translation_unitTerminalClasses::do_,
            ::rusty_lr::parser::state::ShiftTarget::new(270, true)),
            (translation_unitTerminalClasses::for_,
            ::rusty_lr::parser::state::ShiftTarget::new(271, true)),
            (translation_unitTerminalClasses::goto_,
            ::rusty_lr::parser::state::ShiftTarget::new(278, true)),
            (translation_unitTerminalClasses::continue_,
            ::rusty_lr::parser::state::ShiftTarget::new(281, true)),
            (translation_unitTerminalClasses::break_,
            ::rusty_lr::parser::state::ShiftTarget::new(283, true)),
            (translation_unitTerminalClasses::return_,
            ::rusty_lr::parser::state::ShiftTarget::new(285, true)),
            (translation_unitTerminalClasses::typedef,
            ::rusty_lr::parser::state::ShiftTarget::new(16, true)),
            (translation_unitTerminalClasses::extern_,
            ::rusty_lr::parser::state::ShiftTarget::new(17, true)),
            (translation_unitTerminalClasses::static_,
            ::rusty_lr::parser::state::ShiftTarget::new(18, true)),
            (translation_unitTerminalClasses::auto,
            ::rusty_lr::parser::state::ShiftTarget::new(19, true)),
            (translation_unitTerminalClasses::register,
            ::rusty_lr::parser::state::ShiftTarget::new(20, true)),
            (translation_unitTerminalClasses::const_,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)),
            (translation_unitTerminalClasses::volatile,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (translation_unitTerminalClasses::void_,
            ::rusty_lr::parser::state::ShiftTarget::new(21, true)),
            (translation_unitTerminalClasses::char_,
            ::rusty_lr::parser::state::ShiftTarget::new(22, true)),
            (translation_unitTerminalClasses::short_,
            ::rusty_lr::parser::state::ShiftTarget::new(23, true)),
            (translation_unitTerminalClasses::int_,
            ::rusty_lr::parser::state::ShiftTarget::new(24, true)),
            (translation_unitTerminalClasses::long_,
            ::rusty_lr::parser::state::ShiftTarget::new(25, true)),
            (translation_unitTerminalClasses::float_,
            ::rusty_lr::parser::state::ShiftTarget::new(26, true)),
            (translation_unitTerminalClasses::double_,
            ::rusty_lr::parser::state::ShiftTarget::new(27, true)),
            (translation_unitTerminalClasses::signed,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),
            (translation_unitTerminalClasses::unsigned,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (translation_unitTerminalClasses::struct_,
            ::rusty_lr::parser::state::ShiftTarget::new(30, true)),
            (translation_unitTerminalClasses::union_,
            ::rusty_lr::parser::state::ShiftTarget::new(31, true)),
            (translation_unitTerminalClasses::enum_,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::labeled_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(310, true)),
            (translation_unitNonTerminals::statement_or_declaration,
            ::rusty_lr::parser::state::ShiftTarget::new(310, true)),
            (translation_unitNonTerminals::compound_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(310, true)),
            (translation_unitNonTerminals::expression_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(310, true)),
            (translation_unitNonTerminals::selection_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(310, true)),
            (translation_unitNonTerminals::iteration_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(310, true)),
            (translation_unitNonTerminals::jump_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(310, true)),
            (translation_unitNonTerminals::declaration,
            ::rusty_lr::parser::state::ShiftTarget::new(310, true)),
            (translation_unitNonTerminals::statement,
            ::rusty_lr::parser::state::ShiftTarget::new(310, true)),
            (translation_unitNonTerminals::type_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(133, true)),
            (translation_unitNonTerminals::type_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(134, true)),
            (translation_unitNonTerminals::storage_class_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(135, true)),
            (translation_unitNonTerminals::declaration_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(136, true)),
            (translation_unitNonTerminals::struct_or_union,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (translation_unitNonTerminals::struct_or_union_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(128, true)),
            (translation_unitNonTerminals::enum_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(129, true)),
            (translation_unitNonTerminals::_statement_or_declarationPlus58,
            ::rusty_lr::parser::state::ShiftTarget::new(311, true)),
            (translation_unitNonTerminals::_statement_or_declarationStar59,
            ::rusty_lr::parser::state::ShiftTarget::new(313, true)),
            (translation_unitNonTerminals::_declaration_specifierPlus60,
            ::rusty_lr::parser::state::ShiftTarget::new(293, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![190]; __reduce_map.extend(__rustylr_tset32.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
            14, 15, 16, 17, 18, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,
            35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,
            54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72,
            73, 74, 75, 76, 77, 83, 84, 85, 86, 87, 88, 88, 89, 90, 91, 92, 93, 96, 97,
            98, 99, 100, 101, 102, 103, 104, 105, 106, 109, 110, 111, 112, 113, 114, 118,
            119, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156,
            157, 158, 159, 160, 161, 162, 170, 171, 175, 176, 177, 178, 187, 188, 189,
            190, 191, 192,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::colon,
            ::rusty_lr::parser::state::ShiftTarget::new(250, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![7]; __reduce_map
            .extend(__rustylr_tset40.iter().map(| term | (* term, reduce_rules
            .clone()))); let reduce_rules = vec![7, 152]; __reduce_map
            .extend(__rustylr_tset41.iter().map(| term | (* term, reduce_rules
            .clone()))); let reduce_rules = vec![152]; __reduce_map
            .extend(__rustylr_tset17.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [7, 83, 152,]; let shifted : & 'static [u8] = & [1, 1, 1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(251, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::lbrace,
            ::rusty_lr::parser::state::ShiftTarget::new(248, true)),
            (translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(252, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),
            (translation_unitTerminalClasses::case,
            ::rusty_lr::parser::state::ShiftTarget::new(253, true)),
            (translation_unitTerminalClasses::default,
            ::rusty_lr::parser::state::ShiftTarget::new(256, true)),
            (translation_unitTerminalClasses::if_,
            ::rusty_lr::parser::state::ShiftTarget::new(258, true)),
            (translation_unitTerminalClasses::switch,
            ::rusty_lr::parser::state::ShiftTarget::new(262, true)),
            (translation_unitTerminalClasses::while_,
            ::rusty_lr::parser::state::ShiftTarget::new(266, true)),
            (translation_unitTerminalClasses::do_,
            ::rusty_lr::parser::state::ShiftTarget::new(270, true)),
            (translation_unitTerminalClasses::for_,
            ::rusty_lr::parser::state::ShiftTarget::new(271, true)),
            (translation_unitTerminalClasses::goto_,
            ::rusty_lr::parser::state::ShiftTarget::new(278, true)),
            (translation_unitTerminalClasses::continue_,
            ::rusty_lr::parser::state::ShiftTarget::new(281, true)),
            (translation_unitTerminalClasses::break_,
            ::rusty_lr::parser::state::ShiftTarget::new(283, true)),
            (translation_unitTerminalClasses::return_,
            ::rusty_lr::parser::state::ShiftTarget::new(285, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::labeled_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(328, true)),
            (translation_unitNonTerminals::compound_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(328, true)),
            (translation_unitNonTerminals::expression_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(328, true)),
            (translation_unitNonTerminals::selection_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(328, true)),
            (translation_unitNonTerminals::iteration_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(328, true)),
            (translation_unitNonTerminals::jump_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(328, true)),
            (translation_unitNonTerminals::statement,
            ::rusty_lr::parser::state::ShiftTarget::new(328, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 83, 83, 84, 85,
            88, 89, 90, 91, 92, 93, 96, 97, 98, 99, 100, 101, 102, 103, 104, 109, 110,
            111, 112, 113, 114,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::colon,
            ::rusty_lr::parser::state::ShiftTarget::new(250, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![7]; __reduce_map
            .extend(__rustylr_tset42.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [7, 83,]; let shifted : & 'static [u8] = & [1, 1,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![89]; __reduce_map.extend(__rustylr_tset43.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [89,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(254, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 84,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::colon,
            ::rusty_lr::parser::state::ShiftTarget::new(255, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [84,]; let shifted : & 'static
            [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(251, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::lbrace,
            ::rusty_lr::parser::state::ShiftTarget::new(248, true)),
            (translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(252, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),
            (translation_unitTerminalClasses::case,
            ::rusty_lr::parser::state::ShiftTarget::new(253, true)),
            (translation_unitTerminalClasses::default,
            ::rusty_lr::parser::state::ShiftTarget::new(256, true)),
            (translation_unitTerminalClasses::if_,
            ::rusty_lr::parser::state::ShiftTarget::new(258, true)),
            (translation_unitTerminalClasses::switch,
            ::rusty_lr::parser::state::ShiftTarget::new(262, true)),
            (translation_unitTerminalClasses::while_,
            ::rusty_lr::parser::state::ShiftTarget::new(266, true)),
            (translation_unitTerminalClasses::do_,
            ::rusty_lr::parser::state::ShiftTarget::new(270, true)),
            (translation_unitTerminalClasses::for_,
            ::rusty_lr::parser::state::ShiftTarget::new(271, true)),
            (translation_unitTerminalClasses::goto_,
            ::rusty_lr::parser::state::ShiftTarget::new(278, true)),
            (translation_unitTerminalClasses::continue_,
            ::rusty_lr::parser::state::ShiftTarget::new(281, true)),
            (translation_unitTerminalClasses::break_,
            ::rusty_lr::parser::state::ShiftTarget::new(283, true)),
            (translation_unitTerminalClasses::return_,
            ::rusty_lr::parser::state::ShiftTarget::new(285, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::labeled_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(327, true)),
            (translation_unitNonTerminals::compound_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(327, true)),
            (translation_unitNonTerminals::expression_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(327, true)),
            (translation_unitNonTerminals::selection_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(327, true)),
            (translation_unitNonTerminals::iteration_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(327, true)),
            (translation_unitNonTerminals::jump_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(327, true)),
            (translation_unitNonTerminals::statement,
            ::rusty_lr::parser::state::ShiftTarget::new(327, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 83, 84, 84, 85,
            88, 89, 90, 91, 92, 93, 96, 97, 98, 99, 100, 101, 102, 103, 104, 109, 110,
            111, 112, 113, 114,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::colon,
            ::rusty_lr::parser::state::ShiftTarget::new(257, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [85,]; let shifted : & 'static
            [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(251, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::lbrace,
            ::rusty_lr::parser::state::ShiftTarget::new(248, true)),
            (translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(252, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),
            (translation_unitTerminalClasses::case,
            ::rusty_lr::parser::state::ShiftTarget::new(253, true)),
            (translation_unitTerminalClasses::default,
            ::rusty_lr::parser::state::ShiftTarget::new(256, true)),
            (translation_unitTerminalClasses::if_,
            ::rusty_lr::parser::state::ShiftTarget::new(258, true)),
            (translation_unitTerminalClasses::switch,
            ::rusty_lr::parser::state::ShiftTarget::new(262, true)),
            (translation_unitTerminalClasses::while_,
            ::rusty_lr::parser::state::ShiftTarget::new(266, true)),
            (translation_unitTerminalClasses::do_,
            ::rusty_lr::parser::state::ShiftTarget::new(270, true)),
            (translation_unitTerminalClasses::for_,
            ::rusty_lr::parser::state::ShiftTarget::new(271, true)),
            (translation_unitTerminalClasses::goto_,
            ::rusty_lr::parser::state::ShiftTarget::new(278, true)),
            (translation_unitTerminalClasses::continue_,
            ::rusty_lr::parser::state::ShiftTarget::new(281, true)),
            (translation_unitTerminalClasses::break_,
            ::rusty_lr::parser::state::ShiftTarget::new(283, true)),
            (translation_unitTerminalClasses::return_,
            ::rusty_lr::parser::state::ShiftTarget::new(285, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::labeled_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(326, true)),
            (translation_unitNonTerminals::compound_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(326, true)),
            (translation_unitNonTerminals::expression_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(326, true)),
            (translation_unitNonTerminals::selection_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(326, true)),
            (translation_unitNonTerminals::iteration_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(326, true)),
            (translation_unitNonTerminals::jump_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(326, true)),
            (translation_unitNonTerminals::statement,
            ::rusty_lr::parser::state::ShiftTarget::new(326, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 83, 84, 85, 85,
            88, 89, 90, 91, 92, 93, 96, 97, 98, 99, 100, 101, 102, 103, 104, 109, 110,
            111, 112, 113, 114,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(259, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [91, 92,]; let shifted : & 'static
            [u8] = & [1, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted)
            | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(260, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(260, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(260, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 91, 92,]; let
            shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 2, 2,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::rparen,
            ::rusty_lr::parser::state::ShiftTarget::new(261, true)),
            (translation_unitTerminalClasses::comma,
            ::rusty_lr::parser::state::ShiftTarget::new(116, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [77, 91, 92,]; let shifted : &
            'static [u8] = & [1, 3, 3,]; rules.iter().zip(shifted.iter()).map(| (& rule,
            & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(251, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::lbrace,
            ::rusty_lr::parser::state::ShiftTarget::new(248, true)),
            (translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(252, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),
            (translation_unitTerminalClasses::case,
            ::rusty_lr::parser::state::ShiftTarget::new(253, true)),
            (translation_unitTerminalClasses::default,
            ::rusty_lr::parser::state::ShiftTarget::new(256, true)),
            (translation_unitTerminalClasses::if_,
            ::rusty_lr::parser::state::ShiftTarget::new(258, true)),
            (translation_unitTerminalClasses::switch,
            ::rusty_lr::parser::state::ShiftTarget::new(262, true)),
            (translation_unitTerminalClasses::while_,
            ::rusty_lr::parser::state::ShiftTarget::new(266, true)),
            (translation_unitTerminalClasses::do_,
            ::rusty_lr::parser::state::ShiftTarget::new(270, true)),
            (translation_unitTerminalClasses::for_,
            ::rusty_lr::parser::state::ShiftTarget::new(271, true)),
            (translation_unitTerminalClasses::goto_,
            ::rusty_lr::parser::state::ShiftTarget::new(278, true)),
            (translation_unitTerminalClasses::continue_,
            ::rusty_lr::parser::state::ShiftTarget::new(281, true)),
            (translation_unitTerminalClasses::break_,
            ::rusty_lr::parser::state::ShiftTarget::new(283, true)),
            (translation_unitTerminalClasses::return_,
            ::rusty_lr::parser::state::ShiftTarget::new(285, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::labeled_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(323, true)),
            (translation_unitNonTerminals::compound_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(323, true)),
            (translation_unitNonTerminals::expression_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(323, true)),
            (translation_unitNonTerminals::selection_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(323, true)),
            (translation_unitNonTerminals::iteration_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(323, true)),
            (translation_unitNonTerminals::jump_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(323, true)),
            (translation_unitNonTerminals::statement,
            ::rusty_lr::parser::state::ShiftTarget::new(323, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 83, 84, 85, 88,
            89, 90, 91, 91, 92, 92, 93, 96, 97, 98, 99, 100, 101, 102, 103, 104, 109,
            110, 111, 112, 113, 114,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(263, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [93,]; let shifted : & 'static
            [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(264, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(264, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(264, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 93,]; let shifted
            : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::rparen,
            ::rusty_lr::parser::state::ShiftTarget::new(265, true)),
            (translation_unitTerminalClasses::comma,
            ::rusty_lr::parser::state::ShiftTarget::new(116, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [77, 93,]; let shifted : & 'static
            [u8] = & [1, 3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted)
            | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(251, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::lbrace,
            ::rusty_lr::parser::state::ShiftTarget::new(248, true)),
            (translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(252, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),
            (translation_unitTerminalClasses::case,
            ::rusty_lr::parser::state::ShiftTarget::new(253, true)),
            (translation_unitTerminalClasses::default,
            ::rusty_lr::parser::state::ShiftTarget::new(256, true)),
            (translation_unitTerminalClasses::if_,
            ::rusty_lr::parser::state::ShiftTarget::new(258, true)),
            (translation_unitTerminalClasses::switch,
            ::rusty_lr::parser::state::ShiftTarget::new(262, true)),
            (translation_unitTerminalClasses::while_,
            ::rusty_lr::parser::state::ShiftTarget::new(266, true)),
            (translation_unitTerminalClasses::do_,
            ::rusty_lr::parser::state::ShiftTarget::new(270, true)),
            (translation_unitTerminalClasses::for_,
            ::rusty_lr::parser::state::ShiftTarget::new(271, true)),
            (translation_unitTerminalClasses::goto_,
            ::rusty_lr::parser::state::ShiftTarget::new(278, true)),
            (translation_unitTerminalClasses::continue_,
            ::rusty_lr::parser::state::ShiftTarget::new(281, true)),
            (translation_unitTerminalClasses::break_,
            ::rusty_lr::parser::state::ShiftTarget::new(283, true)),
            (translation_unitTerminalClasses::return_,
            ::rusty_lr::parser::state::ShiftTarget::new(285, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::labeled_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(322, true)),
            (translation_unitNonTerminals::compound_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(322, true)),
            (translation_unitNonTerminals::expression_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(322, true)),
            (translation_unitNonTerminals::selection_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(322, true)),
            (translation_unitNonTerminals::iteration_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(322, true)),
            (translation_unitNonTerminals::jump_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(322, true)),
            (translation_unitNonTerminals::statement,
            ::rusty_lr::parser::state::ShiftTarget::new(322, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 83, 84, 85, 88,
            89, 90, 91, 92, 93, 93, 96, 97, 98, 99, 100, 101, 102, 103, 104, 109, 110,
            111, 112, 113, 114,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(267, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [96,]; let shifted : & 'static
            [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(268, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(268, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(268, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 96,]; let shifted
            : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::rparen,
            ::rusty_lr::parser::state::ShiftTarget::new(269, true)),
            (translation_unitTerminalClasses::comma,
            ::rusty_lr::parser::state::ShiftTarget::new(116, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [77, 96,]; let shifted : & 'static
            [u8] = & [1, 3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted)
            | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(251, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::lbrace,
            ::rusty_lr::parser::state::ShiftTarget::new(248, true)),
            (translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(252, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),
            (translation_unitTerminalClasses::case,
            ::rusty_lr::parser::state::ShiftTarget::new(253, true)),
            (translation_unitTerminalClasses::default,
            ::rusty_lr::parser::state::ShiftTarget::new(256, true)),
            (translation_unitTerminalClasses::if_,
            ::rusty_lr::parser::state::ShiftTarget::new(258, true)),
            (translation_unitTerminalClasses::switch,
            ::rusty_lr::parser::state::ShiftTarget::new(262, true)),
            (translation_unitTerminalClasses::while_,
            ::rusty_lr::parser::state::ShiftTarget::new(266, true)),
            (translation_unitTerminalClasses::do_,
            ::rusty_lr::parser::state::ShiftTarget::new(270, true)),
            (translation_unitTerminalClasses::for_,
            ::rusty_lr::parser::state::ShiftTarget::new(271, true)),
            (translation_unitTerminalClasses::goto_,
            ::rusty_lr::parser::state::ShiftTarget::new(278, true)),
            (translation_unitTerminalClasses::continue_,
            ::rusty_lr::parser::state::ShiftTarget::new(281, true)),
            (translation_unitTerminalClasses::break_,
            ::rusty_lr::parser::state::ShiftTarget::new(283, true)),
            (translation_unitTerminalClasses::return_,
            ::rusty_lr::parser::state::ShiftTarget::new(285, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::labeled_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(321, true)),
            (translation_unitNonTerminals::compound_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(321, true)),
            (translation_unitNonTerminals::expression_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(321, true)),
            (translation_unitNonTerminals::selection_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(321, true)),
            (translation_unitNonTerminals::iteration_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(321, true)),
            (translation_unitNonTerminals::jump_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(321, true)),
            (translation_unitNonTerminals::statement,
            ::rusty_lr::parser::state::ShiftTarget::new(321, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 83, 84, 85, 88,
            89, 90, 91, 92, 93, 96, 96, 97, 98, 99, 100, 101, 102, 103, 104, 109, 110,
            111, 112, 113, 114,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(251, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::lbrace,
            ::rusty_lr::parser::state::ShiftTarget::new(248, true)),
            (translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(252, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),
            (translation_unitTerminalClasses::case,
            ::rusty_lr::parser::state::ShiftTarget::new(253, true)),
            (translation_unitTerminalClasses::default,
            ::rusty_lr::parser::state::ShiftTarget::new(256, true)),
            (translation_unitTerminalClasses::if_,
            ::rusty_lr::parser::state::ShiftTarget::new(258, true)),
            (translation_unitTerminalClasses::switch,
            ::rusty_lr::parser::state::ShiftTarget::new(262, true)),
            (translation_unitTerminalClasses::while_,
            ::rusty_lr::parser::state::ShiftTarget::new(266, true)),
            (translation_unitTerminalClasses::do_,
            ::rusty_lr::parser::state::ShiftTarget::new(270, true)),
            (translation_unitTerminalClasses::for_,
            ::rusty_lr::parser::state::ShiftTarget::new(271, true)),
            (translation_unitTerminalClasses::goto_,
            ::rusty_lr::parser::state::ShiftTarget::new(278, true)),
            (translation_unitTerminalClasses::continue_,
            ::rusty_lr::parser::state::ShiftTarget::new(281, true)),
            (translation_unitTerminalClasses::break_,
            ::rusty_lr::parser::state::ShiftTarget::new(283, true)),
            (translation_unitTerminalClasses::return_,
            ::rusty_lr::parser::state::ShiftTarget::new(285, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::labeled_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(315, true)),
            (translation_unitNonTerminals::compound_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(315, true)),
            (translation_unitNonTerminals::expression_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(315, true)),
            (translation_unitNonTerminals::selection_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(315, true)),
            (translation_unitNonTerminals::iteration_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(315, true)),
            (translation_unitNonTerminals::jump_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(315, true)),
            (translation_unitNonTerminals::statement,
            ::rusty_lr::parser::state::ShiftTarget::new(315, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 83, 84, 85, 88,
            89, 90, 91, 92, 93, 96, 97, 97, 98, 99, 100, 101, 102, 103, 104, 109, 110,
            111, 112, 113, 114,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(272, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [98, 99,]; let shifted : & 'static
            [u8] = & [1, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted)
            | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(252, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),
            (translation_unitTerminalClasses::typedef,
            ::rusty_lr::parser::state::ShiftTarget::new(16, true)),
            (translation_unitTerminalClasses::extern_,
            ::rusty_lr::parser::state::ShiftTarget::new(17, true)),
            (translation_unitTerminalClasses::static_,
            ::rusty_lr::parser::state::ShiftTarget::new(18, true)),
            (translation_unitTerminalClasses::auto,
            ::rusty_lr::parser::state::ShiftTarget::new(19, true)),
            (translation_unitTerminalClasses::register,
            ::rusty_lr::parser::state::ShiftTarget::new(20, true)),
            (translation_unitTerminalClasses::const_,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)),
            (translation_unitTerminalClasses::volatile,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (translation_unitTerminalClasses::void_,
            ::rusty_lr::parser::state::ShiftTarget::new(21, true)),
            (translation_unitTerminalClasses::char_,
            ::rusty_lr::parser::state::ShiftTarget::new(22, true)),
            (translation_unitTerminalClasses::short_,
            ::rusty_lr::parser::state::ShiftTarget::new(23, true)),
            (translation_unitTerminalClasses::int_,
            ::rusty_lr::parser::state::ShiftTarget::new(24, true)),
            (translation_unitTerminalClasses::long_,
            ::rusty_lr::parser::state::ShiftTarget::new(25, true)),
            (translation_unitTerminalClasses::float_,
            ::rusty_lr::parser::state::ShiftTarget::new(26, true)),
            (translation_unitTerminalClasses::double_,
            ::rusty_lr::parser::state::ShiftTarget::new(27, true)),
            (translation_unitTerminalClasses::signed,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),
            (translation_unitTerminalClasses::unsigned,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (translation_unitTerminalClasses::struct_,
            ::rusty_lr::parser::state::ShiftTarget::new(30, true)),
            (translation_unitTerminalClasses::union_,
            ::rusty_lr::parser::state::ShiftTarget::new(31, true)),
            (translation_unitTerminalClasses::enum_,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::expression_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(275, true)),
            (translation_unitNonTerminals::declaration_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(275, true)),
            (translation_unitNonTerminals::declaration,
            ::rusty_lr::parser::state::ShiftTarget::new(275, true)),
            (translation_unitNonTerminals::type_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(133, true)),
            (translation_unitNonTerminals::type_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(134, true)),
            (translation_unitNonTerminals::storage_class_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(135, true)),
            (translation_unitNonTerminals::declaration_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(136, true)),
            (translation_unitNonTerminals::struct_or_union,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (translation_unitNonTerminals::struct_or_union_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(128, true)),
            (translation_unitNonTerminals::enum_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(129, true)),
            (translation_unitNonTerminals::_declaration_specifierPlus60,
            ::rusty_lr::parser::state::ShiftTarget::new(293, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 89, 90, 94, 95,
            98, 99, 105, 106, 118, 119, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152,
            153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 170, 171, 175, 176, 177,
            178, 191, 192,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::comma,
            ::rusty_lr::parser::state::ShiftTarget::new(116, true)),
            (translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(274, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [77, 90,]; let shifted : & 'static
            [u8] = & [1, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted)
            | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![90]; __reduce_map
            .extend(__rustylr_tset43.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [90,]; let shifted : & 'static [u8] = & [2,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(252, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::expression_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(276, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 89, 90, 98, 99,];
            let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3,]; rules.iter().zip(shifted.iter())
            .map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule
            as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::rparen,
            ::rusty_lr::parser::state::ShiftTarget::new(277, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(290, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(290, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(290, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 98, 99,]; let
            shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 4, 4,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(251, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::lbrace,
            ::rusty_lr::parser::state::ShiftTarget::new(248, true)),
            (translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(252, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),
            (translation_unitTerminalClasses::case,
            ::rusty_lr::parser::state::ShiftTarget::new(253, true)),
            (translation_unitTerminalClasses::default,
            ::rusty_lr::parser::state::ShiftTarget::new(256, true)),
            (translation_unitTerminalClasses::if_,
            ::rusty_lr::parser::state::ShiftTarget::new(258, true)),
            (translation_unitTerminalClasses::switch,
            ::rusty_lr::parser::state::ShiftTarget::new(262, true)),
            (translation_unitTerminalClasses::while_,
            ::rusty_lr::parser::state::ShiftTarget::new(266, true)),
            (translation_unitTerminalClasses::do_,
            ::rusty_lr::parser::state::ShiftTarget::new(270, true)),
            (translation_unitTerminalClasses::for_,
            ::rusty_lr::parser::state::ShiftTarget::new(271, true)),
            (translation_unitTerminalClasses::goto_,
            ::rusty_lr::parser::state::ShiftTarget::new(278, true)),
            (translation_unitTerminalClasses::continue_,
            ::rusty_lr::parser::state::ShiftTarget::new(281, true)),
            (translation_unitTerminalClasses::break_,
            ::rusty_lr::parser::state::ShiftTarget::new(283, true)),
            (translation_unitTerminalClasses::return_,
            ::rusty_lr::parser::state::ShiftTarget::new(285, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::labeled_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(289, true)),
            (translation_unitNonTerminals::compound_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(289, true)),
            (translation_unitNonTerminals::expression_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(289, true)),
            (translation_unitNonTerminals::selection_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(289, true)),
            (translation_unitNonTerminals::iteration_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(289, true)),
            (translation_unitNonTerminals::jump_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(289, true)),
            (translation_unitNonTerminals::statement,
            ::rusty_lr::parser::state::ShiftTarget::new(289, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 83, 84, 85, 88,
            89, 90, 91, 92, 93, 96, 97, 98, 98, 99, 100, 101, 102, 103, 104, 109, 110,
            111, 112, 113, 114,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(279, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [100,]; let shifted : & 'static
            [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(280, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [100,]; let shifted : & 'static
            [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![100]; __reduce_map.extend(__rustylr_tset44.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [100,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(282, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [101,]; let shifted : & 'static
            [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![101]; __reduce_map.extend(__rustylr_tset44.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [101,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(284, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [102,]; let shifted : & 'static
            [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![102]; __reduce_map.extend(__rustylr_tset44.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [102,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(286, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(287, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(287, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(287, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 103, 104,]; let
            shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 1, 1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![103]; __reduce_map
            .extend(__rustylr_tset44.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [103,]; let shifted : & 'static [u8] = & [2,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::comma,
            ::rusty_lr::parser::state::ShiftTarget::new(116, true)),
            (translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(288, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [77, 104,]; let shifted : &
            'static [u8] = & [1, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![104]; __reduce_map
            .extend(__rustylr_tset44.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [104,]; let shifted : & 'static [u8] = & [3,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![98]; __reduce_map.extend(__rustylr_tset44.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [98,]; let shifted : & 'static [u8] = & [6,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::rparen,
            ::rusty_lr::parser::state::ShiftTarget::new(291, true)),
            (translation_unitTerminalClasses::comma,
            ::rusty_lr::parser::state::ShiftTarget::new(116, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [77, 99,]; let shifted : & 'static
            [u8] = & [1, 5,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted)
            | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(251, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::lbrace,
            ::rusty_lr::parser::state::ShiftTarget::new(248, true)),
            (translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(252, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),
            (translation_unitTerminalClasses::case,
            ::rusty_lr::parser::state::ShiftTarget::new(253, true)),
            (translation_unitTerminalClasses::default,
            ::rusty_lr::parser::state::ShiftTarget::new(256, true)),
            (translation_unitTerminalClasses::if_,
            ::rusty_lr::parser::state::ShiftTarget::new(258, true)),
            (translation_unitTerminalClasses::switch,
            ::rusty_lr::parser::state::ShiftTarget::new(262, true)),
            (translation_unitTerminalClasses::while_,
            ::rusty_lr::parser::state::ShiftTarget::new(266, true)),
            (translation_unitTerminalClasses::do_,
            ::rusty_lr::parser::state::ShiftTarget::new(270, true)),
            (translation_unitTerminalClasses::for_,
            ::rusty_lr::parser::state::ShiftTarget::new(271, true)),
            (translation_unitTerminalClasses::goto_,
            ::rusty_lr::parser::state::ShiftTarget::new(278, true)),
            (translation_unitTerminalClasses::continue_,
            ::rusty_lr::parser::state::ShiftTarget::new(281, true)),
            (translation_unitTerminalClasses::break_,
            ::rusty_lr::parser::state::ShiftTarget::new(283, true)),
            (translation_unitTerminalClasses::return_,
            ::rusty_lr::parser::state::ShiftTarget::new(285, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::labeled_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(292, true)),
            (translation_unitNonTerminals::compound_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(292, true)),
            (translation_unitNonTerminals::expression_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(292, true)),
            (translation_unitNonTerminals::selection_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(292, true)),
            (translation_unitNonTerminals::iteration_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(292, true)),
            (translation_unitNonTerminals::jump_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(292, true)),
            (translation_unitNonTerminals::statement,
            ::rusty_lr::parser::state::ShiftTarget::new(292, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 83, 84, 85, 88,
            89, 90, 91, 92, 93, 96, 97, 98, 99, 99, 100, 101, 102, 103, 104, 109, 110,
            111, 112, 113, 114,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![99]; __reduce_map
            .extend(__rustylr_tset44.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [99,]; let shifted : & 'static [u8] = & [7,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)),
            (translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(294, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)),
            (translation_unitTerminalClasses::typedef,
            ::rusty_lr::parser::state::ShiftTarget::new(16, true)),
            (translation_unitTerminalClasses::extern_,
            ::rusty_lr::parser::state::ShiftTarget::new(17, true)),
            (translation_unitTerminalClasses::static_,
            ::rusty_lr::parser::state::ShiftTarget::new(18, true)),
            (translation_unitTerminalClasses::auto,
            ::rusty_lr::parser::state::ShiftTarget::new(19, true)),
            (translation_unitTerminalClasses::register,
            ::rusty_lr::parser::state::ShiftTarget::new(20, true)),
            (translation_unitTerminalClasses::const_,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)),
            (translation_unitTerminalClasses::volatile,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (translation_unitTerminalClasses::void_,
            ::rusty_lr::parser::state::ShiftTarget::new(21, true)),
            (translation_unitTerminalClasses::char_,
            ::rusty_lr::parser::state::ShiftTarget::new(22, true)),
            (translation_unitTerminalClasses::short_,
            ::rusty_lr::parser::state::ShiftTarget::new(23, true)),
            (translation_unitTerminalClasses::int_,
            ::rusty_lr::parser::state::ShiftTarget::new(24, true)),
            (translation_unitTerminalClasses::long_,
            ::rusty_lr::parser::state::ShiftTarget::new(25, true)),
            (translation_unitTerminalClasses::float_,
            ::rusty_lr::parser::state::ShiftTarget::new(26, true)),
            (translation_unitTerminalClasses::double_,
            ::rusty_lr::parser::state::ShiftTarget::new(27, true)),
            (translation_unitTerminalClasses::signed,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),
            (translation_unitTerminalClasses::unsigned,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (translation_unitTerminalClasses::struct_,
            ::rusty_lr::parser::state::ShiftTarget::new(30, true)),
            (translation_unitTerminalClasses::union_,
            ::rusty_lr::parser::state::ShiftTarget::new(31, true)),
            (translation_unitTerminalClasses::enum_,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::type_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(133, true)),
            (translation_unitNonTerminals::declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(295, true)),
            (translation_unitNonTerminals::direct_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(12, true)),
            (translation_unitNonTerminals::type_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(134, true)),
            (translation_unitNonTerminals::storage_class_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(135, true)),
            (translation_unitNonTerminals::declaration_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(236, true)),
            (translation_unitNonTerminals::struct_or_union,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (translation_unitNonTerminals::struct_or_union_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(128, true)),
            (translation_unitNonTerminals::enum_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(129, true)),
            (translation_unitNonTerminals::init_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(305, true)),
            (translation_unitNonTerminals::init_declarator_list,
            ::rusty_lr::parser::state::ShiftTarget::new(306, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [105,
            106, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 143, 144, 145, 146,
            147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161,
            162, 170, 171, 175, 176, 177, 178, 183, 184, 185, 186, 192,]; let shifted : &
            'static [u8] = & [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![105]; __reduce_map.extend(__rustylr_tset45.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [105,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::assign,
            ::rusty_lr::parser::state::ShiftTarget::new(296, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![183]; __reduce_map
            .extend(__rustylr_tset38.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [183, 184,]; let shifted : & 'static [u8] = & [1, 1,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::lbrace,
            ::rusty_lr::parser::state::ShiftTarget::new(297, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(304, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(304, true)),
            (translation_unitNonTerminals::initializer,
            ::rusty_lr::parser::state::ShiftTarget::new(304, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 78, 79, 80, 184,]; let
            shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 2,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::lbrace,
            ::rusty_lr::parser::state::ShiftTarget::new(297, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(298, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(298, true)),
            (translation_unitNonTerminals::initializer,
            ::rusty_lr::parser::state::ShiftTarget::new(298, true)),
            (translation_unitNonTerminals::initializer_list,
            ::rusty_lr::parser::state::ShiftTarget::new(299, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 78, 79, 79, 80, 80, 81,
            82,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![81]; __reduce_map
            .extend(__rustylr_tset13.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [81,]; let shifted : & 'static [u8] = & [1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::rbrace,
            ::rusty_lr::parser::state::ShiftTarget::new(300, true)),
            (translation_unitTerminalClasses::comma,
            ::rusty_lr::parser::state::ShiftTarget::new(301, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [79, 80, 82,]; let shifted : &
            'static [u8] = & [2, 2, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule,
            & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![79]; __reduce_map
            .extend(__rustylr_tset46.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [79,]; let shifted : & 'static [u8] = & [3,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::lbrace,
            ::rusty_lr::parser::state::ShiftTarget::new(297, true)),
            (translation_unitTerminalClasses::rbrace,
            ::rusty_lr::parser::state::ShiftTarget::new(302, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(303, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(303, true)),
            (translation_unitNonTerminals::initializer,
            ::rusty_lr::parser::state::ShiftTarget::new(303, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 78, 79, 80, 80, 82,]; let
            shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![80]; __reduce_map
            .extend(__rustylr_tset46.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [80,]; let shifted : & 'static [u8] = & [4,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![82]; __reduce_map.extend(__rustylr_tset13.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [82,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![184]; __reduce_map.extend(__rustylr_tset38.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [184,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![185]; __reduce_map.extend(__rustylr_tset38.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [185,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::comma,
            ::rusty_lr::parser::state::ShiftTarget::new(307, true)),
            (translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(309, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [106, 186,]; let shifted : &
            'static [u8] = & [2, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(295, true)),
            (translation_unitNonTerminals::direct_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(12, true)),
            (translation_unitNonTerminals::init_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(308, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [120,
            121, 122, 123, 124, 125, 126, 127, 183, 184, 186,]; let shifted : & 'static
            [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,]; rules.iter().zip(shifted.iter())
            .map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule
            as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![186]; __reduce_map
            .extend(__rustylr_tset38.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [186,]; let shifted : & 'static [u8] = & [3,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![106]; __reduce_map.extend(__rustylr_tset45.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [106,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![187]; __reduce_map.extend(__rustylr_tset47.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [187,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(249, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::lbrace,
            ::rusty_lr::parser::state::ShiftTarget::new(248, true)),
            (translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(252, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),
            (translation_unitTerminalClasses::case,
            ::rusty_lr::parser::state::ShiftTarget::new(253, true)),
            (translation_unitTerminalClasses::default,
            ::rusty_lr::parser::state::ShiftTarget::new(256, true)),
            (translation_unitTerminalClasses::if_,
            ::rusty_lr::parser::state::ShiftTarget::new(258, true)),
            (translation_unitTerminalClasses::switch,
            ::rusty_lr::parser::state::ShiftTarget::new(262, true)),
            (translation_unitTerminalClasses::while_,
            ::rusty_lr::parser::state::ShiftTarget::new(266, true)),
            (translation_unitTerminalClasses::do_,
            ::rusty_lr::parser::state::ShiftTarget::new(270, true)),
            (translation_unitTerminalClasses::for_,
            ::rusty_lr::parser::state::ShiftTarget::new(271, true)),
            (translation_unitTerminalClasses::goto_,
            ::rusty_lr::parser::state::ShiftTarget::new(278, true)),
            (translation_unitTerminalClasses::continue_,
            ::rusty_lr::parser::state::ShiftTarget::new(281, true)),
            (translation_unitTerminalClasses::break_,
            ::rusty_lr::parser::state::ShiftTarget::new(283, true)),
            (translation_unitTerminalClasses::return_,
            ::rusty_lr::parser::state::ShiftTarget::new(285, true)),
            (translation_unitTerminalClasses::typedef,
            ::rusty_lr::parser::state::ShiftTarget::new(16, true)),
            (translation_unitTerminalClasses::extern_,
            ::rusty_lr::parser::state::ShiftTarget::new(17, true)),
            (translation_unitTerminalClasses::static_,
            ::rusty_lr::parser::state::ShiftTarget::new(18, true)),
            (translation_unitTerminalClasses::auto,
            ::rusty_lr::parser::state::ShiftTarget::new(19, true)),
            (translation_unitTerminalClasses::register,
            ::rusty_lr::parser::state::ShiftTarget::new(20, true)),
            (translation_unitTerminalClasses::const_,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)),
            (translation_unitTerminalClasses::volatile,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (translation_unitTerminalClasses::void_,
            ::rusty_lr::parser::state::ShiftTarget::new(21, true)),
            (translation_unitTerminalClasses::char_,
            ::rusty_lr::parser::state::ShiftTarget::new(22, true)),
            (translation_unitTerminalClasses::short_,
            ::rusty_lr::parser::state::ShiftTarget::new(23, true)),
            (translation_unitTerminalClasses::int_,
            ::rusty_lr::parser::state::ShiftTarget::new(24, true)),
            (translation_unitTerminalClasses::long_,
            ::rusty_lr::parser::state::ShiftTarget::new(25, true)),
            (translation_unitTerminalClasses::float_,
            ::rusty_lr::parser::state::ShiftTarget::new(26, true)),
            (translation_unitTerminalClasses::double_,
            ::rusty_lr::parser::state::ShiftTarget::new(27, true)),
            (translation_unitTerminalClasses::signed,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),
            (translation_unitTerminalClasses::unsigned,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (translation_unitTerminalClasses::struct_,
            ::rusty_lr::parser::state::ShiftTarget::new(30, true)),
            (translation_unitTerminalClasses::union_,
            ::rusty_lr::parser::state::ShiftTarget::new(31, true)),
            (translation_unitTerminalClasses::enum_,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::labeled_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(312, true)),
            (translation_unitNonTerminals::statement_or_declaration,
            ::rusty_lr::parser::state::ShiftTarget::new(312, true)),
            (translation_unitNonTerminals::compound_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(312, true)),
            (translation_unitNonTerminals::expression_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(312, true)),
            (translation_unitNonTerminals::selection_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(312, true)),
            (translation_unitNonTerminals::iteration_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(312, true)),
            (translation_unitNonTerminals::jump_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(312, true)),
            (translation_unitNonTerminals::declaration,
            ::rusty_lr::parser::state::ShiftTarget::new(312, true)),
            (translation_unitNonTerminals::statement,
            ::rusty_lr::parser::state::ShiftTarget::new(312, true)),
            (translation_unitNonTerminals::type_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(133, true)),
            (translation_unitNonTerminals::type_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(134, true)),
            (translation_unitNonTerminals::storage_class_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(135, true)),
            (translation_unitNonTerminals::declaration_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(136, true)),
            (translation_unitNonTerminals::struct_or_union,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (translation_unitNonTerminals::struct_or_union_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(128, true)),
            (translation_unitNonTerminals::enum_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(129, true)),
            (translation_unitNonTerminals::_declaration_specifierPlus60,
            ::rusty_lr::parser::state::ShiftTarget::new(293, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![189]; __reduce_map.extend(__rustylr_tset32.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
            14, 15, 16, 17, 18, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,
            35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,
            54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72,
            73, 74, 75, 76, 77, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 96, 97, 98,
            99, 100, 101, 102, 103, 104, 105, 106, 109, 110, 111, 112, 113, 114, 118,
            119, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156,
            157, 158, 159, 160, 161, 162, 170, 171, 175, 176, 177, 178, 188, 189, 191,
            192,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![188]; __reduce_map.extend(__rustylr_tset47.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [188,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::rbrace,
            ::rusty_lr::parser::state::ShiftTarget::new(314, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [88,]; let shifted : & 'static
            [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![88]; __reduce_map.extend(__rustylr_tset48.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [88,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::while_,
            ::rusty_lr::parser::state::ShiftTarget::new(316, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [97,]; let shifted : & 'static
            [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(317, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [97,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(318, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(318, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(318, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 97,]; let shifted
            : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 4,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::rparen,
            ::rusty_lr::parser::state::ShiftTarget::new(319, true)),
            (translation_unitTerminalClasses::comma,
            ::rusty_lr::parser::state::ShiftTarget::new(116, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [77, 97,]; let shifted : & 'static
            [u8] = & [1, 5,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted)
            | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(320, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            ruleset : { let rules : & 'static [u8] = & [97,]; let shifted : & 'static
            [u8] = & [6,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![97]; __reduce_map.extend(__rustylr_tset44.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [97,]; let shifted : & 'static [u8] = & [7,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![96]; __reduce_map.extend(__rustylr_tset44.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [96,]; let shifted : & 'static [u8] = & [5,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![93]; __reduce_map.extend(__rustylr_tset44.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [93,]; let shifted : & 'static [u8] = & [5,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::else_,
            ::rusty_lr::parser::state::ShiftTarget::new(324, true)),],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![91]; __reduce_map
            .extend(__rustylr_tset47.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [91, 92,]; let shifted : & 'static [u8] = & [5, 5,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(251, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (translation_unitTerminalClasses::string_literal,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (translation_unitTerminalClasses::constant_character,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)),
            (translation_unitTerminalClasses::constant_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (translation_unitTerminalClasses::constant_long,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)),
            (translation_unitTerminalClasses::constant_unsigned_integer,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (translation_unitTerminalClasses::constant_unsigned_long,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),
            (translation_unitTerminalClasses::constant_float,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (translation_unitTerminalClasses::constant_double,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)),
            (translation_unitTerminalClasses::lbrace,
            ::rusty_lr::parser::state::ShiftTarget::new(248, true)),
            (translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(252, true)),
            (translation_unitTerminalClasses::inc_op,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (translation_unitTerminalClasses::dec_op,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (translation_unitTerminalClasses::sizeof,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)),
            (translation_unitTerminalClasses::ampersand,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),
            (translation_unitTerminalClasses::exclamation,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (translation_unitTerminalClasses::tilde,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)),
            (translation_unitTerminalClasses::minus,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (translation_unitTerminalClasses::plus,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),
            (translation_unitTerminalClasses::case,
            ::rusty_lr::parser::state::ShiftTarget::new(253, true)),
            (translation_unitTerminalClasses::default,
            ::rusty_lr::parser::state::ShiftTarget::new(256, true)),
            (translation_unitTerminalClasses::if_,
            ::rusty_lr::parser::state::ShiftTarget::new(258, true)),
            (translation_unitTerminalClasses::switch,
            ::rusty_lr::parser::state::ShiftTarget::new(262, true)),
            (translation_unitTerminalClasses::while_,
            ::rusty_lr::parser::state::ShiftTarget::new(266, true)),
            (translation_unitTerminalClasses::do_,
            ::rusty_lr::parser::state::ShiftTarget::new(270, true)),
            (translation_unitTerminalClasses::for_,
            ::rusty_lr::parser::state::ShiftTarget::new(271, true)),
            (translation_unitTerminalClasses::goto_,
            ::rusty_lr::parser::state::ShiftTarget::new(278, true)),
            (translation_unitTerminalClasses::continue_,
            ::rusty_lr::parser::state::ShiftTarget::new(281, true)),
            (translation_unitTerminalClasses::break_,
            ::rusty_lr::parser::state::ShiftTarget::new(283, true)),
            (translation_unitTerminalClasses::return_,
            ::rusty_lr::parser::state::ShiftTarget::new(285, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::Constant,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::primary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::postfix_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)),
            (translation_unitNonTerminals::unary_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)),
            (translation_unitNonTerminals::cast_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::multiplicative_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)),
            (translation_unitNonTerminals::additive_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),
            (translation_unitNonTerminals::shift_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),
            (translation_unitNonTerminals::relational_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)),
            (translation_unitNonTerminals::equality_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),
            (translation_unitNonTerminals::and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (translation_unitNonTerminals::exclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (translation_unitNonTerminals::inclusive_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (translation_unitNonTerminals::logical_and_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(109, true)),
            (translation_unitNonTerminals::logical_or_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),
            (translation_unitNonTerminals::conditional_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::assignment_expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::expression,
            ::rusty_lr::parser::state::ShiftTarget::new(273, true)),
            (translation_unitNonTerminals::labeled_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(325, true)),
            (translation_unitNonTerminals::compound_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(325, true)),
            (translation_unitNonTerminals::expression_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(325, true)),
            (translation_unitNonTerminals::selection_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(325, true)),
            (translation_unitNonTerminals::iteration_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(325, true)),
            (translation_unitNonTerminals::jump_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(325, true)),
            (translation_unitNonTerminals::statement,
            ::rusty_lr::parser::state::ShiftTarget::new(325, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [0, 1,
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
            44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
            63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 83, 84, 85, 88,
            89, 90, 91, 92, 92, 93, 96, 97, 98, 99, 100, 101, 102, 103, 104, 109, 110,
            111, 112, 113, 114,]; let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![92]; __reduce_map
            .extend(__rustylr_tset44.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [92,]; let shifted : & 'static [u8] = & [7,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![85]; __reduce_map.extend(__rustylr_tset44.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [85,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![84]; __reduce_map.extend(__rustylr_tset44.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [84,]; let shifted : & 'static [u8] = & [4,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![83]; __reduce_map.extend(__rustylr_tset44.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [83,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![108]; __reduce_map.extend(__rustylr_tset39.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [108,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)),
            (translation_unitTerminalClasses::semicolon,
            ::rusty_lr::parser::state::ShiftTarget::new(294, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)),
            (translation_unitTerminalClasses::typedef,
            ::rusty_lr::parser::state::ShiftTarget::new(16, true)),
            (translation_unitTerminalClasses::extern_,
            ::rusty_lr::parser::state::ShiftTarget::new(17, true)),
            (translation_unitTerminalClasses::static_,
            ::rusty_lr::parser::state::ShiftTarget::new(18, true)),
            (translation_unitTerminalClasses::auto,
            ::rusty_lr::parser::state::ShiftTarget::new(19, true)),
            (translation_unitTerminalClasses::register,
            ::rusty_lr::parser::state::ShiftTarget::new(20, true)),
            (translation_unitTerminalClasses::const_,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)),
            (translation_unitTerminalClasses::volatile,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (translation_unitTerminalClasses::void_,
            ::rusty_lr::parser::state::ShiftTarget::new(21, true)),
            (translation_unitTerminalClasses::char_,
            ::rusty_lr::parser::state::ShiftTarget::new(22, true)),
            (translation_unitTerminalClasses::short_,
            ::rusty_lr::parser::state::ShiftTarget::new(23, true)),
            (translation_unitTerminalClasses::int_,
            ::rusty_lr::parser::state::ShiftTarget::new(24, true)),
            (translation_unitTerminalClasses::long_,
            ::rusty_lr::parser::state::ShiftTarget::new(25, true)),
            (translation_unitTerminalClasses::float_,
            ::rusty_lr::parser::state::ShiftTarget::new(26, true)),
            (translation_unitTerminalClasses::double_,
            ::rusty_lr::parser::state::ShiftTarget::new(27, true)),
            (translation_unitTerminalClasses::signed,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),
            (translation_unitTerminalClasses::unsigned,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (translation_unitTerminalClasses::struct_,
            ::rusty_lr::parser::state::ShiftTarget::new(30, true)),
            (translation_unitTerminalClasses::union_,
            ::rusty_lr::parser::state::ShiftTarget::new(31, true)),
            (translation_unitTerminalClasses::enum_,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::type_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(133, true)),
            (translation_unitNonTerminals::declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(331, true)),
            (translation_unitNonTerminals::direct_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(12, true)),
            (translation_unitNonTerminals::type_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(134, true)),
            (translation_unitNonTerminals::storage_class_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(135, true)),
            (translation_unitNonTerminals::declaration_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(236, true)),
            (translation_unitNonTerminals::struct_or_union,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (translation_unitNonTerminals::struct_or_union_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(128, true)),
            (translation_unitNonTerminals::enum_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(129, true)),
            (translation_unitNonTerminals::init_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(305, true)),
            (translation_unitNonTerminals::init_declarator_list,
            ::rusty_lr::parser::state::ShiftTarget::new(306, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, ruleset : { let rules : & 'static [u8] = & [105,
            106, 107, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 143, 144, 145,
            146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160,
            161, 162, 170, 171, 175, 176, 177, 178, 183, 184, 185, 186, 192,]; let
            shifted : & 'static [u8] = & [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::lbrace,
            ::rusty_lr::parser::state::ShiftTarget::new(248, true)),
            (translation_unitTerminalClasses::assign,
            ::rusty_lr::parser::state::ShiftTarget::new(296, true)),],
            shift_goto_map_nonterm :
            vec![(translation_unitNonTerminals::compound_statement,
            ::rusty_lr::parser::state::ShiftTarget::new(332, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![183]; __reduce_map.extend(__rustylr_tset38.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [88, 107, 183, 184,]; let shifted : & 'static
            [u8] = & [0, 2, 1, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![107]; __reduce_map
            .extend(__rustylr_tset39.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, ruleset : { let rules : &
            'static [u8] = & [107,]; let shifted : & 'static [u8] = & [3,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(translation_unitTerminalClasses::ident,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)),
            (translation_unitTerminalClasses::lparen,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)),
            (translation_unitTerminalClasses::star,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)),
            (translation_unitTerminalClasses::typedef,
            ::rusty_lr::parser::state::ShiftTarget::new(16, true)),
            (translation_unitTerminalClasses::extern_,
            ::rusty_lr::parser::state::ShiftTarget::new(17, true)),
            (translation_unitTerminalClasses::static_,
            ::rusty_lr::parser::state::ShiftTarget::new(18, true)),
            (translation_unitTerminalClasses::auto,
            ::rusty_lr::parser::state::ShiftTarget::new(19, true)),
            (translation_unitTerminalClasses::register,
            ::rusty_lr::parser::state::ShiftTarget::new(20, true)),
            (translation_unitTerminalClasses::const_,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)),
            (translation_unitTerminalClasses::volatile,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)),
            (translation_unitTerminalClasses::void_,
            ::rusty_lr::parser::state::ShiftTarget::new(21, true)),
            (translation_unitTerminalClasses::char_,
            ::rusty_lr::parser::state::ShiftTarget::new(22, true)),
            (translation_unitTerminalClasses::short_,
            ::rusty_lr::parser::state::ShiftTarget::new(23, true)),
            (translation_unitTerminalClasses::int_,
            ::rusty_lr::parser::state::ShiftTarget::new(24, true)),
            (translation_unitTerminalClasses::long_,
            ::rusty_lr::parser::state::ShiftTarget::new(25, true)),
            (translation_unitTerminalClasses::float_,
            ::rusty_lr::parser::state::ShiftTarget::new(26, true)),
            (translation_unitTerminalClasses::double_,
            ::rusty_lr::parser::state::ShiftTarget::new(27, true)),
            (translation_unitTerminalClasses::signed,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),
            (translation_unitTerminalClasses::unsigned,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (translation_unitTerminalClasses::struct_,
            ::rusty_lr::parser::state::ShiftTarget::new(30, true)),
            (translation_unitTerminalClasses::union_,
            ::rusty_lr::parser::state::ShiftTarget::new(31, true)),
            (translation_unitTerminalClasses::enum_,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),],
            shift_goto_map_nonterm : vec![(translation_unitNonTerminals::declaration,
            ::rusty_lr::parser::state::ShiftTarget::new(334, true)),
            (translation_unitNonTerminals::function_definition,
            ::rusty_lr::parser::state::ShiftTarget::new(334, true)),
            (translation_unitNonTerminals::external_declaration,
            ::rusty_lr::parser::state::ShiftTarget::new(334, true)),
            (translation_unitNonTerminals::type_qualifier,
            ::rusty_lr::parser::state::ShiftTarget::new(133, true)),
            (translation_unitNonTerminals::declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(247, true)),
            (translation_unitNonTerminals::direct_declarator,
            ::rusty_lr::parser::state::ShiftTarget::new(12, true)),
            (translation_unitNonTerminals::type_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(134, true)),
            (translation_unitNonTerminals::storage_class_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(135, true)),
            (translation_unitNonTerminals::declaration_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(136, true)),
            (translation_unitNonTerminals::struct_or_union,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (translation_unitNonTerminals::struct_or_union_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(128, true)),
            (translation_unitNonTerminals::enum_specifier,
            ::rusty_lr::parser::state::ShiftTarget::new(129, true)),
            (translation_unitNonTerminals::_declaration_specifierPlus60,
            ::rusty_lr::parser::state::ShiftTarget::new(330, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![195]; __reduce_map.extend(__rustylr_tset0.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [105, 106, 107, 108, 115, 116, 118, 119, 120,
            121, 122, 123, 124, 125, 126, 127, 143, 144, 145, 146, 147, 148, 149, 150,
            151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 170, 171, 175,
            176, 177, 178, 191, 192, 194, 195,]; let shifted : & 'static [u8] = & [0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![194]; __reduce_map.extend(__rustylr_tset39.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [194,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], shift_goto_map_nonterm : vec![], reduce_map : {
            let mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![117]; __reduce_map.extend(__rustylr_tset0.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, ruleset : {
            let rules : & 'static [u8] = & [117,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } },
        ];
        let states: Vec<translation_unitState> = states
            .into_iter()
            .map(|state| state.into())
            .collect();
        Self { rules, states }
    }
}

// ==============================Generated Codes End===============================
        